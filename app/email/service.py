"""Email service for sending HTML emails via BackgroundTasks.

Emails are dispatched via BackgroundTasks (post-response), which runs AFTER
the DB session commits (see app/core/deps.py get_db). This structural guarantee
means email is never sent if the DB transaction rolls back.
"""

import logging
import re
from functools import lru_cache
from pathlib import Path
from typing import Annotated

from fastapi import BackgroundTasks, Depends
from fastapi_mail import ConnectionConfig, FastMail, MessageSchema, MessageType
from fastapi_mail.schemas import MultipartSubtypeEnum
from jinja2 import Environment, FileSystemLoader

from app.core.config import get_settings

TEMPLATE_FOLDER = Path(__file__).parent / "templates"


def get_email_config() -> ConnectionConfig:
    """Build ConnectionConfig from application settings."""
    s = get_settings()
    return ConnectionConfig(
        MAIL_USERNAME=s.MAIL_USERNAME,
        MAIL_PASSWORD=s.MAIL_PASSWORD,
        MAIL_FROM=s.MAIL_FROM,
        MAIL_PORT=s.MAIL_PORT,
        MAIL_SERVER=s.MAIL_SERVER,
        MAIL_FROM_NAME=s.MAIL_FROM_NAME,
        MAIL_STARTTLS=True,
        MAIL_SSL_TLS=False,
        USE_CREDENTIALS=True,
        VALIDATE_CERTS=True,
        SUPPRESS_SEND=s.MAIL_SUPPRESS_SEND,
        TEMPLATE_FOLDER=TEMPLATE_FOLDER,
    )


class EmailService:
    """Reusable email service wrapping FastMail.

    Usage pattern (in routers):
        email_svc.enqueue(background_tasks, to, template_name, subject, context)

    The enqueue() method adds the send to BackgroundTasks. Because
    BackgroundTasks run AFTER the response is sent (which is after
    get_db commits), email is never dispatched if the DB transaction
    rolls back. This is a structural guarantee — see app/core/deps.py.
    """

    def __init__(self, config: ConnectionConfig) -> None:
        self.fm = FastMail(config)
        self._logger = logging.getLogger(__name__)
        self._jinja_env = Environment(
            loader=FileSystemLoader(str(TEMPLATE_FOLDER)),
            autoescape=True,
        )

    @staticmethod
    def _strip_html(html: str) -> str:
        """Auto-generate plain-text fallback by stripping HTML tags.

        Block-level closing tags (</h1>, </p>, </div>, etc.) are replaced with
        a space before removal so adjacent text nodes are not run together.
        All remaining tags are then removed and whitespace is collapsed.
        """
        # Replace block-level closing tags with a space to separate text nodes
        text = re.sub(r'</(?:h[1-6]|p|div|li|tr|td|th|section|article|header|footer|main|nav|aside|blockquote|pre)>', ' ', html, flags=re.IGNORECASE)
        # Remove all remaining tags
        text = re.sub(r'<[^>]+>', '', text)
        # Collapse whitespace runs into single spaces
        return re.sub(r'\s+', ' ', text).strip()

    def _render_plain_text(self, template_name: str, context: dict) -> str:
        """Render the Jinja2 template to HTML, then strip tags for plain-text fallback.

        This implements the CONTEXT.md locked decision: 'plain-text fallback
        auto-generated by stripping HTML tags from rendered output — no
        separate .txt templates'.
        """
        template = self._jinja_env.get_template(template_name)
        rendered_html = template.render(**context)
        return self._strip_html(rendered_html)

    def enqueue(
        self,
        background_tasks: BackgroundTasks,
        to: str,
        template_name: str,
        subject: str,
        context: dict,
    ) -> None:
        """Add email send to BackgroundTasks (post-commit safe).

        Renders the template to generate a plain-text fallback via
        _strip_html(), then builds a multipart/alternative MessageSchema
        with both HTML (via template_body) and plain text (via alternative_body).

        Args:
            background_tasks: FastAPI BackgroundTasks instance from the route.
            to: Recipient email address (single).
            template_name: Jinja2 template filename (e.g. "order_confirmation.html").
            subject: Email subject line.
            context: Dict of template variables passed to Jinja2.
        """
        plain_text = self._render_plain_text(template_name, context)
        message = MessageSchema(
            subject=subject,
            recipients=[to],
            template_body=context,
            subtype=MessageType.html,
            alternative_body=plain_text,
            multipart_subtype=MultipartSubtypeEnum.alternative,
        )
        background_tasks.add_task(self._send, message, template_name)

    async def _send(self, message: MessageSchema, template_name: str) -> None:
        """Internal: send the email. Logs and drops on failure."""
        try:
            await self.fm.send_message(message, template_name=template_name)
        except Exception as exc:
            self._logger.error(
                "Email send failed: recipient=%s template=%s error=%s",
                message.recipients,
                template_name,
                str(exc),
            )


@lru_cache
def get_email_service() -> EmailService:
    """Return a cached EmailService instance.

    Cached via @lru_cache — FastMail(config) is reused across requests.
    In tests, call get_email_service.cache_clear() to reset.
    """
    return EmailService(config=get_email_config())


EmailSvc = Annotated[EmailService, Depends(get_email_service)]
