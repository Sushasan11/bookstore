---
phase: 18-review-moderation-dashboard
plan: 02
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - app/reviews/repository.py
  - app/admin/reviews_router.py
  - tests/test_review_moderation.py
autonomous: true
requirements: [MOD-02]

must_haves:
  truths:
    - "Admin can call DELETE /admin/reviews/bulk with a list of review IDs and have all matching non-deleted reviews soft-deleted in a single operation"
    - "Soft-deleted reviews do not reappear in subsequent calls to GET /admin/reviews"
    - "Bulk delete response returns deleted_count reflecting only reviews actually soft-deleted"
    - "Missing or already-deleted review IDs are silently skipped (best-effort semantics)"
    - "Bulk delete request with more than 50 IDs returns 422"
    - "Bulk delete request with empty ID list returns 422"
    - "Non-admin users receive 403 on bulk delete, unauthenticated users receive 401"
    - "Integration tests comprehensively cover both GET /admin/reviews (MOD-01) and DELETE /admin/reviews/bulk (MOD-02)"
  artifacts:
    - path: "app/reviews/repository.py"
      provides: "bulk_soft_delete() method on ReviewRepository"
      contains: "async def bulk_soft_delete"
    - path: "app/admin/reviews_router.py"
      provides: "DELETE /admin/reviews/bulk endpoint"
      contains: "async def bulk_delete_reviews"
    - path: "tests/test_review_moderation.py"
      provides: "Integration tests for MOD-01 and MOD-02"
      min_lines: 250
  key_links:
    - from: "app/admin/reviews_router.py"
      to: "app/reviews/repository.py"
      via: "ReviewRepository(db).bulk_soft_delete(body.review_ids)"
      pattern: "repo\\.bulk_soft_delete"
    - from: "app/admin/reviews_router.py"
      to: "app/admin/reviews_schemas.py"
      via: "response_model=BulkDeleteResponse, body: BulkDeleteRequest"
      pattern: "BulkDeleteResponse"
    - from: "tests/test_review_moderation.py"
      to: "app/admin/reviews_router.py"
      via: "HTTP calls to /admin/reviews and /admin/reviews/bulk"
      pattern: "/admin/reviews"
---

<objective>
Implement the bulk delete endpoint and comprehensive integration tests for both review moderation endpoints.

Purpose: Deliver MOD-02 — admins can bulk soft-delete reviews by providing a list of IDs. Also create the full integration test suite covering both MOD-01 (list with filters/sort/pagination from Plan 01) and MOD-02 (bulk delete). This completes Phase 18 and the v2.1 milestone.

Output: Working `DELETE /admin/reviews/bulk` endpoint, `bulk_soft_delete()` repository method, and comprehensive integration test file with 20+ tests.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-review-moderation-dashboard/18-01-SUMMARY.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase and Plan 01. -->
<!-- Executor should use these directly — no codebase exploration needed. -->

From app/admin/reviews_schemas.py (created in Plan 01):
```python
class AdminReviewAuthor(BaseModel):
    user_id: int
    display_name: str

class AdminReviewBook(BaseModel):
    book_id: int
    title: str

class AdminReviewEntry(BaseModel):
    id: int
    rating: int
    text: str | None
    created_at: datetime
    updated_at: datetime
    author: AdminReviewAuthor
    book: AdminReviewBook
    model_config = {"from_attributes": True}

class AdminReviewListResponse(BaseModel):
    items: list[AdminReviewEntry]
    total_count: int
    page: int
    per_page: int
    total_pages: int

class BulkDeleteRequest(BaseModel):
    review_ids: list[int] = Field(min_length=1, max_length=50)

class BulkDeleteResponse(BaseModel):
    deleted_count: int
```

From app/admin/reviews_router.py (created in Plan 01):
```python
router = APIRouter(
    prefix="/admin/reviews",
    tags=["admin-reviews"],
    dependencies=[Depends(require_admin)],
)

@router.get("", response_model=AdminReviewListResponse)
async def list_reviews(db, _admin, page, per_page, book_id, user_id,
                       rating_min, rating_max, sort_by, sort_dir):
    ...
# DELETE /bulk endpoint to be added in this plan
```

From app/reviews/repository.py (list_all_admin() from Plan 01):
```python
class ReviewRepository:
    def __init__(self, session: AsyncSession) -> None:
        self.session = session

    async def list_all_admin(self, *, page, per_page, book_id, user_id,
                             rating_min, rating_max, sort_by, sort_dir
                             ) -> tuple[list[Review], int]: ...

    async def soft_delete(self, review: Review) -> None:
        review.deleted_at = datetime.now(UTC)
        await self.session.flush()

    # bulk_soft_delete() to be added in this plan
```

From app/reviews/models.py:
```python
class Review(Base):
    __tablename__ = "reviews"
    id: Mapped[int]
    user_id: Mapped[int]              # ForeignKey("users.id")
    book_id: Mapped[int]              # ForeignKey("books.id")
    rating: Mapped[int]               # 1-5
    text: Mapped[str | None]
    created_at: Mapped[datetime]
    updated_at: Mapped[datetime]
    deleted_at: Mapped[datetime | None]
    book: Mapped[Book] = relationship()
    user: Mapped[User] = relationship()
```

From app/core/deps.py:
```python
AdminUser = Annotated[dict, Depends(require_admin)]
DbSession = Annotated[AsyncSession, Depends(get_db)]
```

From tests/test_sales_analytics.py (fixture pattern):
```python
@pytest_asyncio.fixture
async def admin_headers(client: AsyncClient, db_session: AsyncSession) -> dict:
    repo = UserRepository(db_session)
    hashed = await hash_password("adminpass123")
    user = await repo.create(email="admin_analytics@example.com", hashed_password=hashed)
    await repo.set_role_admin(user.id)
    await db_session.flush()
    resp = await client.post("/auth/login", json={"email": "...", "password": "..."})
    return {"Authorization": f"Bearer {resp.json()['access_token']}"}
```

From STATE.md (bulk delete pattern):
```
bulk_delete uses single UPDATE ... WHERE id IN (...) with synchronize_session="fetch"
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add bulk_soft_delete() to ReviewRepository and DELETE /admin/reviews/bulk endpoint</name>
  <files>
    app/reviews/repository.py
    app/admin/reviews_router.py
  </files>
  <action>
**1. Add `bulk_soft_delete()` method to `ReviewRepository`** in `app/reviews/repository.py`:

Add `update` to the existing SQLAlchemy import (which after Plan 01 is `from sqlalchemy import asc, desc, func, select`). It becomes:
```python
from sqlalchemy import asc, desc, func, select, update
```

Add the following method to the `ReviewRepository` class after the existing `list_all_admin()` method:

```python
async def bulk_soft_delete(self, review_ids: list[int]) -> int:
    """Soft-delete multiple reviews by ID list in a single UPDATE.

    Best-effort: silently skips IDs that are missing or already soft-deleted.
    Returns the count of reviews actually soft-deleted.

    Uses synchronize_session="fetch" per project convention (STATE.md).
    """
    if not review_ids:
        return 0

    result = await self.session.execute(
        update(Review)
        .where(Review.id.in_(review_ids), Review.deleted_at.is_(None))
        .values(deleted_at=datetime.now(UTC))
        .execution_options(synchronize_session="fetch")
    )
    return result.rowcount
```

Key details:
- Single `UPDATE ... WHERE id IN (...) AND deleted_at IS NULL` — O(1) DB round-trips
- `synchronize_session="fetch"` — project-established pattern from STATE.md
- `datetime.now(UTC)` — already imported at top of file (`from datetime import UTC, datetime`)
- Returns `result.rowcount` — DB-reported count of affected rows
- Empty list guard returns 0 immediately — no unnecessary DB call
- No `selectinload` or `options()` — this is a write-only operation, no relationship data needed
- `update` import from sqlalchemy (not `Update`) — lowercase function form

**2. Add `DELETE /admin/reviews/bulk` endpoint** to `app/admin/reviews_router.py`:

The endpoint goes after the existing `list_reviews` function. Add the following:

```python
@router.delete("/bulk", response_model=BulkDeleteResponse)
async def bulk_delete_reviews(
    body: BulkDeleteRequest,
    db: DbSession,
    _admin: AdminUser,
) -> BulkDeleteResponse:
    """Bulk soft-delete reviews by ID list.

    Accepts up to 50 review IDs. Best-effort: silently skips IDs that are
    missing or already soft-deleted. Returns count of actually deleted reviews.

    Admin only. Empty list or >50 IDs returns 422.
    """
    repo = ReviewRepository(db)
    deleted_count = await repo.bulk_soft_delete(body.review_ids)
    return BulkDeleteResponse(deleted_count=deleted_count)
```

Key details:
- `BulkDeleteRequest` and `BulkDeleteResponse` are already imported from `reviews_schemas` in Plan 01
- `body: BulkDeleteRequest` — FastAPI reads JSON body with Pydantic validation (min_length=1, max_length=50)
- No try/except needed — best-effort semantics handle all edge cases via the WHERE clause
- Router-level `Depends(require_admin)` already protects this endpoint (set in Plan 01)
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && python -c "from app.reviews.repository import ReviewRepository; assert hasattr(ReviewRepository, 'bulk_soft_delete'), 'bulk_soft_delete not found'; from app.admin.reviews_router import bulk_delete_reviews; print('Bulk delete endpoint and repository method OK')"</automated>
  </verify>
  <done>
    - ReviewRepository.bulk_soft_delete(review_ids) method exists
    - Uses single UPDATE...WHERE IN with synchronize_session="fetch"
    - Returns rowcount (int) — count of actually soft-deleted reviews
    - Empty list guard returns 0
    - DELETE /admin/reviews/bulk endpoint exists on the reviews admin router
    - Accepts BulkDeleteRequest body (max 50 IDs)
    - Returns BulkDeleteResponse with deleted_count
  </done>
</task>

<task type="auto">
  <name>Task 2: Create comprehensive integration tests for admin review moderation (MOD-01 and MOD-02)</name>
  <files>
    tests/test_review_moderation.py
  </files>
  <action>
Create `tests/test_review_moderation.py` with comprehensive integration tests for both MOD-01 and MOD-02.

**File header and imports:**

```python
"""Integration tests for Phase 18 review moderation dashboard.

Tests cover:
  - MOD-01: GET /admin/reviews — auth, pagination, filtering, sorting, soft-delete exclusion
  - MOD-02: DELETE /admin/reviews/bulk — auth, best-effort semantics, soft-delete, validation
"""

from datetime import UTC, datetime
from decimal import Decimal

import pytest_asyncio
from httpx import AsyncClient
from sqlalchemy.ext.asyncio import AsyncSession

from app.books.models import Book, Genre
from app.core.security import hash_password
from app.reviews.models import Review
from app.users.repository import UserRepository

LIST_URL = "/admin/reviews"
BULK_DELETE_URL = "/admin/reviews/bulk"
LOGIN_URL = "/auth/login"
```

**Fixtures:**

Use `revmod_` prefix for test user emails (per RESEARCH.md convention).

`admin_headers` fixture — Create admin user with email `revmod_admin@example.com`, password `adminpass123`. Follow exact pattern from `tests/test_sales_analytics.py` (create via `UserRepository`, `set_role_admin`, flush, login, return Bearer headers).

`user_headers` fixture — Create regular user with email `revmod_user@example.com`, password `userpass123`. Same pattern, no `set_role_admin`. Return user object AND headers as tuple `(user, headers)` — the user is needed to create reviews owned by this user for filtering tests.

`review_data` fixture — depends on `admin_headers` and `user_headers`. Creates test data:

1. Create a Genre ("Moderation Test Genre")
2. Create 2 books:
   - Book A: title="Book Alpha", author="Author A", price=10.00
   - Book B: title="Book Beta", author="Author B", price=20.00
3. Create a second regular user (`revmod_reviewer@example.com`) for multi-user filtering
4. Create 5 reviews across the two users and two books with varying ratings:
   - Review 1: user=revmod_user, book=Book A, rating=5, text="Excellent"
   - Review 2: user=revmod_user, book=Book B, rating=2, text="Poor"
   - Review 3: user=revmod_reviewer, book=Book A, rating=3, text="Average"
   - Review 4: user=revmod_reviewer, book=Book B, rating=1, text="Terrible"
   - Review 5: user=revmod_reviewer, book=Book A, rating=4, text=None (rating-only)
5. Soft-delete Review 4 directly: `review4.deleted_at = datetime.now(UTC)`, then flush
6. Return a dict with all entities: `{"books": [book_a, book_b], "users": [user1, user2], "reviews": [r1, r2, r3, r4, r5], "deleted_review": r4}`

This gives us:
- 4 active reviews (r1, r2, r3, r5), 1 soft-deleted (r4)
- 2 books, 2 users (non-admin reviewers), varying ratings 1-5
- Filters testable: book_id, user_id, rating_min/max combinations
- Sort testable: by date and rating, both directions

**Test classes and methods:**

`class TestAdminReviewListAuth:` — Auth gate tests
- `test_list_reviews_requires_auth`: GET /admin/reviews without headers returns 401
- `test_list_reviews_requires_admin`: GET /admin/reviews with `user_headers` (extract just headers) returns 403

`class TestAdminReviewListBasic:` — Basic list behavior (all use `admin_headers` + `review_data`)
- `test_list_reviews_returns_all_active`: GET /admin/reviews, verify 200, `total_count == 4` (soft-deleted r4 excluded), `len(items) == 4`
- `test_soft_deleted_review_excluded`: Verify that review with r4's id does NOT appear in items
- `test_response_schema_fields`: Verify response has keys: items, total_count, page, per_page, total_pages. Verify first item has keys: id, rating, text, created_at, updated_at, author, book. Verify author has: user_id, display_name. Verify book has: book_id, title.
- `test_default_pagination`: Verify `page == 1`, `per_page == 20`, `total_pages == 1` (since only 4 reviews)

`class TestAdminReviewListPagination:` — Pagination behavior (uses `admin_headers` + `review_data`)
- `test_pagination_limits_items`: GET with `?per_page=2&page=1`, verify `len(items) == 2`, `total_count == 4`, `total_pages == 2`
- `test_pagination_page_2`: GET with `?per_page=2&page=2`, verify `len(items) == 2` (items from page 2)
- `test_pagination_beyond_last_page`: GET with `?per_page=2&page=3`, verify `len(items) == 0`, `total_count == 4`

`class TestAdminReviewListFilters:` — Filter behavior (uses `admin_headers` + `review_data`)
- `test_filter_by_book_id`: GET with `?book_id={book_a.id}`, verify all returned reviews have `book.book_id == book_a.id`, `total_count == 3` (r1, r3, r5 on Book A)
- `test_filter_by_user_id`: GET with `?user_id={user1.id}`, verify all returned reviews have `author.user_id == user1.id`, `total_count == 2` (r1, r2 by user1)
- `test_filter_by_rating_min`: GET with `?rating_min=4`, verify all items have `rating >= 4`, `total_count == 2` (r1=5, r5=4)
- `test_filter_by_rating_max`: GET with `?rating_max=2`, verify all items have `rating <= 2`, `total_count == 1` (r2=2; r4=1 is soft-deleted)
- `test_filter_by_rating_range`: GET with `?rating_min=2&rating_max=4`, verify all items have `2 <= rating <= 4`, `total_count == 3` (r2=2, r3=3, r5=4)
- `test_combined_filters_are_and`: GET with `?book_id={book_a.id}&rating_min=4`, verify `total_count == 2` (r1=5 and r5=4 on Book A)
- `test_invalid_rating_min_returns_422`: GET with `?rating_min=0`, verify 422
- `test_invalid_rating_max_returns_422`: GET with `?rating_max=6`, verify 422

`class TestAdminReviewListSorting:` — Sort behavior (uses `admin_headers` + `review_data`)
- `test_default_sort_is_date_desc`: GET with no sort params, verify items are ordered by `created_at` descending (compare consecutive items)
- `test_sort_by_rating_asc`: GET with `?sort_by=rating&sort_dir=asc`, verify items ratings are in ascending order
- `test_sort_by_rating_desc`: GET with `?sort_by=rating&sort_dir=desc`, verify items ratings are in descending order
- `test_sort_by_date_asc`: GET with `?sort_by=date&sort_dir=asc`, verify items are ordered by `created_at` ascending
- `test_invalid_sort_by_returns_422`: GET with `?sort_by=invalid`, verify 422
- `test_invalid_sort_dir_returns_422`: GET with `?sort_dir=invalid`, verify 422

`class TestBulkDeleteAuth:` — Auth gate tests
- `test_bulk_delete_requires_auth`: DELETE /admin/reviews/bulk without headers returns 401
- `test_bulk_delete_requires_admin`: DELETE /admin/reviews/bulk with `user_headers` returns 403

`class TestBulkDeleteBehavior:` — Core behavior (uses `admin_headers` + `review_data`)
- `test_bulk_delete_soft_deletes_reviews`: DELETE with `review_ids=[r1.id, r2.id]`, verify 200, `deleted_count == 2`. Then GET /admin/reviews, verify r1 and r2 no longer appear, `total_count == 2` (only r3, r5 remain)
- `test_bulk_delete_skips_already_deleted`: DELETE with `review_ids=[r4.id]` (r4 already soft-deleted), verify `deleted_count == 0`
- `test_bulk_delete_skips_nonexistent_ids`: DELETE with `review_ids=[99999]`, verify `deleted_count == 0`
- `test_bulk_delete_mixed_valid_invalid`: DELETE with `review_ids=[r1.id, r4.id, 99999]`, verify `deleted_count == 1` (only r1 actually deleted; r4 already deleted, 99999 missing)
- `test_bulk_delete_empty_list_returns_422`: DELETE with `review_ids=[]`, verify 422 (min_length=1)
- `test_bulk_delete_exceeds_max_returns_422`: DELETE with `review_ids=list(range(1, 52))` (51 IDs), verify 422 (max_length=50)
- `test_deleted_reviews_not_in_subsequent_list`: DELETE with `review_ids=[r3.id]`, then GET /admin/reviews, verify r3's id not in returned item ids

All tests follow the test patterns from `tests/test_sales_analytics.py`:
- Use `pytest_asyncio` fixtures, no `@pytest.mark.asyncio` decorators (rely on `asyncio_mode = "auto"`)
- HTTP requests via `client.get()` / `client.delete()` with `headers=admin_headers`
- Assert status codes first, then parse `resp.json()` for field assertions
- Use `revmod_` email prefix to avoid fixture collisions with other test files
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && python -m pytest tests/test_review_moderation.py -x -v 2>&1 | tail -40</automated>
  </verify>
  <done>
    - All integration tests pass (25+ test methods)
    - Auth gates: 401 without token, 403 for regular user (both endpoints)
    - MOD-01 list tests: default pagination, custom pagination, all filters (book_id, user_id, rating_min, rating_max), combined AND filters, all sort combinations, soft-delete exclusion, schema validation, 422 for invalid params
    - MOD-02 bulk delete tests: successful deletion, already-deleted skipped, nonexistent IDs skipped, mixed valid/invalid, empty list 422, exceeds max 422, deleted reviews excluded from subsequent list
    - No test file collisions (revmod_ email prefix)
  </done>
</task>

</tasks>

<verification>
1. `python -c "from app.admin.reviews_router import bulk_delete_reviews"` — bulk delete endpoint importable
2. `python -m pytest tests/test_review_moderation.py -x -v` — all integration tests pass
3. `python -m pytest tests/ -x` — full test suite passes (no regression from any phase)
4. Verify GET /admin/reviews returns reviews, DELETE /admin/reviews/bulk soft-deletes them, and they disappear from subsequent GET
</verification>

<success_criteria>
- DELETE /admin/reviews/bulk accepts up to 50 review IDs, soft-deletes matching non-deleted reviews
- Best-effort: missing or already-deleted IDs silently skipped, deleted_count reflects actual deletions
- Empty list returns 422 (min_length=1), >50 IDs returns 422 (max_length=50)
- Soft-deleted reviews never reappear in GET /admin/reviews
- 401 unauthenticated, 403 non-admin on both endpoints
- 25+ integration tests covering auth, filters, sort, pagination, bulk delete, edge cases
- All existing tests pass (no regression)
- Phase 18 and v2.1 milestone complete
</success_criteria>

<output>
After completion, create `.planning/phases/18-review-moderation-dashboard/18-02-SUMMARY.md`
</output>
