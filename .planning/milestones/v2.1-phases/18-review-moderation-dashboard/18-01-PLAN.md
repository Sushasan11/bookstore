---
phase: 18-review-moderation-dashboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/admin/reviews_schemas.py
  - app/reviews/repository.py
  - app/admin/reviews_router.py
  - app/main.py
autonomous: true
requirements: [MOD-01]

must_haves:
  truths:
    - "Admin can call GET /admin/reviews?page=1&per_page=20 and receive a paginated list of all non-deleted reviews with reviewer and book context"
    - "Admin can filter reviews by book_id, user_id, or rating range (rating_min, rating_max) — filters combine as AND"
    - "Admin can sort review results by date or rating in ascending or descending order"
    - "Pagination envelope includes items, total_count, page, per_page, and total_pages"
    - "Soft-deleted reviews do not appear in the admin review list"
    - "Non-admin users receive 403, unauthenticated users receive 401"
    - "Invalid rating_min/rating_max (outside 1-5) returns 422"
    - "Invalid sort_by or sort_dir values return 422"
  artifacts:
    - path: "app/admin/reviews_schemas.py"
      provides: "AdminReviewAuthor, AdminReviewBook, AdminReviewEntry, AdminReviewListResponse, BulkDeleteRequest, BulkDeleteResponse schemas"
      contains: "class AdminReviewListResponse"
    - path: "app/reviews/repository.py"
      provides: "list_all_admin() method on ReviewRepository"
      contains: "async def list_all_admin"
    - path: "app/admin/reviews_router.py"
      provides: "GET /admin/reviews endpoint with filters, sort, pagination"
      contains: "async def list_reviews"
    - path: "app/main.py"
      provides: "reviews_admin_router registration"
      contains: "reviews_admin_router"
  key_links:
    - from: "app/admin/reviews_router.py"
      to: "app/reviews/repository.py"
      via: "ReviewRepository(db).list_all_admin()"
      pattern: "repo\\.list_all_admin"
    - from: "app/admin/reviews_router.py"
      to: "app/admin/reviews_schemas.py"
      via: "response_model=AdminReviewListResponse"
      pattern: "AdminReviewListResponse"
    - from: "app/main.py"
      to: "app/admin/reviews_router.py"
      via: "application.include_router(reviews_admin_router)"
      pattern: "reviews_admin_router"
    - from: "app/reviews/repository.py"
      to: "app/reviews/models.py"
      via: "select(Review) with conditional filters and selectinload"
      pattern: "select\\(Review\\)"
---

<objective>
Implement the admin review list endpoint with pagination, filtering, and sorting, plus all supporting schemas and the repository method.

Purpose: Deliver MOD-01 — admins can list all reviews with pagination, sort by date or rating, and filter by book, user, or rating range. This creates the admin review moderation router (`/admin/reviews`) and extends the existing `ReviewRepository` with a new `list_all_admin()` method.

Output: Working `GET /admin/reviews` endpoint with filtering, sorting, and pagination. Schemas for both MOD-01 and MOD-02 (BulkDeleteRequest/Response defined here for Plan 02 to consume).
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->
<!-- Executor should use these directly — no codebase exploration needed. -->

From app/reviews/models.py:
```python
class Review(Base):
    __tablename__ = "reviews"
    id: Mapped[int]                    # primary key
    user_id: Mapped[int]               # ForeignKey("users.id"), indexed
    book_id: Mapped[int]               # ForeignKey("books.id"), indexed
    rating: Mapped[int]                # 1-5, CheckConstraint
    text: Mapped[str | None]           # String(2000), nullable
    created_at: Mapped[datetime]       # server_default=func.now()
    updated_at: Mapped[datetime]       # server_default=func.now(), onupdate=func.now()
    deleted_at: Mapped[datetime | None]  # nullable, soft-delete

    book: Mapped[Book] = relationship()
    user: Mapped[User] = relationship()
```

From app/reviews/repository.py:
```python
class ReviewRepository:
    def __init__(self, session: AsyncSession) -> None:
        self.session = session

    async def list_for_book(self, book_id, *, page=1, size=20) -> tuple[list[Review], int]:
        # Pattern: select(Review).where(...deleted_at.is_(None))
        # Count: select(func.count()).select_from(stmt.subquery())
        # Paginate: .limit(size).offset((page - 1) * size)
        # Options: selectinload(Review.user), selectinload(Review.book)
        ...

    async def soft_delete(self, review: Review) -> None:
        review.deleted_at = datetime.now(UTC)
        await self.session.flush()
```

From app/users/repository.py (pagination pattern):
```python
async def list_paginated(self, *, page, per_page, role=None, is_active=None):
    stmt = select(User).order_by(User.created_at.desc())
    if role is not None:
        stmt = stmt.where(User.role == role)
    if is_active is not None:
        stmt = stmt.where(User.is_active == is_active)
    count_stmt = select(func.count()).select_from(stmt.subquery())
    total = await self.session.scalar(count_stmt)
    offset = (page - 1) * per_page
    stmt = stmt.limit(per_page).offset(offset)
    result = await self.session.execute(stmt)
    return list(result.scalars().all()), total
```

From app/admin/schemas.py (pagination envelope):
```python
class UserListResponse(BaseModel):
    items: list[AdminUserResponse]
    total_count: int
    page: int
    per_page: int
    total_pages: int
```

From app/admin/analytics_router.py (router-level admin auth pattern):
```python
router = APIRouter(
    prefix="/admin/analytics",
    tags=["admin-analytics"],
    dependencies=[Depends(require_admin)],
)
```

From app/core/deps.py:
```python
AdminUser = Annotated[dict, Depends(require_admin)]
DbSession = Annotated[AsyncSession, Depends(get_db)]
```

From app/main.py (router registration pattern):
```python
from app.admin.analytics_router import router as analytics_router
application.include_router(analytics_router)
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create reviews_schemas.py with all admin review moderation schemas</name>
  <files>
    app/admin/reviews_schemas.py
  </files>
  <action>
Create `app/admin/reviews_schemas.py` with all schemas needed for both MOD-01 and MOD-02 (Plan 02 will consume BulkDeleteRequest/BulkDeleteResponse without modifying this file).

```python
"""Pydantic schemas for admin review moderation endpoints."""

import math
from datetime import datetime

from pydantic import BaseModel, Field


class AdminReviewAuthor(BaseModel):
    """Reviewer identity in the admin moderation list."""

    user_id: int
    display_name: str  # email.split('@')[0] — same pattern as ReviewAuthorSummary


class AdminReviewBook(BaseModel):
    """Book context in the admin moderation list."""

    book_id: int
    title: str


class AdminReviewEntry(BaseModel):
    """Single review in the admin moderation list.

    Omits verified_purchase (admin concern is content, not purchase status).
    Omits avatar_url and cover_image_url (not needed for moderation).
    """

    id: int
    rating: int
    text: str | None
    created_at: datetime
    updated_at: datetime
    author: AdminReviewAuthor
    book: AdminReviewBook

    model_config = {"from_attributes": True}


class AdminReviewListResponse(BaseModel):
    """Paginated envelope for admin review list — follows admin convention."""

    items: list[AdminReviewEntry]
    total_count: int
    page: int
    per_page: int
    total_pages: int


class BulkDeleteRequest(BaseModel):
    """Request body for bulk review soft-delete.

    Max 50 IDs per request — locked user decision.
    min_length=1 prevents empty list submission.
    """

    review_ids: list[int] = Field(min_length=1, max_length=50)


class BulkDeleteResponse(BaseModel):
    """Response for bulk review soft-delete.

    deleted_count reflects only reviews actually soft-deleted
    (best-effort: missing or already-deleted IDs silently skipped).
    """

    deleted_count: int
```

Key details:
- `AdminReviewEntry` uses `from_attributes = True` for ORM model compatibility in `model_validate`
- `BulkDeleteRequest` uses `Field(min_length=1, max_length=50)` — Pydantic v2 uses `max_length` for list constraints
- `AdminReviewAuthor.display_name` will be constructed as `email.split('@')[0]` in the router (not in the schema)
- Both BulkDelete schemas are defined here for Plan 02 to consume — Plan 02 will NOT modify this file
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && python -c "from app.admin.reviews_schemas import AdminReviewEntry, AdminReviewListResponse, BulkDeleteRequest, BulkDeleteResponse, AdminReviewAuthor, AdminReviewBook; print('All schema imports OK')"</automated>
  </verify>
  <done>
    - AdminReviewAuthor schema has fields: user_id, display_name
    - AdminReviewBook schema has fields: book_id, title
    - AdminReviewEntry schema has fields: id, rating, text, created_at, updated_at, author, book
    - AdminReviewListResponse has fields: items, total_count, page, per_page, total_pages
    - BulkDeleteRequest has review_ids with min_length=1, max_length=50
    - BulkDeleteResponse has deleted_count field
  </done>
</task>

<task type="auto">
  <name>Task 2: Add list_all_admin() to ReviewRepository, create admin reviews router, and register in main.py</name>
  <files>
    app/reviews/repository.py
    app/admin/reviews_router.py
    app/main.py
  </files>
  <action>
**1. Add `list_all_admin()` method to `ReviewRepository`** in `app/reviews/repository.py`:

Add `asc, desc` to the existing `from sqlalchemy import func, select` import line (becomes `from sqlalchemy import asc, desc, func, select`).

Add the following method to the `ReviewRepository` class after the existing `list_for_book()` method:

```python
async def list_all_admin(
    self,
    *,
    page: int = 1,
    per_page: int = 20,
    book_id: int | None = None,
    user_id: int | None = None,
    rating_min: int | None = None,
    rating_max: int | None = None,
    sort_by: str = "date",
    sort_dir: str = "desc",
) -> tuple[list[Review], int]:
    """Return paginated, filtered, sorted reviews for admin moderation.

    Filters combine as AND (e.g., book_id=5 AND rating_min=3).
    Soft-deleted reviews are always excluded.
    Eager-loads user and book relationships for response serialization.

    Args:
        page: 1-indexed page number.
        per_page: Items per page.
        book_id: Filter to reviews for this book only.
        user_id: Filter to reviews by this user only.
        rating_min: Minimum rating (inclusive, 1-5).
        rating_max: Maximum rating (inclusive, 1-5).
        sort_by: "date" (created_at) or "rating".
        sort_dir: "asc" or "desc".

    Returns:
        Tuple of (reviews list, total count).
    """
    stmt = (
        select(Review)
        .where(Review.deleted_at.is_(None))
        .options(selectinload(Review.user), selectinload(Review.book))
    )

    # Conditional filters — all combine as AND
    if book_id is not None:
        stmt = stmt.where(Review.book_id == book_id)
    if user_id is not None:
        stmt = stmt.where(Review.user_id == user_id)
    if rating_min is not None:
        stmt = stmt.where(Review.rating >= rating_min)
    if rating_max is not None:
        stmt = stmt.where(Review.rating <= rating_max)

    # Sort column and direction
    sort_col = Review.created_at if sort_by == "date" else Review.rating
    order_expr = desc(sort_col) if sort_dir == "desc" else asc(sort_col)
    stmt = stmt.order_by(order_expr, Review.id.desc())  # id as stable tiebreaker

    # Count (reuses same filters via subquery)
    count_stmt = select(func.count()).select_from(stmt.subquery())
    total = (await self.session.execute(count_stmt)).scalar_one()

    # Paginate
    result = await self.session.execute(
        stmt.limit(per_page).offset((page - 1) * per_page)
    )
    return list(result.scalars().all()), total
```

Key details:
- `selectinload(Review.user), selectinload(Review.book)` — eager-loads relationships for response serialization
- `Review.id.desc()` as secondary sort provides stable tiebreaker
- Count uses `select(func.count()).select_from(stmt.subquery())` — guarantees count and data use identical filters
- `deleted_at.is_(None)` is the FIRST where clause — soft-deleted reviews never appear

**2. Create `app/admin/reviews_router.py`** with the admin review list endpoint:

```python
"""Admin review moderation endpoints — GET /admin/reviews, DELETE /admin/reviews/bulk."""

import math

from fastapi import APIRouter, Depends, Query

from app.admin.reviews_schemas import (
    AdminReviewEntry,
    AdminReviewListResponse,
    BulkDeleteRequest,
    BulkDeleteResponse,
)
from app.core.deps import AdminUser, DbSession, require_admin
from app.reviews.repository import ReviewRepository

router = APIRouter(
    prefix="/admin/reviews",
    tags=["admin-reviews"],
    dependencies=[Depends(require_admin)],
)


@router.get("", response_model=AdminReviewListResponse)
async def list_reviews(
    db: DbSession,
    _admin: AdminUser,
    page: int = Query(1, ge=1),
    per_page: int = Query(20, ge=1, le=100),
    book_id: int | None = Query(None),
    user_id: int | None = Query(None),
    rating_min: int | None = Query(None, ge=1, le=5),
    rating_max: int | None = Query(None, ge=1, le=5),
    sort_by: str = Query("date", pattern="^(date|rating)$"),
    sort_dir: str = Query("desc", pattern="^(asc|desc)$"),
) -> AdminReviewListResponse:
    """Return paginated, filtered list of all non-deleted reviews for admin moderation.

    Query parameters:
    - page: Page number (default 1, minimum 1).
    - per_page: Items per page (default 20, 1-100).
    - book_id: Filter by book ID (optional).
    - user_id: Filter by user ID (optional).
    - rating_min: Minimum rating 1-5 inclusive (optional).
    - rating_max: Maximum rating 1-5 inclusive (optional).
    - sort_by: "date" (default) or "rating".
    - sort_dir: "desc" (default) or "asc".

    Filters combine as AND. Admin only. Invalid values return 422.
    """
    repo = ReviewRepository(db)
    reviews, total = await repo.list_all_admin(
        page=page, per_page=per_page,
        book_id=book_id, user_id=user_id,
        rating_min=rating_min, rating_max=rating_max,
        sort_by=sort_by, sort_dir=sort_dir,
    )
    items = [
        AdminReviewEntry.model_validate({
            "id": r.id,
            "rating": r.rating,
            "text": r.text,
            "created_at": r.created_at,
            "updated_at": r.updated_at,
            "author": {"user_id": r.user.id, "display_name": r.user.email.split("@")[0]},
            "book": {"book_id": r.book.id, "title": r.book.title},
        })
        for r in reviews
    ]
    return AdminReviewListResponse(
        items=items,
        total_count=total,
        page=page,
        per_page=per_page,
        total_pages=math.ceil(total / per_page) if total > 0 else 0,
    )
```

Key details:
- `dependencies=[Depends(require_admin)]` at router level — all endpoints protected automatically
- `Query("date", pattern="^(date|rating)$")` for sort_by validation — matches project convention (regex, not Literal)
- `Query(None, ge=1, le=5)` for rating_min/rating_max — FastAPI returns 422 for out-of-range values
- `r.user.email.split("@")[0]` for display_name — same pattern as `ReviewService._build_review_data()`
- `math.ceil(total / per_page) if total > 0 else 0` for total_pages — admin pagination convention
- No service layer — direct repository call, same pattern as analytics endpoints
- BulkDeleteRequest/BulkDeleteResponse imported but the delete endpoint will be added in Plan 02

**3. Register the router in `app/main.py`:**

Add the import alongside existing admin router imports:
```python
from app.admin.reviews_router import router as reviews_admin_router
```

Add the router registration after the existing `analytics_router` line:
```python
application.include_router(reviews_admin_router)
```

Key details:
- Import alias `reviews_admin_router` avoids collision with `reviews_router` from `app.reviews.router`
- Register after `analytics_router` to keep admin routers grouped
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && python -c "from app.admin.reviews_router import router, list_reviews; from app.reviews.repository import ReviewRepository; print('Router and repository imports OK')" && python -c "from app.main import app; routes = [r.path for r in app.routes]; assert '/admin/reviews' in routes or any('/admin/reviews' in str(r.path) for r in app.routes), f'Route not found in {routes}'; print('Router registered in main.py OK')"</automated>
  </verify>
  <done>
    - ReviewRepository.list_all_admin() method exists with all filter/sort/pagination parameters
    - list_all_admin() filters: book_id, user_id, rating_min, rating_max (AND combination)
    - list_all_admin() sorts: by date or rating, asc or desc, with id tiebreaker
    - list_all_admin() paginates with count from subquery pattern
    - list_all_admin() always excludes soft-deleted reviews (deleted_at IS NULL)
    - GET /admin/reviews endpoint exists with all query parameters and validation
    - rating_min/rating_max validated ge=1, le=5
    - sort_by validated pattern="^(date|rating)$", sort_dir validated pattern="^(asc|desc)$"
    - Router registered in app/main.py as reviews_admin_router
    - Response follows admin pagination envelope: items, total_count, page, per_page, total_pages
  </done>
</task>

</tasks>

<verification>
1. `python -c "from app.admin.reviews_schemas import AdminReviewListResponse, BulkDeleteRequest"` — schemas importable
2. `python -c "from app.admin.reviews_router import router, list_reviews"` — router importable
3. `python -c "from app.main import app; print([r.path for r in app.routes])"` — `/admin/reviews` appears in route list
4. `python -m pytest tests/ -x --ignore=tests/test_review_moderation.py` — existing tests still pass (no regression)
</verification>

<success_criteria>
- GET /admin/reviews returns paginated, filtered, sorted reviews for admin users
- Filters: book_id, user_id, rating_min (1-5), rating_max (1-5) — all AND combined
- Sort: date (default, desc) or rating, in asc or desc direction
- Pagination: page, per_page with total_count and total_pages
- Soft-deleted reviews never appear
- 401 unauthenticated, 403 non-admin, 422 invalid params
- All existing tests pass (no regression)
</success_criteria>

<output>
After completion, create `.planning/phases/18-review-moderation-dashboard/18-01-SUMMARY.md`
</output>
