---
phase: 16-sales-analytics
plan: 2
type: execute
wave: 2
depends_on:
  - 16-01
files_modified:
  - app/admin/analytics_repository.py
  - app/admin/analytics_schemas.py
  - app/admin/analytics_router.py
  - tests/test_sales_analytics.py
autonomous: true
requirements:
  - SALES-03
  - SALES-04

must_haves:
  truths:
    - "Admin can call GET /admin/analytics/sales/top-books?sort_by=revenue and receive books ranked by total revenue with title, author, units_sold, and total_revenue"
    - "Admin can call GET /admin/analytics/sales/top-books?sort_by=volume and receive books ranked by units sold — distinct ordering from revenue ranking"
    - "Top-books default limit is 10, accepts ?limit=N up to max 50"
    - "Only CONFIRMED orders appear in top-books calculations"
    - "Deleted books (book_id IS NULL in order_items) are excluded from top-books results"
    - "Non-admin users receive 403 on the top-books endpoint"
    - "Integration tests validate revenue summary (all periods, zero-data edge cases) and top-books (both sort orderings)"
  artifacts:
    - path: "app/admin/analytics_repository.py"
      provides: "top_books() method added to AnalyticsRepository"
      contains: "async def top_books"
    - path: "app/admin/analytics_schemas.py"
      provides: "TopBookEntry and TopBooksResponse schemas"
      contains: "class TopBookEntry"
    - path: "app/admin/analytics_router.py"
      provides: "GET /admin/analytics/sales/top-books endpoint"
      contains: "/sales/top-books"
    - path: "tests/test_sales_analytics.py"
      provides: "Integration tests for both sales analytics endpoints"
      min_lines: 150
  key_links:
    - from: "app/admin/analytics_router.py"
      to: "app/admin/analytics_repository.py"
      via: "AnalyticsRepository.top_books() call in endpoint"
      pattern: "repo\\.top_books"
    - from: "tests/test_sales_analytics.py"
      to: "app/admin/analytics_router.py"
      via: "HTTP client calls to /admin/analytics/sales/* endpoints"
      pattern: "/admin/analytics/sales/"
---

<objective>
Add the top-selling books endpoint and comprehensive integration tests for all Phase 16 sales analytics functionality.

Purpose: Completes the sales analytics feature by adding top-books rankings (by revenue and by volume) and validates the entire phase with integration tests covering both endpoints, edge cases, and auth protection.

Output: Extended analytics_repository.py with top_books() method, new schemas (TopBookEntry, TopBooksResponse), new endpoint (GET /admin/analytics/sales/top-books), and a comprehensive test file covering both sales analytics endpoints.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-sales-analytics/16-RESEARCH.md
@.planning/phases/16-sales-analytics/16-01-SUMMARY.md

<interfaces>
<!-- Interfaces created by Plan 16-01 that this plan extends -->

From app/admin/analytics_repository.py (created by 16-01):
```python
class AnalyticsRepository:
    def __init__(self, session: AsyncSession) -> None:
        self.session = session

    async def revenue_summary(self, *, period_start: datetime, period_end: datetime) -> dict:
        """Returns {"revenue": Decimal, "order_count": int}"""
```

From app/admin/analytics_service.py (created by 16-01):
```python
class AdminAnalyticsService:
    def __init__(self, repo: AnalyticsRepository) -> None:
        self.repo = repo

    async def sales_summary(self, period: str) -> dict:
        """Returns {"period": str, "revenue": float, "order_count": int, "aov": float, "delta_percentage": float|None}"""
```

From app/admin/analytics_schemas.py (created by 16-01):
```python
class SalesSummaryResponse(BaseModel):
    period: str
    revenue: float
    order_count: int
    aov: float
    delta_percentage: float | None
```

From app/admin/analytics_router.py (created by 16-01):
```python
router = APIRouter(
    prefix="/admin/analytics",
    tags=["admin-analytics"],
    dependencies=[Depends(require_admin)],
)

@router.get("/sales/summary", response_model=SalesSummaryResponse)
async def sales_summary(db: DbSession, _admin: AdminUser, period: str = Query("today", pattern="^(today|week|month)$")) -> SalesSummaryResponse:
```

From app/orders/models.py:
```python
class OrderStatus(enum.StrEnum):
    CONFIRMED = "confirmed"
    PAYMENT_FAILED = "payment_failed"

class OrderItem(Base):
    book_id: Mapped[int | None]  # nullable, ondelete="SET NULL"
    quantity: Mapped[int]
    unit_price: Mapped[Decimal] = mapped_column(Numeric(10, 2))
```

From app/books/models.py:
```python
class Book(Base):
    __tablename__ = "books"
    id: Mapped[int]
    title: Mapped[str]
    author: Mapped[str]
```

From tests/conftest.py (test fixtures):
```python
# Available fixtures: db_session (AsyncSession, per-test rollback), client (AsyncClient)
# Test DB: postgresql+asyncpg://postgres:postgres@127.0.0.1:5433/bookstore_test
```

From tests/test_admin_users.py (auth fixture pattern):
```python
@pytest_asyncio.fixture
async def admin_headers(client: AsyncClient, db_session: AsyncSession) -> dict:
    repo = UserRepository(db_session)
    hashed = await hash_password("adminpass123")
    user = await repo.create(email="admin_mgmt@example.com", hashed_password=hashed)
    await repo.set_role_admin(user.id)
    await db_session.flush()
    resp = await client.post(LOGIN_URL, json={"email": "...", "password": "..."})
    return {"Authorization": f"Bearer {resp.json()['access_token']}"}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add top_books() repository method, TopBookEntry/TopBooksResponse schemas, and top-books endpoint</name>
  <files>
    app/admin/analytics_repository.py
    app/admin/analytics_schemas.py
    app/admin/analytics_router.py
  </files>
  <action>
**analytics_repository.py** — Add `top_books()` method to existing `AnalyticsRepository`:
- `async def top_books(self, *, sort_by: str, limit: int = 10) -> list[dict]`:
  - Define two labels: `revenue_col = func.sum(OrderItem.unit_price * OrderItem.quantity).label("total_revenue")` and `volume_col = func.sum(OrderItem.quantity).label("units_sold")`.
  - Determine sort column: `order_col = revenue_col if sort_by == "revenue" else volume_col`.
  - SQL: `select(OrderItem.book_id, Book.title, Book.author, revenue_col, volume_col).join(Order, OrderItem.order_id == Order.id).join(Book, OrderItem.book_id == Book.id).where(Order.status == OrderStatus.CONFIRMED, OrderItem.book_id.is_not(None)).group_by(OrderItem.book_id, Book.title, Book.author).order_by(desc(order_col)).limit(limit)`.
  - CRITICAL: `OrderItem.book_id.is_not(None)` MUST be included to exclude items from deleted books. Without this, NULL book_ids create ghost groups.
  - CRITICAL: INNER JOIN to Book is safe here ONLY because we already filter `book_id IS NOT NULL`.
  - Execute and return `[row._asdict() for row in result.all()]`.
  - Add import for `desc` from `sqlalchemy` and `Book` from `app.books.models` at top of file.
  - Each dict in result has: `book_id: int, title: str, author: str, total_revenue: Decimal, units_sold: int`.

**analytics_schemas.py** — Add two new schemas after existing `SalesSummaryResponse`:
- `TopBookEntry(BaseModel)`: `book_id: int`, `title: str`, `author: str`, `total_revenue: float`, `units_sold: int`.
- `TopBooksResponse(BaseModel)`: `sort_by: str`, `items: list[TopBookEntry]`.
- All money fields (`total_revenue`) as `float` — same pattern as SalesSummaryResponse.

**analytics_router.py** — Add top-books endpoint after existing summary endpoint:
- `@router.get("/sales/top-books", response_model=TopBooksResponse)`.
- Parameters: `db: DbSession`, `_admin: AdminUser`, `sort_by: str = Query("revenue", pattern="^(revenue|volume)$")`, `limit: int = Query(10, ge=1, le=50)`.
- Body: create `AnalyticsRepository(db)`, call `await repo.top_books(sort_by=sort_by, limit=limit)`, return `TopBooksResponse(sort_by=sort_by, items=books)`.
- Note: top-books goes directly to repository (no service needed) — it's a simple parameterized query with no period logic.
- Import `TopBooksResponse` from analytics_schemas (add to existing import).
  </action>
  <verify>
    <automated>python -c "from app.main import app; routes = [r.path for r in app.routes]; assert '/admin/analytics/sales/top-books' in routes, f'Route not found in: {routes}'; print('Top-books endpoint registered OK')"</automated>
  </verify>
  <done>
    - top_books() method exists in AnalyticsRepository with CONFIRMED filter and book_id IS NOT NULL guard
    - TopBookEntry and TopBooksResponse schemas exist with float money fields
    - GET /admin/analytics/sales/top-books endpoint exists with sort_by (revenue|volume) and limit (1-50) params
    - Invalid sort_by values return 422 via Query pattern validation
  </done>
</task>

<task type="auto">
  <name>Task 2: Create integration tests for both sales analytics endpoints</name>
  <files>
    tests/test_sales_analytics.py
  </files>
  <action>
Create `tests/test_sales_analytics.py` with comprehensive integration tests. Follow the exact pattern from `tests/test_admin_users.py` for admin auth fixtures.

**Fixtures:**
- `admin_headers(client, db_session)` — create admin user, login, return Bearer headers. Use unique email like `"admin_analytics@example.com"`.
- `user_headers(client, db_session)` — create regular user, login, return Bearer headers. Use unique email like `"user_analytics@example.com"`.
- `_create_confirmed_order(db_session, user_id, items)` — async helper that creates a CONFIRMED Order and its OrderItems. `items` is a list of `{"book_id": int, "quantity": int, "unit_price": Decimal}` dicts. Flushes the session after creation.
- `sample_books(db_session)` — create 3+ Book rows with different titles/authors/prices/stock. Return the books list. Import `Book` from `app.books.models` and `Genre` from `app.books.models`. Each book needs a genre_id, so create a Genre first.

**Test classes and methods:**

`TestSalesSummaryAuth`:
- `test_summary_requires_auth` — GET /admin/analytics/sales/summary without token returns 401.
- `test_summary_requires_admin` — GET with regular user token returns 403.

`TestSalesSummary`:
- `test_summary_default_period_today` — GET without period param returns `period: "today"`.
- `test_summary_zero_orders` — GET when no orders exist returns `{revenue: 0.0, order_count: 0, aov: 0.0, delta_percentage: null}`.
- `test_summary_with_confirmed_orders` — Create a confirmed order with known items, call summary. Verify revenue = sum(qty * price), order_count = 1, aov = revenue / 1.
- `test_summary_excludes_payment_failed` — Create one CONFIRMED and one PAYMENT_FAILED order. Verify revenue only counts the confirmed one.
- `test_summary_invalid_period_returns_422` — GET with `?period=year` returns 422.
- `test_summary_week_period` — GET with `?period=week` returns `period: "week"` with valid response structure.
- `test_summary_month_period` — GET with `?period=month` returns `period: "month"` with valid response structure.

`TestTopBooksAuth`:
- `test_top_books_requires_auth` — GET /admin/analytics/sales/top-books without token returns 401.
- `test_top_books_requires_admin` — GET with regular user token returns 403.

`TestTopBooks`:
- `test_top_books_by_revenue` — Create orders for multiple books with different quantities and prices. Call with `?sort_by=revenue`. Verify books are ordered by total_revenue descending. Verify each item has book_id, title, author, total_revenue, units_sold.
- `test_top_books_by_volume` — Same data, call with `?sort_by=volume`. Verify books are ordered by units_sold descending. The ordering SHOULD differ from revenue ranking (design test data so a cheap book sells more units but less revenue than an expensive book).
- `test_top_books_default_limit` — Without limit param, returns at most 10 results.
- `test_top_books_custom_limit` — `?limit=2` returns exactly 2 results.
- `test_top_books_limit_max_50` — `?limit=100` returns 422 (exceeds max).
- `test_top_books_excludes_payment_failed` — Create orders with PAYMENT_FAILED status. Verify those items don't appear in top-books.
- `test_top_books_empty` — No orders at all returns `{sort_by: "revenue", items: []}`.
- `test_top_books_invalid_sort_returns_422` — GET with `?sort_by=rating` returns 422.

**Key test data design for distinct revenue vs volume rankings:**
- Book A: price 50.00, sold 2 units = revenue 100.00, volume 2
- Book B: price 10.00, sold 8 units = revenue 80.00, volume 8
- Book C: price 30.00, sold 3 units = revenue 90.00, volume 3
- Revenue order: A, C, B. Volume order: B, C, A. This proves the two rankings are distinct.

**Important test patterns:**
- Use `db_session` fixture (auto-rollback per test).
- Use `client` fixture from conftest.py.
- All async tests — pytest-asyncio handles this (asyncio_mode = "auto" in pyproject.toml).
- Create Order objects directly via SQLAlchemy model instantiation + `db_session.add()` + `db_session.flush()` — don't go through the checkout flow.
- Import models: `Order, OrderItem, OrderStatus` from `app.orders.models`, `Book, Genre` from `app.books.models`.
- For PAYMENT_FAILED orders, set `status=OrderStatus.PAYMENT_FAILED` on the Order.
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && python -m pytest tests/test_sales_analytics.py -x -v 2>&1 | tail -30</automated>
  </verify>
  <done>
    - tests/test_sales_analytics.py exists with 15+ test methods
    - All tests pass (pytest exit code 0)
    - Auth tests verify 401 (no token) and 403 (non-admin) for both endpoints
    - Revenue summary tests cover: default period, zero-data, confirmed orders, PAYMENT_FAILED exclusion, invalid period, all three period values
    - Top-books tests cover: revenue ordering, volume ordering (distinct from revenue), limit parameter, PAYMENT_FAILED exclusion, empty results, invalid sort_by
    - Test data demonstrates that sort_by=revenue and sort_by=volume produce different rankings
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_sales_analytics.py -x -v` — all tests pass
2. Both endpoints exist: `/admin/analytics/sales/summary` and `/admin/analytics/sales/top-books`
3. Top-books query contains `OrderItem.book_id.is_not(None)` — grep confirms NULL guard
4. Top-books query contains `Order.status == OrderStatus.CONFIRMED` — grep confirms filter
5. Revenue ranking and volume ranking tests use data that produces different orderings
6. Auth protection tests exist for both endpoints (401 + 403)
</verification>

<success_criteria>
- Admin can call GET /admin/analytics/sales/top-books?sort_by=revenue and receive books ranked by total revenue
- Admin can call GET /admin/analytics/sales/top-books?sort_by=volume and receive books ranked by units sold, with different ordering from revenue
- All 15+ integration tests pass covering both endpoints, edge cases, and auth
- Phase 16 is fully complete: all four requirements (SALES-01 through SALES-04) are implemented and tested
</success_criteria>

<output>
After completion, create `.planning/phases/16-sales-analytics/16-02-SUMMARY.md`
</output>
