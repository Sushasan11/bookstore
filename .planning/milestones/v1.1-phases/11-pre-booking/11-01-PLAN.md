---
phase: 11-pre-booking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/prebooks/models.py
  - app/prebooks/repository.py
  - app/prebooks/schemas.py
  - app/prebooks/service.py
  - app/prebooks/router.py
  - app/prebooks/__init__.py
  - app/books/service.py
  - app/books/router.py
  - app/main.py
  - alembic/env.py
  - alembic/versions/xxxx_create_pre_bookings.py
autonomous: true
requirements: [PRBK-01, PRBK-02, PRBK-03, PRBK-04, PRBK-05, PRBK-06]

must_haves:
  truths:
    - "User can create a pre-booking for an out-of-stock book"
    - "User cannot pre-book a book that has stock > 0 (409 rejected)"
    - "User cannot create a duplicate pre-booking for the same book (409 rejected)"
    - "User can view all their pre-bookings with book details and status"
    - "User can cancel a pre-booking (soft-delete to CANCELLED status)"
    - "When admin restocks a book from 0 to >0, all waiting pre-bookings atomically transition to notified with notified_at timestamp"
    - "Restock of already-in-stock book does NOT trigger pre-booking notifications"
  artifacts:
    - path: "app/prebooks/models.py"
      provides: "PreBooking model with PreBookStatus enum"
      contains: "class PreBooking"
    - path: "app/prebooks/repository.py"
      provides: "PreBookRepository with add, list, cancel, notify_waiting_by_book"
      contains: "class PreBookRepository"
    - path: "app/prebooks/service.py"
      provides: "PreBookService with create, list, cancel"
      contains: "class PreBookService"
    - path: "app/prebooks/router.py"
      provides: "POST/GET/DELETE /prebooks endpoints"
      contains: "router = APIRouter"
    - path: "app/prebooks/schemas.py"
      provides: "PreBookCreate, PreBookResponse, PreBookListResponse"
      contains: "class PreBookResponse"
    - path: "app/books/service.py"
      provides: "Extended set_stock_and_notify method"
      contains: "set_stock_and_notify"
    - path: "app/books/router.py"
      provides: "Modified PATCH /books/{id}/stock with prebook notification"
      contains: "prebook_repo"
  key_links:
    - from: "app/prebooks/router.py"
      to: "app/prebooks/service.py"
      via: "PreBookService instantiation in _make_service"
      pattern: "PreBookService\\("
    - from: "app/prebooks/service.py"
      to: "app/books/repository.py"
      via: "BookRepository.get_by_id for stock check"
      pattern: "book_repo\\.get_by_id"
    - from: "app/books/service.py"
      to: "app/prebooks/repository.py"
      via: "PreBookRepository.notify_waiting_by_book in set_stock_and_notify"
      pattern: "prebook_repo\\.notify_waiting_by_book"
    - from: "app/books/router.py"
      to: "app/prebooks/repository.py"
      via: "Router passes PreBookRepository to BookService.set_stock_and_notify"
      pattern: "PreBookRepository\\(db\\)"
    - from: "app/main.py"
      to: "app/prebooks/router.py"
      via: "include_router registration"
      pattern: "include_router.*prebooks"
---

<objective>
Implement the complete pre-booking feature: data model, repository, service, and API endpoints for reserving out-of-stock books, viewing reservations, cancelling them, and atomically notifying all waiting pre-bookers when admin restocks a book.

Purpose: Enable users to express interest in out-of-stock books and receive status updates when the book becomes available, completing the pre-booking data layer and API (email wiring deferred to Phase 12).

Output: PreBooking model with migration, full CRUD repository, business logic service, REST endpoints, and BookService extension for restock notification broadcast.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-pre-booking/11-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From app/db/base.py:
```python
from sqlalchemy.orm import DeclarativeBase
class Base(DeclarativeBase):
    pass
```

From app/core/deps.py:
```python
DbSession = Annotated[AsyncSession, Depends(get_db)]
ActiveUser = Annotated[dict, Depends(get_active_user)]
AdminUser = Annotated[dict, Depends(require_admin)]
```

From app/core/exceptions.py:
```python
class AppError(Exception):
    def __init__(self, status_code: int, detail: str, code: str, field: str | None = None) -> None:
```

From app/books/repository.py:
```python
class BookRepository:
    def __init__(self, session: AsyncSession) -> None:
    async def get_by_id(self, book_id: int) -> Book | None:
    async def set_stock(self, book: Book, quantity: int) -> Book:
```

From app/books/service.py:
```python
class BookService:
    def __init__(self, book_repo: BookRepository, genre_repo: GenreRepository) -> None:
    async def _get_book_or_404(self, book_id: int) -> Book:
    async def set_stock(self, book_id: int, quantity: int) -> Book:
```

From app/books/router.py:
```python
@router.patch("/books/{book_id}/stock", response_model=BookResponse)
async def update_stock(book_id: int, body: StockUpdate, db: DbSession, admin: AdminUser) -> BookResponse:
    service = _make_service(db)
    book = await service.set_stock(book_id, body.quantity)
    return BookResponse.model_validate(book)
```

From app/wishlist/repository.py (pattern to follow for IntegrityError handling):
```python
async def add(self, user_id: int, book_id: int) -> WishlistItem:
    item = WishlistItem(user_id=user_id, book_id=book_id)
    self.session.add(item)
    try:
        await self.session.flush()
    except IntegrityError as e:
        await self.session.rollback()
        orig = str(e.orig).lower() if e.orig else ""
        if "uq_wishlist_items" in orig or "wishlist_items" in orig:
            raise AppError(409, "...", "WISHLIST_ITEM_DUPLICATE", "book_id") from e
        raise
```

From app/orders/models.py (StrEnum + SAEnum pattern):
```python
class OrderStatus(enum.StrEnum):
    CONFIRMED = "confirmed"
    PAYMENT_FAILED = "payment_failed"

class Order(Base):
    status: Mapped[OrderStatus] = mapped_column(
        SAEnum(OrderStatus, name="orderstatus"), nullable=False, default=OrderStatus.CONFIRMED
    )
```

From alembic/env.py (model import section):
```python
from app.books.models import Book, Genre  # noqa: F401
from app.cart.models import Cart, CartItem  # noqa: F401
from app.orders.models import Order, OrderItem  # noqa: F401
from app.users.models import OAuthAccount, RefreshToken, User  # noqa: F401
from app.wishlist.models import WishlistItem  # noqa: F401
```

From app/main.py (router registration section):
```python
application.include_router(wishlist_router)
application.include_router(admin_users_router)
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PreBooking model, migration, and register in model discovery</name>
  <files>
    app/prebooks/__init__.py
    app/prebooks/models.py
    alembic/env.py
    alembic/versions/xxxx_create_pre_bookings.py
  </files>
  <action>
**1. app/prebooks/models.py** — Create the PreBooking model and PreBookStatus enum:

```python
import enum
from datetime import datetime
from typing import TYPE_CHECKING

from sqlalchemy import DateTime, ForeignKey, Index, func, text
from sqlalchemy import Enum as SAEnum
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.db.base import Base

if TYPE_CHECKING:
    from app.books.models import Book


class PreBookStatus(enum.StrEnum):
    WAITING = "waiting"
    NOTIFIED = "notified"
    CANCELLED = "cancelled"


class PreBooking(Base):
    __tablename__ = "pre_bookings"

    __table_args__ = (
        Index(
            "uq_pre_bookings_user_book_waiting",
            "user_id",
            "book_id",
            unique=True,
            postgresql_where=text("status = 'waiting'"),
        ),
    )

    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(
        ForeignKey("users.id", ondelete="CASCADE"), nullable=False, index=True
    )
    book_id: Mapped[int] = mapped_column(
        ForeignKey("books.id", ondelete="CASCADE"), nullable=False, index=True
    )
    status: Mapped[PreBookStatus] = mapped_column(
        SAEnum(PreBookStatus, name="prebookstatus"),
        nullable=False,
        default=PreBookStatus.WAITING,
    )
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), nullable=False
    )
    notified_at: Mapped[datetime | None] = mapped_column(
        DateTime(timezone=True), nullable=True
    )
    cancelled_at: Mapped[datetime | None] = mapped_column(
        DateTime(timezone=True), nullable=True
    )

    book: Mapped["Book"] = relationship()
```

Key design points:
- `PreBookStatus(StrEnum)` with waiting/notified/cancelled — matches OrderStatus pattern
- Partial unique index `uq_pre_bookings_user_book_waiting` with `postgresql_where=text("status = 'waiting'")` — enforces one active pre-booking per (user, book) while allowing re-reservation after cancellation. This is THE critical constraint.
- `notified_at` and `cancelled_at` are nullable timestamps for audit trail
- `book` relationship (no back_populates needed — one-direction for response serialization)
- ForeignKey ondelete=CASCADE for both user_id and book_id

**2. app/prebooks/__init__.py** — Leave empty (package marker already exists, keep it empty).

**3. alembic/env.py** — Add model import for Alembic autogenerate discovery. Add this line after the wishlist import:
```python
from app.prebooks.models import PreBooking  # noqa: F401
```

**4. Alembic migration** — Generate migration via autogenerate:
```bash
cd D:/Python/claude-test && poetry run alembic revision --autogenerate -m "create_pre_bookings"
```

If autogenerate is not available (no DB connection), manually create the migration file in `alembic/versions/` following the project pattern. The migration must:
- Create `prebookstatus` ENUM type (waiting, notified, cancelled)
- Create `pre_bookings` table with all columns (id, user_id, book_id, status, created_at, notified_at, cancelled_at)
- Create ForeignKey constraints (users.id CASCADE, books.id CASCADE)
- Create indexes: `ix_pre_bookings_user_id`, `ix_pre_bookings_book_id`
- Create the conditional unique index: `uq_pre_bookings_user_book_waiting` on (user_id, book_id) WHERE status = 'waiting'
- Downgrade must drop the table AND the enum type

Use this revision ID pattern: a random hex string like `a1b2c3d4e5f6` (12 chars). Set `down_revision` to the latest existing migration hash. Find it with:
```bash
ls -t D:/Python/claude-test/alembic/versions/*.py | head -1
```
Read that file to get its revision ID for the `down_revision` value.
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && poetry run python -c "from app.prebooks.models import PreBooking, PreBookStatus; print('Model OK:', PreBookStatus.WAITING, PreBookStatus.NOTIFIED, PreBookStatus.CANCELLED)" && poetry run python -c "from app.prebooks.models import PreBooking; t = PreBooking.__table__; idx = [i.name for i in t.indexes]; print('Indexes:', idx); assert 'uq_pre_bookings_user_book_waiting' in idx, 'Missing partial unique index'"</automated>
  </verify>
  <done>
    - PreBooking model importable with PreBookStatus enum (waiting/notified/cancelled)
    - Partial unique index uq_pre_bookings_user_book_waiting exists on (user_id, book_id) WHERE status='waiting'
    - Alembic migration file exists and creates the table with all columns, indexes, and FK constraints
    - alembic/env.py imports PreBooking for autogenerate discovery
    - ruff check passes on all new/modified files
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PreBookRepository, PreBookService, schemas, and router</name>
  <files>
    app/prebooks/repository.py
    app/prebooks/schemas.py
    app/prebooks/service.py
    app/prebooks/router.py
    app/main.py
  </files>
  <action>
**1. app/prebooks/schemas.py** — Pydantic v2 request/response schemas:

```python
from datetime import datetime
from pydantic import BaseModel, Field

class PreBookCreate(BaseModel):
    """Request body for POST /prebooks."""
    book_id: int = Field(description="ID of the book to pre-book")

class PreBookResponse(BaseModel):
    """Response schema for a single pre-booking."""
    id: int
    book_id: int
    book_title: str
    book_author: str
    status: str
    created_at: datetime
    notified_at: datetime | None
    cancelled_at: datetime | None

    model_config = {"from_attributes": True}

class PreBookListResponse(BaseModel):
    """Response envelope for GET /prebooks."""
    items: list[PreBookResponse]
```

`PreBookResponse` uses `book_title` and `book_author` flattened from the book relationship. The `model_validate` call in the router must construct this from the ORM object — use a classmethod or manual construction:
```python
@classmethod
def from_orm_with_book(cls, prebook: "PreBooking") -> "PreBookResponse":
    return cls(
        id=prebook.id,
        book_id=prebook.book_id,
        book_title=prebook.book.title,
        book_author=prebook.book.author,
        status=prebook.status.value,
        created_at=prebook.created_at,
        notified_at=prebook.notified_at,
        cancelled_at=prebook.cancelled_at,
    )
```

**2. app/prebooks/repository.py** — PreBookRepository with four methods:

```python
class PreBookRepository:
    def __init__(self, session: AsyncSession) -> None:
        self.session = session
```

Methods:
- `add(user_id, book_id) -> PreBooking`: Create with status=WAITING, flush, catch IntegrityError on the partial unique index and re-raise as AppError(409, "You already have an active pre-booking for this book", "PREBOOK_DUPLICATE", "book_id"). After flush, do `await self.session.refresh(prebook, ["book"])` to load the book relationship.
- `get_all_for_user(user_id) -> list[PreBooking]`: SELECT with `selectinload(PreBooking.book)`, ordered by `created_at DESC`. Return ALL statuses (waiting, notified, cancelled) — no filtering. Claude's discretion decision: return all, let client filter.
- `get_by_id(prebook_id) -> PreBooking | None`: Simple SELECT by id.
- `cancel(prebook) -> PreBooking`: Set `prebook.status = PreBookStatus.CANCELLED`, `prebook.cancelled_at = datetime.now(UTC)`, flush, return.
- `notify_waiting_by_book(book_id) -> list[int]`: Bulk UPDATE using SQLAlchemy `update()` expression:
  ```python
  from sqlalchemy import update
  result = await self.session.execute(
      update(PreBooking)
      .where(PreBooking.book_id == book_id, PreBooking.status == PreBookStatus.WAITING)
      .values(status=PreBookStatus.NOTIFIED, notified_at=datetime.now(UTC))
      .returning(PreBooking.user_id)
  )
  return list(result.scalars().all())
  ```
  Returns list of user_ids whose pre-bookings were notified. Returns empty list if no waiting pre-bookings exist.

**3. app/prebooks/service.py** — PreBookService with business logic:

```python
class PreBookService:
    def __init__(self, prebook_repo: PreBookRepository, book_repo: BookRepository) -> None:
        self.prebook_repo = prebook_repo
        self.book_repo = book_repo
```

Methods:
- `create(user_id, book_id) -> PreBooking`:
  1. Fetch book via `self.book_repo.get_by_id(book_id)` — raise AppError(404, "Book not found", "BOOK_NOT_FOUND", "book_id") if None
  2. Check `book.stock_quantity > 0` — raise AppError(409, "Book is in stock — add to cart instead", "PREBOOK_BOOK_IN_STOCK", "book_id")
  3. Call `self.prebook_repo.add(user_id, book_id)` — duplicate detection handled by repository via partial unique index
  4. Return the pre-booking
- `list(user_id) -> list[PreBooking]`: Delegate to `self.prebook_repo.get_all_for_user(user_id)`
- `cancel(user_id, prebook_id) -> None`:
  1. Fetch prebook via `self.prebook_repo.get_by_id(prebook_id)` — raise AppError(404, ..., "PREBOOK_NOT_FOUND") if None or `prebook.user_id != user_id` (ownership check — never reveal existence to other users)
  2. Check `prebook.status == PreBookStatus.CANCELLED` — raise AppError(409, "Pre-booking is already cancelled", "PREBOOK_ALREADY_CANCELLED")
  3. Call `self.prebook_repo.cancel(prebook)`

**4. app/prebooks/router.py** — Three endpoints:

```python
router = APIRouter(prefix="/prebooks", tags=["prebooks"])
```

- `POST /prebooks` (201): Accepts `PreBookCreate` body. Uses `ActiveUser` dependency (not CurrentUser — per Phase 10 pattern). Extracts `user_id = int(current_user["sub"])`. Calls `PreBookService.create()`. Returns `PreBookResponse`.
- `GET /prebooks` (200): Uses `ActiveUser`. Calls `PreBookService.list()`. Returns `PreBookListResponse` with items.
- `DELETE /prebooks/{prebook_id}` (204): Uses `ActiveUser`. Calls `PreBookService.cancel()`. Returns nothing (204 No Content). This is the soft-delete endpoint — DELETE verb is semantically correct for "user removes their pre-booking" even though the record is preserved as CANCELLED.

Router helper `_make_service(db)` follows wishlist pattern:
```python
def _make_service(db: DbSession) -> PreBookService:
    return PreBookService(
        prebook_repo=PreBookRepository(db),
        book_repo=BookRepository(db),
    )
```

**5. app/main.py** — Register the prebooks router:
- Import: `from app.prebooks.router import router as prebooks_router`
- Add: `application.include_router(prebooks_router)` after the wishlist router line
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && poetry run python -c "from app.prebooks.router import router; routes = [(r.path, list(r.methods)) for r in router.routes]; print('Routes:', routes); assert len(routes) == 3" && poetry run python -c "from app.main import app; paths = [r.path for r in app.routes]; print('/prebooks' in str(paths))" && poetry run ruff check app/prebooks/ app/main.py</automated>
  </verify>
  <done>
    - POST /prebooks endpoint creates pre-booking for out-of-stock books, rejects in-stock (409) and duplicates (409)
    - GET /prebooks endpoint returns all user's pre-bookings with book details
    - DELETE /prebooks/{id} endpoint soft-cancels a pre-booking (status=CANCELLED)
    - PreBookService enforces business rules: book exists, book is out of stock, ownership check on cancel
    - PreBookRepository handles IntegrityError for duplicate detection via partial unique index
    - Router registered in app/main.py
    - ruff check passes on all new files
  </done>
</task>

<task type="auto">
  <name>Task 3: Extend BookService.set_stock with restock notification broadcast</name>
  <files>
    app/books/service.py
    app/books/router.py
  </files>
  <action>
**1. app/books/service.py** — Add `set_stock_and_notify()` method to BookService:

Add a new method (do NOT remove the existing `set_stock` — it may be called from checkout or other paths):

```python
async def set_stock_and_notify(
    self,
    book_id: int,
    quantity: int,
    prebook_repo: "PreBookRepository",
) -> tuple[Book, list[int]]:
    """Set stock and notify waiting pre-bookers if transitioning 0 to >0.

    Returns (book, notified_user_ids).
    Caller (router) receives user_ids for background task enqueueing (Phase 12).
    """
    book = await self._get_book_or_404(book_id)
    old_qty = book.stock_quantity
    book = await self.book_repo.set_stock(book, quantity)

    notified_user_ids: list[int] = []
    if old_qty == 0 and quantity > 0:
        notified_user_ids = await prebook_repo.notify_waiting_by_book(book_id)

    return book, notified_user_ids
```

The import for `PreBookRepository` uses TYPE_CHECKING to avoid circular imports:
```python
from __future__ import annotations
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from app.prebooks.repository import PreBookRepository
```

Critical design points:
- Check `old_qty == 0 AND quantity > 0` — ONLY fire on 0-to-positive transition (locked decision)
- `prebook_repo` is passed as a parameter from the router, NOT imported at module level (locked STATE.md decision — avoids circular imports)
- Returns `tuple[Book, list[int]]` — the list is user_ids from the RETURNING clause of the bulk UPDATE
- Notification happens in the SAME DB transaction as the stock update (atomic — locked decision)

**2. app/books/router.py** — Modify the `update_stock` endpoint to use `set_stock_and_notify`:

Replace the existing `update_stock` function:

```python
@router.patch("/books/{book_id}/stock", response_model=BookResponse)
async def update_stock(
    book_id: int, body: StockUpdate, db: DbSession, admin: AdminUser
) -> BookResponse:
    """Set absolute stock quantity. Admin only.

    When stock transitions from 0 to >0, all waiting pre-bookings are atomically
    notified (status set to 'notified' with notified_at timestamp).
    Phase 12 wires email dispatch for notified users.
    """
    from app.prebooks.repository import PreBookRepository  # avoid circular at module level

    service = _make_service(db)
    prebook_repo = PreBookRepository(db)
    book, notified_user_ids = await service.set_stock_and_notify(
        book_id, body.quantity, prebook_repo
    )
    # Phase 12 wires email here: for uid in notified_user_ids: email_svc.enqueue(...)
    # notified_user_ids is intentionally captured but not yet used
    return BookResponse.model_validate(book)
```

Key points:
- `PreBookRepository` imported locally inside the function body (avoids circular import — locked pattern from STATE.md)
- `notified_user_ids` is captured but not used yet — Phase 12 will wire email dispatch using BackgroundTasks
- `_make_service(db)` still creates BookService the same way — no change to the factory
- The endpoint signature stays the same (same path, method, response_model) — no breaking change
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && poetry run python -c "from app.books.service import BookService; assert hasattr(BookService, 'set_stock_and_notify'), 'Missing set_stock_and_notify'; print('BookService.set_stock_and_notify exists')" && poetry run ruff check app/books/service.py app/books/router.py</automated>
  </verify>
  <done>
    - BookService has set_stock_and_notify(book_id, quantity, prebook_repo) returning (Book, list[int])
    - Restock notification ONLY fires when old_qty == 0 AND new quantity > 0 (0-to-positive transition)
    - Notification happens atomically in the same DB transaction as stock update
    - PATCH /books/{id}/stock endpoint uses set_stock_and_notify and captures notified_user_ids (Phase 12 wires email)
    - PreBookRepository imported locally in router to avoid circular imports
    - Existing set_stock method preserved for backward compatibility
    - ruff check passes on both modified files
  </done>
</task>

</tasks>

<verification>
After all three tasks complete, verify the full feature:

1. **Model integrity:** `poetry run python -c "from app.prebooks.models import PreBooking, PreBookStatus; assert PreBookStatus.WAITING.value == 'waiting'; assert PreBookStatus.NOTIFIED.value == 'notified'; assert PreBookStatus.CANCELLED.value == 'cancelled'"`

2. **Repository methods exist:** `poetry run python -c "from app.prebooks.repository import PreBookRepository; methods = ['add', 'get_all_for_user', 'get_by_id', 'cancel', 'notify_waiting_by_book']; [getattr(PreBookRepository, m) for m in methods]; print('All repository methods exist')"`

3. **Service methods exist:** `poetry run python -c "from app.prebooks.service import PreBookService; methods = ['create', 'list', 'cancel']; [getattr(PreBookService, m) for m in methods]; print('All service methods exist')"`

4. **Router routes registered:** `poetry run python -c "from app.main import app; paths = [r.path for r in app.routes]; assert '/prebooks' in paths or any('/prebooks' in p for p in paths); print('Router registered')"`

5. **BookService extension:** `poetry run python -c "import inspect; from app.books.service import BookService; sig = inspect.signature(BookService.set_stock_and_notify); params = list(sig.parameters.keys()); assert 'prebook_repo' in params; print('set_stock_and_notify has prebook_repo param')"`

6. **Lint clean:** `poetry run ruff check app/prebooks/ app/books/service.py app/books/router.py app/main.py alembic/env.py`
</verification>

<success_criteria>
- PreBooking model with partial unique index and PreBookStatus enum deployed via Alembic migration
- Three API endpoints operational: POST /prebooks (201), GET /prebooks (200), DELETE /prebooks/{id} (204)
- POST /prebooks rejects in-stock books (409 PREBOOK_BOOK_IN_STOCK) and duplicates (409 PREBOOK_DUPLICATE)
- DELETE /prebooks/{id} soft-deletes via status=CANCELLED with cancelled_at timestamp
- PATCH /books/{id}/stock atomically transitions waiting pre-bookings to notified on 0-to->0 stock change
- All new files pass ruff check with zero violations
</success_criteria>

<output>
After completion, create `.planning/phases/11-pre-booking/11-01-SUMMARY.md`
</output>
