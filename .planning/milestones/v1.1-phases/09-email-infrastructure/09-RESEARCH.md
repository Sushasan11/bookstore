# Phase 9: Email Infrastructure - Research

**Researched:** 2026-02-26
**Domain:** Transactional email — fastapi-mail, Jinja2 templates, FastAPI BackgroundTasks
**Confidence:** HIGH

---

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

**Template design**
- Shared base layout (`base.html` with header/footer/branding) — each email template extends it
- Templates colocated with email module at `app/email/templates/`
- Plain-text fallback auto-generated by stripping HTML tags from rendered output — no separate .txt templates
- Phase 9 ships base layout only; concrete email templates (order confirmation, restock alert) are Phase 12

**Service interface**
- Direct service call pattern — endpoint calls `email_service.send(to, template, context)` explicitly
- `EmailService` class injected via FastAPI `Depends` — consistent with existing repository/service DI pattern
- Single recipient per call (`to: str`) — no CC/BCC support needed
- Use `fastapi-mail` library — built-in Jinja2 support, MAIL_SUPPRESS_SEND flag, battle-tested FastAPI integration

**Post-commit safety**
- BackgroundTasks pattern — email added to FastAPI's `BackgroundTasks` in the endpoint, runs after response/commit
- Log and drop on SMTP failure — structured log entry with recipient, template, error; no retry mechanism
- Trust the caller — no runtime guard checking DB commit state; document the correct usage pattern
- Logging only for failed sends — no failed-email DB table; check logs if issues arise

**Dev/test workflow**
- `MAIL_*` config fields added to existing pydantic-settings `Settings` class — env vars for all environments
- Suppressed emails captured in a mailbox fixture for test assertions (recipient, subject, rendered content)
- Dev mode logs rendered email to console (recipient, subject, HTML/text body) — no external SMTP trap needed
- Both unit tests (template rendering, service logic) and integration tests (full render-send-capture pipeline)

### Claude's Discretion
- Exact base template HTML/CSS styling
- mailbox fixture implementation details
- Console logging format for dev mode
- How to structure the auto-strip HTML-to-text conversion

### Deferred Ideas (OUT OF SCOPE)
None — discussion stayed within phase scope
</user_constraints>

---

<phase_requirements>
## Phase Requirements

| ID | Description | Research Support |
|----|-------------|-----------------|
| EMAL-01 | Email infrastructure exists with async SMTP sending via fastapi-mail | fastapi-mail 1.6.2 ConnectionConfig + FastMail pattern; install via poetry |
| EMAL-04 | Emails use Jinja2 HTML templates with plain-text fallback | fastapi-mail's `TEMPLATE_FOLDER` + `template_name`; plain-text via `alternative_body` with stripped HTML |
| EMAL-05 | Email sending never blocks or delays the API response (BackgroundTasks) | `background_tasks.add_task(fm.send_message, message)` — FastAPI guarantees execution after response sent |
| EMAL-06 | Email is only sent after the database transaction commits (no email on rollback) | BackgroundTasks run after the response is sent; `get_db` commits before response completes; no email if exception raised |
</phase_requirements>

---

## Summary

Phase 9 builds the email plumbing: a reusable `EmailService` class backed by `fastapi-mail` 1.6.2, Jinja2 HTML templates with a shared `base.html`, auto-generated plain-text fallbacks, and test infrastructure using `SUPPRESS_SEND=1` + `record_messages()` outbox capture. The service exposes a single method — `send(to, template_name, context)` — that endpoints call, then pass `FastMail.send_message` as a `BackgroundTask` so SMTP never blocks the HTTP response.

The post-commit safety guarantee (EMAL-06) does not require special code: the project's existing `get_db` dependency in `app/core/deps.py` commits after `yield` and rollbacks on exception. Because `BackgroundTasks` are enqueued in the router (after the service call returns a result) and executed after the response is sent (which happens after `get_db`'s commit), any email added to `BackgroundTasks` only runs when the commit has already occurred. If the service raises an exception before returning, control never reaches `background_tasks.add_task(...)`, so no email is dispatched on rollback. This is why the decision is "trust the caller" — the safety is structural, not guarded.

The test approach uses `fastapi-mail`'s built-in `record_messages()` context manager (requires `blinker`) with `SUPPRESS_SEND=1`. When `SUPPRESS_SEND` is truthy, `send_message()` skips the SMTP session but still fires the `email_dispatched` blinker signal, which `record_messages()` collects into an `outbox` list. This means test assertions can inspect `outbox[0]["subject"]`, recipients, and rendered body without any real mail server.

**Primary recommendation:** Implement `EmailService` as a standalone class (not a FastAPI router), configure `FastMail` from `Settings`, and use `background_tasks.add_task(email_service.fm.send_message, message, template_name=...)` at the router layer. Keep the service interface minimal: `send(to, template_name, context)` returns the `MessageSchema` to allow the router to enqueue it.

---

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| fastapi-mail | 1.6.2 (Feb 2026) | SMTP sending, Jinja2 templating, test suppression | Only production-ready FastAPI email library; built-in SUPPRESS_SEND and record_messages; active maintenance |
| blinker | (fastapi-mail dep) | Signal bus for record_messages() outbox | Required by fastapi-mail's testing feature; auto-installed as dependency |
| Jinja2 | (FastAPI dep) | HTML template rendering | Already a FastAPI transitive dependency; template inheritance for base.html |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| python-multipart | (already installed) | Not needed here | Already in pyproject.toml |
| re (stdlib) | N/A | Strip HTML tags for plain-text fallback | Use `re.sub(r'<[^>]+>', '', html)` for simple auto-strip |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| fastapi-mail | aiosmtplib directly | Lower level — no Jinja2 integration, no SUPPRESS_SEND, manual message construction |
| re.sub for plain text | BeautifulSoup | bs4 adds a dependency; re.sub is sufficient for generated (clean) HTML output |
| BackgroundTasks | Celery/arq | Out of scope per STATE.md decision; BackgroundTasks sufficient at v1.1 volume |

**Installation:**
```bash
poetry add "fastapi-mail==1.6.2"
# blinker is installed automatically as fastapi-mail dependency
```

---

## Architecture Patterns

### Recommended Project Structure
```
app/
└── email/
    ├── __init__.py
    ├── service.py          # EmailService class — wraps FastMail, Jinja2, strip-text
    └── templates/
        ├── base.html       # Shared layout: header, footer, branding (Phase 9 deliverable)
        └── (Phase 12 adds: order_confirmation.html, restock_alert.html)
```

No `models.py`, `repository.py`, `router.py`, or `schemas.py` — the email module has no DB model, no HTTP endpoints, and no Pydantic schemas. It is a pure service module.

### Pattern 1: EmailService Class

**What:** A class that wraps `FastMail`, renders Jinja2 templates, generates plain-text fallback, and returns a `MessageSchema` ready for enqueueing as a BackgroundTask.

**When to use:** All email sends — instantiated once via `Depends`, reused per request.

```python
# app/email/service.py
# Source: fastapi-mail docs (sabuhish.github.io/fastapi-mail/example/)

from pathlib import Path
from fastapi_mail import FastMail, MessageSchema, MessageType, ConnectionConfig
from fastapi_mail.schemas import MultipartSubtypeEnum
import re
import logging

logger = logging.getLogger(__name__)

class EmailService:
    def __init__(self, config: ConnectionConfig) -> None:
        self.fm = FastMail(config)

    def _strip_html(self, html: str) -> str:
        """Auto-generate plain text by stripping HTML tags."""
        text = re.sub(r'<[^>]+>', '', html)
        # Collapse excessive whitespace
        return re.sub(r'\s+', ' ', text).strip()

    async def send(
        self,
        to: str,
        template_name: str,
        context: dict,
    ) -> MessageSchema:
        """Build MessageSchema. Caller enqueues via background_tasks.add_task()."""
        message = MessageSchema(
            subject=context.get("subject", "Bookstore Notification"),
            recipients=[to],
            template_body=context,
            subtype=MessageType.html,
        )
        return message

    async def send_now(
        self,
        to: str,
        template_name: str,
        context: dict,
    ) -> None:
        """Direct send (for testing or non-background scenarios)."""
        message = await self.send(to, template_name, context)
        try:
            await self.fm.send_message(message, template_name=template_name)
        except Exception as exc:
            logger.error(
                "Email send failed",
                extra={"recipient": to, "template": template_name, "error": str(exc)},
            )
```

**Note on design choice:** The `CONTEXT.md` specifies the service interface as `email_service.send(to, template, context)`. Two reasonable implementations:

**Option A — Service returns MessageSchema, router enqueues:**
```python
# router.py
message = await email_service.build_message(to, template_name, context)
background_tasks.add_task(email_service.fm.send_message, message, template_name=template_name)
```

**Option B — Service owns the enqueue step:**
```python
# service.py
def enqueue(self, background_tasks: BackgroundTasks, to, template_name, context):
    message = MessageSchema(...)
    background_tasks.add_task(self.fm.send_message, message, template_name=template_name)
```

Option B is cleaner for this project — it keeps all email plumbing inside `EmailService` and matches the project's existing service-layer encapsulation pattern. The router just calls `email_service.enqueue(background_tasks, to, template_name, context)`.

### Pattern 2: ConnectionConfig from Settings

**What:** Build `ConnectionConfig` from pydantic-settings `Settings`, not hardcoded values.

```python
# app/email/service.py
from app.core.config import get_settings

def get_email_config() -> ConnectionConfig:
    s = get_settings()
    return ConnectionConfig(
        MAIL_USERNAME=s.MAIL_USERNAME,
        MAIL_PASSWORD=s.MAIL_PASSWORD,
        MAIL_FROM=s.MAIL_FROM,
        MAIL_PORT=s.MAIL_PORT,
        MAIL_SERVER=s.MAIL_SERVER,
        MAIL_FROM_NAME=s.MAIL_FROM_NAME,
        MAIL_STARTTLS=True,
        MAIL_SSL_TLS=False,
        USE_CREDENTIALS=True,
        VALIDATE_CERTS=True,
        SUPPRESS_SEND=s.MAIL_SUPPRESS_SEND,   # 0 in prod, 1 in test
        TEMPLATE_FOLDER=Path(__file__).parent / "templates",
    )

def get_email_service() -> EmailService:
    return EmailService(config=get_email_config())

# In router:
EmailSvc = Annotated[EmailService, Depends(get_email_service)]
```

### Pattern 3: BackgroundTasks Post-Commit Guarantee

**What:** Structural guarantee that email fires only after DB commit.

**How the guarantee works:**
1. `get_db` (in `app/core/deps.py`) commits after `yield`, on no-exception exit
2. `get_db` rollbacks if any exception propagates out of the route handler
3. `background_tasks.add_task(...)` is called in the router, after the service call succeeds
4. If the service raises an exception, control never reaches `add_task`
5. FastAPI executes BackgroundTasks after the response is sent — which is after `get_db` commits

```python
# router.py — correct pattern
@router.post("/checkout", ...)
async def checkout(
    body: CheckoutRequest,
    db: DbSession,
    background_tasks: BackgroundTasks,
    email_svc: EmailSvc,
    current_user: CurrentUser,
) -> OrderResponse:
    user_id = int(current_user["sub"])
    service = _make_service(db)
    order = await service.checkout(user_id, body)  # raises on failure → no email
    # Only reached if checkout succeeded (commit will happen via get_db)
    email_svc.enqueue(background_tasks, current_user["email"], "order_confirmation.html", {...})
    return OrderResponse.model_validate(order)
```

### Pattern 4: Jinja2 Template with Inheritance

**What:** `base.html` defines structure; each email extends it via `{% extends "base.html" %}`.

```html
<!-- app/email/templates/base.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{% block title %}Bookstore{% endblock %}</title>
</head>
<body style="font-family: Arial, sans-serif; background-color: #f4f4f4; margin: 0; padding: 0;">
  <table width="100%" cellpadding="0" cellspacing="0">
    <tr>
      <td align="center">
        <table width="600" cellpadding="20" cellspacing="0"
               style="background-color: #ffffff; margin: 30px auto;">
          <!-- Header -->
          <tr>
            <td style="background-color: #1a202c; color: #ffffff; text-align: center;">
              <h1 style="margin: 0; font-size: 24px;">Bookstore</h1>
            </td>
          </tr>
          <!-- Content block -->
          <tr>
            <td>{% block content %}{% endblock %}</td>
          </tr>
          <!-- Footer -->
          <tr>
            <td style="background-color: #f4f4f4; text-align: center;
                       font-size: 12px; color: #718096;">
              {% block footer %}
              <p>You received this email because you have an account with Bookstore.</p>
              {% endblock %}
            </td>
          </tr>
        </table>
      </td>
    </tr>
  </table>
</body>
</html>
```

**Note on template_body:** fastapi-mail passes `template_body` to the Jinja2 template. When `template_body` is a dict, variables are available directly in the template (e.g., `{{ user_name }}`). When `template_body` is not a dict, the variable is available as `{{ body }}`.

### Pattern 5: Testing with record_messages Outbox

**What:** `FastMail.record_messages()` context manager captures dispatched messages for assertions without real SMTP.

**Requirements:** `blinker` must be installed (auto-installed with fastapi-mail). `SUPPRESS_SEND=1` in `ConnectionConfig`.

```python
# tests/test_email.py
import pytest
from fastapi_mail import FastMail, MessageSchema, MessageType, ConnectionConfig
from pathlib import Path

@pytest.fixture
def mail_config():
    return ConnectionConfig(
        MAIL_USERNAME="test",
        MAIL_PASSWORD="test",
        MAIL_FROM="test@bookstore.com",
        MAIL_PORT=587,
        MAIL_SERVER="smtp.test.com",
        MAIL_STARTTLS=True,
        MAIL_SSL_TLS=False,
        USE_CREDENTIALS=True,
        SUPPRESS_SEND=1,           # No real SMTP
        TEMPLATE_FOLDER=Path("app/email/templates"),
    )

async def test_email_captured_in_outbox(mail_config):
    fm = FastMail(mail_config)
    message = MessageSchema(
        subject="Test Email",
        recipients=["user@example.com"],
        template_body={"user_name": "Test User"},
        subtype=MessageType.html,
    )
    with fm.record_messages() as outbox:
        await fm.send_message(message, template_name="base.html")
        assert len(outbox) == 1
        assert outbox[0]["subject"] == "Test Email"
        assert "user@example.com" in outbox[0]["To"]
```

**How `record_messages` works internally:**
- Creates an `outbox` list
- Connects a `_record(message, app)` callback to fastapi-mail's `email_dispatched` blinker signal
- When `SUPPRESS_SEND=1`, `send_message()` skips actual SMTP but still fires the signal
- Each sent message is appended to `outbox`
- On context exit, disconnects the callback

### Anti-Patterns to Avoid

- **Sending email inside the DB transaction:** Calling `await fm.send_message(...)` before `get_db`'s commit means email fires even if DB rollbacks later. Always enqueue via `BackgroundTasks`, never `await` inside route handlers.
- **Passing the DB session to BackgroundTasks:** Sessions are not thread-safe. The email background task must not hold a reference to `db` session. Email content must be extracted (to string, template context as plain dict) before enqueueing.
- **Instantiating FastMail per-email:** Create `FastMail(config)` once (in `EmailService.__init__`), reuse for all sends. Config parsing has overhead.
- **Using `template_body` as a non-dict when variables are needed:** If `template_body` is not a dict, Jinja2 receives it as `{{ body }}`; if a dict, keys are available directly. Use dict always.
- **Forgetting blinker for tests:** `record_messages()` raises `RuntimeError("blinker must be installed")` if blinker is absent. It installs with fastapi-mail but verify with `poetry show blinker`.

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| SMTP connection pooling | Custom aiosmtplib session | `FastMail` from fastapi-mail | Handles connection lifecycle, TLS negotiation, error handling |
| Template rendering | Manual `jinja2.Environment` setup | `ConnectionConfig(TEMPLATE_FOLDER=...)` + `send_message(..., template_name=)` | fastapi-mail auto-initialises Jinja2 environment from the folder |
| Test email suppression | Mock/patch `FastMail.send_message` | `SUPPRESS_SEND=1` + `record_messages()` | Built-in; no monkey-patching required |
| Multipart plain text | Separate `.txt` template | `re.sub(r'<[^>]+>', '', html)` on rendered HTML | Decision locked: auto-strip, no separate templates |

**Key insight:** fastapi-mail handles the SMTP/Jinja2 integration, test suppression, and background task compatibility. The only custom code needed is the `EmailService` wrapper class and the `re.sub` strip function.

---

## Common Pitfalls

### Pitfall 1: Email Fires Before Commit (Wrong Pattern)
**What goes wrong:** Email is sent synchronously inside the route handler before `get_db` commits, e.g., `await email_svc.send_now(...)` directly in the route body.
**Why it happens:** Developer mistakes `await` (synchronous in-request send) for BackgroundTasks enqueue.
**How to avoid:** Always use `background_tasks.add_task(...)`. Never `await` SMTP inside route handlers. Document the pattern in `EmailService.enqueue()` docstring.
**Warning signs:** Email arrives even when DB operation later rolls back; email arrives before HTTP response returns.

### Pitfall 2: DB Session Leaked into BackgroundTask
**What goes wrong:** Background task closure captures the `AsyncSession` from `get_db`; by the time the task runs, the session is closed.
**Why it happens:** Python closure captures the `db` variable reference.
**How to avoid:** `EmailService.enqueue()` must accept only serialisable data (strings, dicts) — no SQLAlchemy model objects or session references. Extract all needed data before calling `enqueue`.
**Warning signs:** `MissingGreenlet` error or `DetachedInstanceError` inside background tasks.

### Pitfall 3: record_messages Without SUPPRESS_SEND
**What goes wrong:** Real SMTP connection attempt during tests causes test failures or slow timeouts.
**Why it happens:** `record_messages()` captures the signal but doesn't prevent sending — `SUPPRESS_SEND` does. They must be used together.
**How to avoid:** Always set `SUPPRESS_SEND=1` in test `ConnectionConfig`. Use a pytest fixture that builds the suppressed config.
**Warning signs:** Tests hang or raise SMTP connection errors; `record_messages` outbox is still populated but email was actually sent.

### Pitfall 4: Template Context Variable Naming
**What goes wrong:** Variables in Jinja2 template `{{ user_name }}` are undefined; template renders with empty values.
**Why it happens:** fastapi-mail passes `template_body` dict directly — keys become template variables. If `template_body` is a string/object, the template sees `{{ body }}`.
**How to avoid:** Always pass `template_body` as a `dict`. Verify template variable names match dict keys.
**Warning signs:** Template renders successfully but all dynamic values are blank.

### Pitfall 5: BackgroundTask Not Running in Tests
**What goes wrong:** Integration test calls endpoint but `outbox` is empty — email background task never ran.
**Why it happens:** `httpx.AsyncClient` (used in conftest.py) runs background tasks synchronously after the response; `record_messages()` context must wrap the client call.
**How to avoid:** Use `with fm.record_messages() as outbox:` wrapping the `await client.post(...)` call. The background task runs before the `with` block exits.
**Warning signs:** `assert len(outbox) == 1` fails with `outbox == []` even though endpoint returned 200.

### Pitfall 6: Missing MAIL_* Settings Break Startup
**What goes wrong:** Application fails to start or `EmailService` raises validation error in non-email tests.
**Why it happens:** pydantic-settings with required `MAIL_USERNAME` etc. fails if not set in `.env`.
**How to avoid:** Give all `MAIL_*` settings sensible defaults (empty strings or test values) in `Settings`. Only raise if actually sending. Consider `MAIL_SUPPRESS_SEND: int = 1` (default suppress in non-prod).
**Warning signs:** `ValidationError` on `Settings` import in tests that don't test email.

---

## Code Examples

Verified patterns from official sources:

### Full ConnectionConfig (all fields)
```python
# Source: sabuhish.github.io/fastapi-mail/example/ + getting-started docs
from fastapi_mail import ConnectionConfig
from pathlib import Path

conf = ConnectionConfig(
    MAIL_USERNAME="username",
    MAIL_PASSWORD="**********",
    MAIL_FROM="noreply@bookstore.com",
    MAIL_PORT=587,
    MAIL_SERVER="smtp.gmail.com",
    MAIL_FROM_NAME="Bookstore",
    MAIL_STARTTLS=True,
    MAIL_SSL_TLS=False,
    USE_CREDENTIALS=True,
    VALIDATE_CERTS=True,
    SUPPRESS_SEND=0,          # 1 in tests/dev
    TEMPLATE_FOLDER=Path(__file__).parent / "templates",
)
```

### BackgroundTasks Enqueue (canonical pattern)
```python
# Source: sabuhish.github.io/fastapi-mail/example/
from fastapi import BackgroundTasks
from fastapi_mail import FastMail, MessageSchema, MessageType

@app.post("/emailbackground")
async def send_in_background(
    background_tasks: BackgroundTasks,
    email: EmailSchema,
) -> JSONResponse:
    message = MessageSchema(
        subject="Fastapi mail module",
        recipients=email.dict().get("email"),
        body="Simple background task",
        subtype=MessageType.plain,
    )
    fm = FastMail(conf)
    background_tasks.add_task(fm.send_message, message)
    return JSONResponse(status_code=200, content={"message": "email has been sent"})
```

### Jinja2 Template Send
```python
# Source: sabuhish.github.io/fastapi-mail/example/
message = MessageSchema(
    subject="Welcome to Bookstore",
    recipients=["user@example.com"],
    template_body={"user_name": "Alice", "subject": "Welcome"},
    subtype=MessageType.html,
)
fm = FastMail(conf)
# In background task:
await fm.send_message(message, template_name="welcome.html")
```

### Multipart HTML + Plain Text (alternative_body)
```python
# Source: sabuhish.github.io/fastapi-mail/example/
from fastapi_mail.schemas import MultipartSubtypeEnum

message = MessageSchema(
    subject="Bookstore Notification",
    recipients=["user@example.com"],
    template_body={"user_name": "Alice"},
    subtype=MessageType.html,
    alternative_body="Plain text fallback content",
    multipart_subtype=MultipartSubtypeEnum.alternative,
)
```

**Note:** For the auto-strip approach (locked decision), render HTML first, then strip for `alternative_body`:
```python
# Strip HTML for plain-text fallback
import re

def strip_html(html: str) -> str:
    text = re.sub(r'<[^>]+>', '', html)
    return re.sub(r'\s+', ' ', text).strip()
```

Since fastapi-mail renders the Jinja2 template internally, the service needs to render the template manually first (using `jinja2.Environment`) to get the HTML string before stripping. Alternative: pass plain text as a context value in the template_body dict and build the alternative separately in the Jinja2 template.

**Simpler approach:** Use `alternative_body` with a hardcoded "Please view this email in an HTML-capable client." or render the template manually with `jinja2.Environment.from_string()` — given Phase 9 only ships `base.html`, this can be deferred to Phase 12 when concrete templates exist.

### record_messages Outbox (test pattern)
```python
# Source: github.com/sabuhish/fastapi-mail/blob/master/fastapi_mail/fastmail.py
# record_messages() requires blinker

with fm.record_messages() as outbox:
    response = await client.post("/some-endpoint-that-sends-email", ...)
    assert len(outbox) == 1
    assert outbox[0]["subject"] == "Expected Subject"
    assert "recipient@example.com" in outbox[0]["To"]
```

### Settings Extension for Email
```python
# app/core/config.py — add to existing Settings class
class Settings(BaseSettings):
    # ... existing fields ...

    # Email
    MAIL_USERNAME: str = ""
    MAIL_PASSWORD: str = ""
    MAIL_FROM: str = "noreply@bookstore.com"
    MAIL_PORT: int = 587
    MAIL_SERVER: str = "smtp.gmail.com"
    MAIL_FROM_NAME: str = "Bookstore"
    MAIL_SUPPRESS_SEND: int = 1  # Default: suppress (safe); prod sets to 0

    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        case_sensitive=False,
    )
```

**Note:** `SUPPRESS_SEND` is the field name in `ConnectionConfig`. Naming the `Settings` field `MAIL_SUPPRESS_SEND` avoids collision with the ConnectionConfig attribute name.

---

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| smtplib (sync) | fastapi-mail + aiosmtplib (async) | FastAPI era | Non-blocking SMTP; required for async apps |
| Separate .txt templates | `alternative_body` or auto-strip | fastapi-mail v1.x | Simpler maintenance; one template per email |
| Global FastMail instance | Per-request via Depends | Current pattern | Testable; config injectable |
| Patching send_message in tests | SUPPRESS_SEND + record_messages | fastapi-mail v1.x | No monkey-patching; cleaner tests |

**Deprecated/outdated:**
- `MAIL_SUPPRESS_SEND` as ConnectionConfig field name: the actual field is `SUPPRESS_SEND` (not `MAIL_SUPPRESS_SEND`). The `MAIL_` prefix is only used in `Settings`.

---

## Open Questions

1. **Manual Jinja2 render for plain-text strip**
   - What we know: fastapi-mail renders templates internally; there is no public API to get the rendered HTML string before sending
   - What's unclear: Whether `EmailService` should use `jinja2.Environment` directly for pre-render (to strip), or defer plain-text to Phase 12
   - Recommendation: Phase 9 ships `alternative_body="Please view in an HTML-capable email client."` as a hardcoded stub. Phase 12 adds proper auto-strip when concrete templates exist and rendered HTML is available.

2. **`background_tasks.add_task` in integration tests with httpx**
   - What we know: httpx's `ASGITransport` runs Starlette's full lifecycle including BackgroundTasks after response
   - What's unclear: Whether `record_messages()` must wrap the entire `client.post(...)` call or only needs to be active during task execution
   - Recommendation: Wrap the full `await client.post(...)` inside `with fm.record_messages() as outbox:` — this is the documented pattern. Background tasks run synchronously in test scope before `with` block exits.

3. **EmailService as Depends vs singleton**
   - What we know: The decision is to inject via `Depends`; `get_settings()` is `lru_cache`-cached
   - What's unclear: Whether `FastMail(config)` is cheap to instantiate per-request
   - Recommendation: Cache `EmailService` via `lru_cache` on `get_email_service()`, similar to how `get_settings()` is cached. FastMail wraps a `ConnectionConfig`, so per-request instantiation is low-cost but caching is cleaner.

---

## Validation Architecture

### Test Framework
| Property | Value |
|----------|-------|
| Framework | pytest 9.0.2 + pytest-asyncio 1.3.0 |
| Config file | `pyproject.toml` (`[tool.pytest.ini_options]`) |
| Quick run command | `pytest tests/test_email.py -v` |
| Full suite command | `pytest tests/ -v` |

### Phase Requirements → Test Map
| Req ID | Behavior | Test Type | Automated Command | File Exists? |
|--------|----------|-----------|-------------------|-------------|
| EMAL-01 | FastMail can be instantiated with valid ConnectionConfig | unit | `pytest tests/test_email.py::TestEmailService::test_service_instantiates -x` | Wave 0 |
| EMAL-04 | Jinja2 renders base.html without error; template_body vars are accessible | unit | `pytest tests/test_email.py::TestEmailTemplates::test_base_template_renders -x` | Wave 0 |
| EMAL-04 | alternative_body plain-text fallback is present in sent message | unit | `pytest tests/test_email.py::TestEmailTemplates::test_plain_text_fallback -x` | Wave 0 |
| EMAL-05 | BackgroundTasks enqueue does not block HTTP response | integration | `pytest tests/test_email.py::TestEmailIntegration::test_background_task_does_not_delay_response -x` | Wave 0 |
| EMAL-06 | Email not dispatched when endpoint raises before add_task | integration | `pytest tests/test_email.py::TestEmailIntegration::test_no_email_on_route_error -x` | Wave 0 |

### Sampling Rate
- **Per task commit:** `pytest tests/test_email.py -v`
- **Per wave merge:** `pytest tests/ -v`
- **Phase gate:** Full suite green before `/gsd:verify-work`

### Wave 0 Gaps
- [ ] `tests/test_email.py` — covers EMAL-01, EMAL-04, EMAL-05, EMAL-06
- [ ] `conftest.py` update — add `mail_config` and `email_service` fixtures with `SUPPRESS_SEND=1`
- [ ] `app/email/__init__.py` — module init (empty)
- [ ] `app/email/service.py` — EmailService class
- [ ] `app/email/templates/base.html` — base layout template
- [ ] Framework install: `poetry add "fastapi-mail==1.6.2"` — not yet in pyproject.toml

---

## Sources

### Primary (HIGH confidence)
- `sabuhish.github.io/fastapi-mail/example/` — ConnectionConfig fields, MessageSchema, BackgroundTasks pattern, Jinja2 setup, SUPPRESS_SEND, record_messages
- `github.com/sabuhish/fastapi-mail/blob/master/fastapi_mail/fastmail.py` — record_messages() implementation, SUPPRESS_SEND behavior, email_dispatched signal, send_message() signature
- `pypi.org/project/fastapi-mail/` — version 1.6.2 (released Feb 17, 2026), Python 3.10-3.14 support, changelog
- `fastapi.tiangolo.com/tutorial/background-tasks/` — BackgroundTasks execution timing (after response sent), Depends integration

### Secondary (MEDIUM confidence)
- `sabuhish.github.io/fastapi-mail/getting-started/` — `SUPPRESS_SEND` field name confirmed (not `MAIL_SUPPRESS_SEND`), `TEMPLATE_FOLDER` usage
- `github.com/sabuhish/fastapi-mail/blob/master/docs/example.md` — `alternative_body` + `MultipartSubtypeEnum.alternative` for plain text, `html_template` + `plain_template` as separate template alternative

### Tertiary (LOW confidence)
- WebSearch community results on BackgroundTasks + SQLAlchemy session timing — consistent with official FastAPI docs; session safety confirmed via multiple sources

---

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH — fastapi-mail 1.6.2 verified on PyPI (Feb 2026); blinker dependency confirmed via fastmail.py source
- Architecture: HIGH — ConnectionConfig, FastMail, MessageSchema, BackgroundTasks patterns verified from official docs and source
- Pitfalls: MEDIUM — post-commit safety is structural (get_db lifecycle); BackgroundTask timing confirmed by FastAPI docs; session leak pitfall is known SQLAlchemy pattern
- Test patterns: HIGH — record_messages() implementation read directly from fastmail.py source code

**Research date:** 2026-02-26
**Valid until:** 2026-03-28 (30 days — fastapi-mail is actively maintained; check PyPI for new releases before planning)
