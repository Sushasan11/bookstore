---
phase: 12-email-notifications-wiring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/email/templates/order_confirmation.html
  - app/email/templates/restock_alert.html
  - app/users/repository.py
  - app/orders/router.py
  - app/books/router.py
autonomous: true
requirements: [EMAL-02, EMAL-03]

must_haves:
  truths:
    - "After a successful checkout, an order confirmation email is enqueued via BackgroundTasks containing order ID, line items, and total"
    - "When admin restocks a book from 0 to >0, a restock alert email is enqueued for every user with a waiting pre-booking"
    - "No email is enqueued if checkout fails (cart empty, insufficient stock, payment failure)"
    - "No email is enqueued if stock update is not a 0-to-positive transition or there are no waiting pre-bookers"
    - "Email dispatch does not block or delay the HTTP response"
  artifacts:
    - path: "app/email/templates/order_confirmation.html"
      provides: "Jinja2 order confirmation email template extending base.html"
      contains: "extends \"base.html\""
    - path: "app/email/templates/restock_alert.html"
      provides: "Jinja2 restock alert email template extending base.html"
      contains: "extends \"base.html\""
    - path: "app/users/repository.py"
      provides: "Batch email lookup method"
      contains: "get_emails_by_ids"
    - path: "app/orders/router.py"
      provides: "Order confirmation email dispatch after checkout"
      contains: "email_svc.enqueue"
    - path: "app/books/router.py"
      provides: "Restock alert email dispatch after stock update"
      contains: "email_svc.enqueue"
  key_links:
    - from: "app/orders/router.py"
      to: "app/email/service.py"
      via: "EmailSvc dependency injection"
      pattern: "email_svc\\.enqueue.*order_confirmation"
    - from: "app/books/router.py"
      to: "app/email/service.py"
      via: "EmailSvc dependency injection"
      pattern: "email_svc\\.enqueue.*restock_alert"
    - from: "app/orders/router.py"
      to: "app/users/repository.py"
      via: "UserRepository.get_by_id for user email"
      pattern: "user_repo\\.get_by_id"
    - from: "app/books/router.py"
      to: "app/users/repository.py"
      via: "UserRepository.get_emails_by_ids for batch email lookup"
      pattern: "user_repo\\.get_emails_by_ids"
---

<objective>
Wire email dispatch into the checkout and stock-update routers using the Phase 9 email infrastructure. Create two Jinja2 HTML email templates (order confirmation, restock alert), add a batch email lookup method to UserRepository, and modify both routers to enqueue emails via BackgroundTasks after successful operations.

Purpose: Completes the final phase of v1.1 — users receive transactional emails for order confirmations and restock alerts, closing EMAL-02 and EMAL-03.
Output: Two new templates, one new repository method, two modified routers — all wired through the existing EmailService.enqueue() pattern.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-email-notifications-wiring/12-RESEARCH.md

@app/email/service.py
@app/email/templates/base.html
@app/orders/router.py
@app/orders/schemas.py
@app/books/router.py
@app/users/repository.py
@app/core/deps.py

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From app/email/service.py:
```python
class EmailService:
    def enqueue(self, background_tasks: BackgroundTasks, to: str, template_name: str, subject: str, context: dict) -> None: ...

EmailSvc = Annotated[EmailService, Depends(get_email_service)]
```

From app/core/deps.py:
```python
DbSession = Annotated[AsyncSession, Depends(get_db)]
ActiveUser = Annotated[dict, Depends(get_active_user)]
AdminUser = Annotated[dict, Depends(require_admin)]
# JWT payload: {"sub": "user_id_string", "role": "user|admin"} — NO email field
```

From app/users/repository.py:
```python
class UserRepository:
    def __init__(self, session: AsyncSession) -> None: ...
    async def get_by_id(self, user_id: int) -> User | None: ...
    async def get_by_email(self, email: str) -> User | None: ...
```

From app/orders/schemas.py:
```python
class OrderResponse(BaseModel):
    id: int
    status: str
    created_at: datetime
    items: list[OrderItemResponse]
    @computed_field
    @property
    def total_price(self) -> Decimal: ...  # Sum of (unit_price * quantity)

class OrderItemResponse(BaseModel):
    id: int
    book_id: int | None
    quantity: int
    unit_price: Decimal
    book: OrderItemBookSummary | None  # book.title, book.author, book.id
```

From app/email/templates/base.html:
```html
{% block title %}Bookstore{% endblock %}
{% block content %}{% endblock %}
{% block footer %}...{% endblock %}
```

From app/books/router.py (current update_stock):
```python
# Lines 139-144 — current placeholder for Phase 12:
book, notified_user_ids = await service.set_stock_and_notify(book_id, body.quantity, prebook_repo)
# Phase 12 wires email here: for uid in notified_user_ids: email_svc.enqueue(...)
_ = notified_user_ids
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create email templates and add batch email lookup to UserRepository</name>
  <files>
    app/email/templates/order_confirmation.html
    app/email/templates/restock_alert.html
    app/users/repository.py
  </files>
  <action>
**1. Create `app/email/templates/order_confirmation.html`:**

Create a Jinja2 HTML template that extends `base.html`. The template receives these context variables:
- `order_id` (int) — the order ID
- `items` (list of dicts) — each dict has `title` (str), `quantity` (int), `unit_price` (str, formatted Decimal)
- `total_price` (str, formatted Decimal)

Template structure:
```html
{% extends "base.html" %}
{% block title %}Order Confirmed — Bookstore{% endblock %}
{% block content %}
<h2 style="color: #1a202c;">Your order is confirmed!</h2>
<p>Order #{{ order_id }}</p>
<table width="100%" style="border-collapse: collapse;">
  <thead>
    <tr>
      <th style="text-align: left; padding: 8px; border-bottom: 1px solid #e2e8f0;">Book</th>
      <th style="text-align: right; padding: 8px; border-bottom: 1px solid #e2e8f0;">Qty</th>
      <th style="text-align: right; padding: 8px; border-bottom: 1px solid #e2e8f0;">Price</th>
    </tr>
  </thead>
  <tbody>
    {% for item in items %}
    <tr>
      <td style="padding: 8px; border-bottom: 1px solid #f4f4f4;">{{ item.title }}</td>
      <td style="text-align: right; padding: 8px; border-bottom: 1px solid #f4f4f4;">{{ item.quantity }}</td>
      <td style="text-align: right; padding: 8px; border-bottom: 1px solid #f4f4f4;">${{ item.unit_price }}</td>
    </tr>
    {% endfor %}
  </tbody>
</table>
<p style="text-align: right; font-weight: bold; margin-top: 16px;">Total: ${{ total_price }}</p>
{% endblock %}
```

**2. Create `app/email/templates/restock_alert.html`:**

Create a Jinja2 HTML template that extends `base.html`. The template receives:
- `book_title` (str) — the book title
- `book_id` (int) — the book ID

Template structure:
```html
{% extends "base.html" %}
{% block title %}Back in Stock — {{ book_title }}{% endblock %}
{% block content %}
<h2 style="color: #1a202c;">Good news! Your pre-booked book is back.</h2>
<p><strong>{{ book_title }}</strong> is now back in stock.</p>
<p>Visit the bookstore to add it to your cart before it sells out again.</p>
{% endblock %}
```

**3. Add `get_emails_by_ids()` to `UserRepository` in `app/users/repository.py`:**

Add a new method to the existing `UserRepository` class. Place it after the existing `get_by_id` method. This performs a single batch query using `User.id.in_(user_ids)` to fetch `{user_id: email}` mapping. Add the `User.email` import if not already present (it is — `User` model is imported at top).

```python
async def get_emails_by_ids(self, user_ids: list[int]) -> dict[int, str]:
    """Return {user_id: email} for the given list of user IDs.

    Uses a single IN query regardless of list length.
    Returns empty dict for empty input.
    """
    if not user_ids:
        return {}
    result = await self.session.execute(
        select(User.id, User.email).where(User.id.in_(user_ids))
    )
    return {row.id: row.email for row in result}
```

**IMPORTANT: Do NOT modify the `select` import** — it is already imported at the top of the file from `sqlalchemy`.

**Avoid:** Do not add any email-related imports to this file. This is purely a data-access method.
  </action>
  <verify>
    <automated>python -c "from app.users.repository import UserRepository; assert hasattr(UserRepository, 'get_emails_by_ids'), 'Method not found'" && python -c "from app.email.service import EmailService; svc = EmailService.__new__(EmailService); from jinja2 import Environment, FileSystemLoader; env = Environment(loader=FileSystemLoader('app/email/templates'), autoescape=True); t1 = env.get_template('order_confirmation.html'); t2 = env.get_template('restock_alert.html'); print('Templates load OK')"</automated>
  </verify>
  <done>
    - `order_confirmation.html` extends base.html, renders order_id + items table + total_price
    - `restock_alert.html` extends base.html, renders book_title
    - `UserRepository.get_emails_by_ids()` method exists and accepts `list[int]`, returns `dict[int, str]`
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire email dispatch into checkout and stock-update routers</name>
  <files>
    app/orders/router.py
    app/books/router.py
  </files>
  <action>
**1. Modify `app/orders/router.py` — wire order confirmation email into `checkout()`:**

Add these imports at the top of the file:
```python
from fastapi import APIRouter, BackgroundTasks, status  # add BackgroundTasks to existing import
from app.email.service import EmailSvc
from app.users.repository import UserRepository
```

Update the `checkout()` function signature to add `BackgroundTasks` and `EmailSvc` parameters:
```python
@router.post(
    "/checkout", response_model=OrderResponse, status_code=status.HTTP_201_CREATED
)
async def checkout(
    body: CheckoutRequest,
    db: DbSession,
    current_user: ActiveUser,
    background_tasks: BackgroundTasks,
    email_svc: EmailSvc,
) -> OrderResponse:
```

After `order = await service.checkout(user_id, body)`, build the response FIRST to get `total_price` (it is a `@computed_field` on `OrderResponse`, not on the ORM model), then enqueue the email:

```python
    user_id = int(current_user["sub"])
    service = _make_service(db)
    order = await service.checkout(user_id, body)

    # Build response first — total_price is a computed field on OrderResponse, not on ORM
    order_response = OrderResponse.model_validate(order)

    # Enqueue confirmation email (post-commit via BackgroundTasks — EMAL-06 safe)
    user_repo = UserRepository(db)
    user = await user_repo.get_by_id(user_id)
    if user:
        email_svc.enqueue(
            background_tasks,
            to=user.email,
            template_name="order_confirmation.html",
            subject="Your Bookstore order is confirmed",
            context={
                "order_id": order.id,
                "items": [
                    {
                        "title": item.book.title if item.book else "Unknown Book",
                        "quantity": item.quantity,
                        "unit_price": f"{item.unit_price:.2f}",
                    }
                    for item in order.items
                ],
                "total_price": f"{order_response.total_price:.2f}",
            },
        )

    return order_response
```

**CRITICAL NOTES:**
- `email_svc.enqueue()` MUST be called AFTER `service.checkout()` — never before. If checkout raises (cart empty, insufficient stock, payment failure), execution never reaches the enqueue. This is the structural guarantee for EMAL-06 compliance.
- Do NOT use `current_user["email"]` — the JWT payload has only `sub` and `role`. Always fetch from DB.
- Format prices with `f"{value:.2f}"` for consistent decimal display in the email template.
- `order.items` are eagerly loaded by the checkout service — safe to iterate.

**2. Modify `app/books/router.py` — wire restock alert emails into `update_stock()`:**

Add these imports at the top of the file:
```python
from fastapi import APIRouter, BackgroundTasks, Query, status  # add BackgroundTasks to existing import
from app.email.service import EmailSvc
```

Update the `update_stock()` function signature to add `BackgroundTasks` and `EmailSvc`:
```python
@router.patch("/books/{book_id}/stock", response_model=BookResponse)
async def update_stock(
    book_id: int,
    body: StockUpdate,
    db: DbSession,
    admin: AdminUser,
    background_tasks: BackgroundTasks,
    email_svc: EmailSvc,
) -> BookResponse:
```

Replace the placeholder `_ = notified_user_ids` block (lines 142-144) with the actual email dispatch. Add a local import for `UserRepository` (same local-import pattern used by `PreBookRepository` already in this function):

```python
    from app.prebooks.repository import PreBookRepository  # existing
    from app.users.repository import UserRepository

    service = _make_service(db)
    prebook_repo = PreBookRepository(db)
    book, notified_user_ids = await service.set_stock_and_notify(
        book_id, body.quantity, prebook_repo
    )

    # Enqueue restock alert emails for all notified users (EMAL-03)
    if notified_user_ids:
        user_repo = UserRepository(db)
        email_map = await user_repo.get_emails_by_ids(notified_user_ids)
        for uid, email_addr in email_map.items():
            email_svc.enqueue(
                background_tasks,
                to=email_addr,
                template_name="restock_alert.html",
                subject=f"'{book.title}' is back in stock",
                context={"book_title": book.title, "book_id": book.id},
            )

    return BookResponse.model_validate(book)
```

**CRITICAL NOTES:**
- Remove the placeholder comment and `_ = notified_user_ids` line entirely.
- Use `get_emails_by_ids()` for a single batch query — NOT a loop of `get_by_id()` calls (avoids N+1 queries).
- `notified_user_ids` is empty when: stock is not transitioning 0-to-positive, OR book has no waiting pre-bookers. The `if notified_user_ids:` guard handles this.
- Do NOT import `EmailService` or `UserRepository` at the module level in `app/books/router.py` — use local imports inside the function body to match the existing `PreBookRepository` pattern and avoid circular imports.

Wait — correction: `EmailSvc` is a type alias used as a function parameter annotation, so it MUST be importable at module level. Import `EmailSvc` from `app.email.service` at the TOP of the file (module level). Only `UserRepository` needs a local import inside the function body (same as the existing `PreBookRepository` pattern).

**Avoid:**
- Never send email inside the service layer — routers only.
- Never call `email_svc.enqueue()` before the service method that can raise exceptions.
- Never use `async with` on `record_messages()` (sync context manager — per STATE.md Phase 09-02 decision).
  </action>
  <verify>
    <automated>python -c "from app.orders.router import checkout; import inspect; sig = inspect.signature(checkout); params = list(sig.parameters.keys()); assert 'background_tasks' in params, f'Missing background_tasks: {params}'; assert 'email_svc' in params, f'Missing email_svc: {params}'; print('checkout signature OK')" && python -c "from app.books.router import update_stock; import inspect; sig = inspect.signature(update_stock); params = list(sig.parameters.keys()); assert 'background_tasks' in params, f'Missing background_tasks: {params}'; assert 'email_svc' in params, f'Missing email_svc: {params}'; print('update_stock signature OK')"</automated>
  </verify>
  <done>
    - `checkout()` has `BackgroundTasks` and `EmailSvc` parameters; enqueues `order_confirmation.html` email after successful checkout with order_id, items, total_price context
    - `update_stock()` has `BackgroundTasks` and `EmailSvc` parameters; enqueues `restock_alert.html` email for each notified user using batch email lookup
    - Placeholder `_ = notified_user_ids` removed from `update_stock()`
    - No email is enqueued on error paths (structural guarantee: enqueue is after service call)
    - All existing tests still pass: `pytest tests/test_orders.py tests/test_prebooks.py tests/test_catalog.py -v`
  </done>
</task>

</tasks>

<verification>
1. Both templates exist and extend base.html:
   - `app/email/templates/order_confirmation.html` — renders order_id, items table, total_price
   - `app/email/templates/restock_alert.html` — renders book_title, book_id
2. `UserRepository.get_emails_by_ids()` exists and returns `dict[int, str]`
3. `checkout()` signature includes `BackgroundTasks` and `EmailSvc`; calls `email_svc.enqueue()` AFTER `service.checkout()`
4. `update_stock()` signature includes `BackgroundTasks` and `EmailSvc`; calls `email_svc.enqueue()` in a loop after `set_stock_and_notify()`
5. No placeholder `_ = notified_user_ids` remains in `app/books/router.py`
6. All pre-existing tests pass: `pytest tests/ -v`
</verification>

<success_criteria>
- `order_confirmation.html` and `restock_alert.html` templates render correctly via Jinja2
- Checkout router enqueues an email with order details after successful checkout
- Stock-update router enqueues one email per notified user when stock transitions 0-to-positive
- No email enqueued on any failure path
- All existing tests (orders, prebooks, catalog, email) still pass
</success_criteria>

<output>
After completion, create `.planning/phases/12-email-notifications-wiring/12-01-SUMMARY.md`
</output>
