---
phase: 12-email-notifications-wiring
plan: 02
type: execute
wave: 2
depends_on: [12-01]
files_modified:
  - tests/test_email_notifications.py
autonomous: true
requirements: [EMAL-02, EMAL-03]

must_haves:
  truths:
    - "Integration test proves checkout sends a confirmation email with order_id, items, and total"
    - "Integration test proves checkout failure (empty cart, insufficient stock, payment failure) sends no email"
    - "Integration test proves restock sends alert email to every user with a waiting pre-booking"
    - "Integration test proves no email sent when stock update is positive-to-positive (not 0-to-positive)"
    - "Integration test proves cancelled pre-bookings do not receive restock email"
    - "Integration test proves no email sent when book has no waiting pre-bookers"
  artifacts:
    - path: "tests/test_email_notifications.py"
      provides: "All Phase 12 email notification integration tests"
      min_lines: 200
  key_links:
    - from: "tests/test_email_notifications.py"
      to: "app/orders/router.py"
      via: "HTTP POST /orders/checkout with outbox capture"
      pattern: "POST.*checkout"
    - from: "tests/test_email_notifications.py"
      to: "app/books/router.py"
      via: "HTTP PATCH /books/{id}/stock with outbox capture"
      pattern: "PATCH.*stock"
    - from: "tests/test_email_notifications.py"
      to: "app/email/service.py"
      via: "get_email_service dependency override for outbox capture"
      pattern: "get_email_service"
---

<objective>
Write integration tests that prove order confirmation emails fire after successful checkout and restock alert emails fire when a book is restocked, both through the real HTTP stack with email outbox capture.

Purpose: Validates EMAL-02 and EMAL-03 end-to-end — proving the wiring from Plan 01 actually works through the full request lifecycle, including that emails are NOT sent on error paths.
Output: `tests/test_email_notifications.py` with 8+ tests covering all success and failure paths.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-email-notifications-wiring/12-RESEARCH.md
@.planning/phases/12-email-notifications-wiring/12-01-PLAN.md

@tests/conftest.py
@tests/test_email.py
@tests/test_orders.py
@tests/test_prebooks.py
@app/email/service.py
@app/orders/router.py
@app/books/router.py

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase + 12-01 plan. -->

From tests/conftest.py (existing fixtures):
```python
# Available fixtures from conftest.py:
@pytest_asyncio.fixture(scope="session")
async def test_engine(): ...  # Session-scoped async engine

@pytest_asyncio.fixture
async def db_session(test_engine): ...  # Per-test session with rollback

@pytest_asyncio.fixture
async def client(db_session): ...  # AsyncClient with get_db override

@pytest_asyncio.fixture
async def mail_config(): ...  # ConnectionConfig with SUPPRESS_SEND=1

@pytest_asyncio.fixture
async def email_service(mail_config): ...  # EmailService with suppressed sending
```

From app/email/service.py:
```python
@lru_cache
def get_email_service() -> EmailService: ...  # Cached singleton — MUST override in tests

EmailSvc = Annotated[EmailService, Depends(get_email_service)]
```

From tests/test_email.py (established patterns):
```python
# record_messages() is SYNC context manager (per STATE.md Phase 09-02):
with fm.record_messages() as outbox:
    response = await ac.post(...)
assert len(outbox) == 1
assert outbox[0]["subject"] == "..."
assert "recipient@test.com" in outbox[0]["To"]
```

From tests/test_orders.py (established patterns):
```python
# Payment mock for reliable checkout:
from unittest.mock import AsyncMock, patch
with patch("app.orders.service.MockPaymentService.charge", new=AsyncMock(return_value=True)):
    resp = await client.post("/orders/checkout", json={"force_payment_failure": False}, headers=headers)

# User/admin fixture pattern:
repo = UserRepository(db_session)
hashed = await hash_password("password")
user = await repo.create(email="unique_prefix@example.com", hashed_password=hashed)
await db_session.flush()
resp = await client.post("/auth/login", json={"email": "...", "password": "..."})
headers = {"Authorization": f"Bearer {resp.json()['access_token']}"}
```

From app/core/deps.py:
```python
async def get_db() -> AsyncGenerator[AsyncSession]: ...  # Commit on success, rollback on error
```

Email outbox item structure (from fastapi-mail record_messages):
```python
outbox[0]["subject"]  # str — email subject
outbox[0]["To"]       # str — recipient(s)
# HTML body accessible via outbox[0].get_payload() or outbox[0].get_content()
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create email notification integration test fixtures and order confirmation tests (EMAL-02)</name>
  <files>
    tests/test_email_notifications.py
  </files>
  <action>
Create `tests/test_email_notifications.py` with the module docstring, imports, fixtures, and EMAL-02 tests.

**Module docstring:**
```python
"""Integration tests for email notifications wiring (Phase 12).

Tests cover:
  - EMAL-02: Order confirmation email sent after successful checkout
  - EMAL-03: Restock alert email sent when pre-booked book is restocked

All tests use SUPPRESS_SEND=1 — no real SMTP connections are made.
Email capture uses fm.record_messages() (sync context manager) with
get_email_service dependency override to inject a controlled EmailService.

Uses unique email prefixes (enotif_admin@, enotif_user@, enotif_user2@)
to avoid cross-test DB contamination.
"""
```

**Imports needed:**
```python
from unittest.mock import AsyncMock, patch

import pytest_asyncio
from httpx import ASGITransport, AsyncClient
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.deps import get_db
from app.core.security import hash_password
from app.email.service import EmailService, get_email_service
from app.main import app
from app.users.repository import UserRepository
```

**Critical fixture: `email_client`**

This is the key fixture that makes email outbox capture work through the real HTTP stack. It overrides BOTH `get_db` AND `get_email_service` so the test controls the EmailService instance (and therefore has access to its `FastMail.record_messages()` outbox):

```python
@pytest_asyncio.fixture
async def email_client(db_session, mail_config):
    """AsyncClient with controlled EmailService for outbox capture.

    Overrides get_email_service to inject a test-controlled EmailService instance,
    allowing fm.record_messages() to capture emails sent by route handlers.
    Also overrides get_db to use the test session.
    """
    controlled_svc = EmailService(config=mail_config)

    async def override_get_db():
        yield db_session

    app.dependency_overrides[get_db] = override_get_db
    app.dependency_overrides[get_email_service] = lambda: controlled_svc

    transport = ASGITransport(app=app)
    async with AsyncClient(transport=transport, base_url="http://test") as ac:
        yield ac, controlled_svc.fm

    app.dependency_overrides.clear()
    get_email_service.cache_clear()
```

**User/admin fixtures** (use `enotif_` prefix for isolation):

```python
@pytest_asyncio.fixture
async def enotif_admin_headers(email_client, db_session):
    """Create admin user and return (headers, email_client_tuple)."""
    ac, fm = email_client
    repo = UserRepository(db_session)
    hashed = await hash_password("adminpass123")
    user = await repo.create(email="enotif_admin@example.com", hashed_password=hashed)
    await repo.set_role_admin(user.id)
    await db_session.flush()

    resp = await ac.post("/auth/login", json={"email": "enotif_admin@example.com", "password": "adminpass123"})
    assert resp.status_code == 200, f"Admin login failed: {resp.json()}"
    return {"Authorization": f"Bearer {resp.json()['access_token']}"}


@pytest_asyncio.fixture
async def enotif_user_headers(email_client, db_session):
    """Create regular user and return headers."""
    ac, fm = email_client
    repo = UserRepository(db_session)
    hashed = await hash_password("userpass123")
    await repo.create(email="enotif_user@example.com", hashed_password=hashed)
    await db_session.flush()

    resp = await ac.post("/auth/login", json={"email": "enotif_user@example.com", "password": "userpass123"})
    assert resp.status_code == 200, f"User login failed: {resp.json()}"
    return {"Authorization": f"Bearer {resp.json()['access_token']}"}


@pytest_asyncio.fixture
async def enotif_user2_headers(email_client, db_session):
    """Create second regular user for multi-user tests."""
    ac, fm = email_client
    repo = UserRepository(db_session)
    hashed = await hash_password("user2pass123")
    await repo.create(email="enotif_user2@example.com", hashed_password=hashed)
    await db_session.flush()

    resp = await ac.post("/auth/login", json={"email": "enotif_user2@example.com", "password": "user2pass123"})
    assert resp.status_code == 200, f"User2 login failed: {resp.json()}"
    return {"Authorization": f"Bearer {resp.json()['access_token']}"}
```

**Helper: `_create_stocked_book`**
```python
async def _create_stocked_book(ac, admin_headers, title="Email Test Book", price="14.99", stock=10):
    """Create a book with stock via admin endpoints. Returns book dict."""
    resp = await ac.post("/books", json={"title": title, "author": "Test Author", "price": price}, headers=admin_headers)
    assert resp.status_code == 201
    book = resp.json()
    stock_resp = await ac.patch(f"/books/{book['id']}/stock", json={"quantity": stock}, headers=admin_headers)
    assert stock_resp.status_code == 200
    return stock_resp.json()
```

**EMAL-02 Tests (4 tests):**

**Test 1: `test_checkout_sends_confirmation_email`**
- Create stocked book via admin, add to user's cart, checkout with payment mock
- Wrap the checkout call in `with fm.record_messages() as outbox:`
- Assert: `len(outbox) == 1`
- Assert: subject contains "confirmed" (case-insensitive)
- Assert: `"enotif_user@example.com" in outbox[0]["To"]`
- Assert: checkout returned 201

**Test 2: `test_confirmation_email_contains_order_details`**
- Same setup as test 1, but also inspect the email body content
- Get the HTML body from the outbox message (use `outbox[0].get_payload()` — if multipart, iterate parts)
- Assert the HTML contains: the order ID (from checkout response), the book title, the total price
- Note: `outbox[0].get_payload()` returns a list for multipart messages. The HTML part is typically at index 1, plain text at index 0. Use a helper to extract HTML body:
  ```python
  def _get_email_html(msg):
      """Extract HTML body from a multipart email message."""
      payload = msg.get_payload()
      if isinstance(payload, list):
          for part in payload:
              if part.get_content_type() == "text/html":
                  return part.get_payload(decode=True).decode()
      return msg.get_payload(decode=True).decode() if msg.get_content_type() == "text/html" else str(payload)
  ```
- Assert HTML contains order_id (as string), book title "Email Test Book", and total price

**Test 3: `test_no_email_on_checkout_failure_empty_cart`**
- Do NOT add anything to cart. Attempt checkout.
- Wrap in `with fm.record_messages() as outbox:`
- Assert: checkout returned 422 (ORDER_CART_EMPTY)
- Assert: `len(outbox) == 0`

**Test 4: `test_no_email_on_checkout_failure_insufficient_stock`**
- Create book with stock=1, add quantity=5 to cart, attempt checkout
- Wrap in `with fm.record_messages() as outbox:`
- Assert: checkout returned 409 (ORDER_INSUFFICIENT_STOCK)
- Assert: `len(outbox) == 0`

**IMPORTANT pattern for checkout tests:** Always patch `MockPaymentService.charge` to return `True` on success paths to avoid the 10% random payment failure:
```python
with patch("app.orders.service.MockPaymentService.charge", new=AsyncMock(return_value=True)):
    with fm.record_messages() as outbox:
        resp = await ac.post("/orders/checkout", json={"force_payment_failure": False}, headers=user_headers)
```

For failure tests (empty cart, insufficient stock), the payment mock is not strictly needed because the error is raised before payment, but it is harmless to include for consistency. The empty-cart test does NOT need payment mock since no items exist.
  </action>
  <verify>
    <automated>pytest tests/test_email_notifications.py -k "EMAL02 or checkout" -v -x</automated>
  </verify>
  <done>
    - `tests/test_email_notifications.py` exists with email_client fixture, user/admin fixtures, and 4 EMAL-02 tests
    - Test proves checkout sends exactly 1 email with correct recipient and subject
    - Test proves email body contains order_id, book title, and total_price
    - Test proves no email sent on empty cart checkout (422)
    - Test proves no email sent on insufficient stock checkout (409)
    - All 4 tests pass green
  </done>
</task>

<task type="auto">
  <name>Task 2: Add restock alert email tests (EMAL-03) and run full suite</name>
  <files>
    tests/test_email_notifications.py
  </files>
  <action>
Append EMAL-03 tests to the existing `tests/test_email_notifications.py` file created in Task 1.

**Helper: `_create_oos_book`**
```python
async def _create_oos_book(ac, admin_headers, title="OOS Email Book"):
    """Create an out-of-stock book (default stock_quantity=0). Returns book dict."""
    resp = await ac.post("/books", json={"title": title, "author": "Test Author", "price": "19.99"}, headers=admin_headers)
    assert resp.status_code == 201
    return resp.json()
```

**EMAL-03 Tests (4 tests):**

**Test 5: `test_restock_sends_alert_to_all_prebookers`**
- Create OOS book, user1 and user2 both pre-book it
- Admin restocks from 0 to 5
- Wrap the PATCH /books/{id}/stock call in `with fm.record_messages() as outbox:`
- Assert: `len(outbox) == 2` (one per pre-booker)
- Assert: both user emails appear across outbox messages (`enotif_user@example.com` and `enotif_user2@example.com`)
- Assert: subject contains book title and "back in stock"
- Note: The `fm.record_messages()` must wrap the stock PATCH call specifically — previous pre-book POST calls do not send emails

**Test 6: `test_no_restock_email_on_positive_to_positive`**
- Create OOS book, user pre-books, admin restocks 0->5 (triggers notification + emails)
- Clear outbox by exiting first `with fm.record_messages()` block
- Admin restocks 5->10 (positive-to-positive — should NOT send email)
- Wrap second PATCH in a new `with fm.record_messages() as outbox:`
- Assert: `len(outbox) == 0`

**Test 7: `test_no_restock_email_when_no_prebookers`**
- Create OOS book (no one pre-books it)
- Admin restocks from 0 to 5
- Wrap PATCH in `with fm.record_messages() as outbox:`
- Assert: `len(outbox) == 0` (no pre-bookers = no emails)

**Test 8: `test_cancelled_prebookers_not_emailed`**
- Create OOS book, user pre-books, then cancels the pre-booking
- Admin restocks from 0 to 5
- Wrap PATCH in `with fm.record_messages() as outbox:`
- Assert: `len(outbox) == 0` (cancelled pre-booking is not notified, so no email)

**IMPORTANT patterns for restock tests:**
- Pre-booking: `await ac.post("/prebooks", json={"book_id": book["id"]}, headers=user_headers)`
- Cancel: `await ac.delete(f"/prebooks/{prebook_id}", headers=user_headers)`
- Restock: `await ac.patch(f"/books/{book['id']}/stock", json={"quantity": 5}, headers=admin_headers)`
- The `fm.record_messages()` context manager MUST wrap ONLY the restock PATCH call — pre-booking calls do not send emails

**Test naming convention:** Use class-based organization:
- `class TestOrderConfirmationEmail:` for EMAL-02 tests
- `class TestRestockAlertEmail:` for EMAL-03 tests

After all 8 tests pass, run the full test suite to ensure no regressions: `pytest tests/ -v`
  </action>
  <verify>
    <automated>pytest tests/test_email_notifications.py -v -x && pytest tests/ -v</automated>
  </verify>
  <done>
    - 4 EMAL-03 tests added to `tests/test_email_notifications.py`
    - Test proves restock sends alert email to all waiting pre-bookers (2 users = 2 emails)
    - Test proves no email on positive-to-positive stock update
    - Test proves no email when book has no pre-bookers
    - Test proves cancelled pre-bookers do not receive email
    - All 8 tests in test_email_notifications.py pass green
    - Full test suite (`pytest tests/ -v`) passes with zero failures
  </done>
</task>

</tasks>

<verification>
1. `tests/test_email_notifications.py` exists with 8+ tests
2. `email_client` fixture overrides both `get_db` and `get_email_service` and clears overrides + cache on teardown
3. EMAL-02 tests: checkout confirmation email sent (1 email, correct recipient, correct content), no email on empty cart (0 emails), no email on insufficient stock (0 emails)
4. EMAL-03 tests: restock alert to all pre-bookers (N emails), no email on positive-to-positive, no email when no pre-bookers, cancelled pre-bookers excluded
5. Full test suite green: `pytest tests/ -v`
</verification>

<success_criteria>
- All 8 email notification tests pass
- Checkout confirmation email contains order_id, item details, and total_price
- Restock alert email correctly targets only users with waiting pre-bookings
- No email sent on any failure/error path
- Full test suite passes without regressions
</success_criteria>

<output>
After completion, create `.planning/phases/12-email-notifications-wiring/12-02-SUMMARY.md`
</output>
