---
phase: 10-admin-user-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/users/repository.py
  - app/users/service.py
  - app/core/deps.py
  - app/admin/__init__.py
  - app/admin/schemas.py
  - app/admin/service.py
  - app/admin/router.py
  - app/main.py
  - app/cart/router.py
  - app/orders/router.py
  - app/wishlist/router.py
autonomous: true
requirements:
  - ADMN-01
  - ADMN-02
  - ADMN-03
  - ADMN-04
  - ADMN-05

must_haves:
  truths:
    - "Admin can retrieve a paginated list of all users sorted by created_at DESC with total_count, page, per_page, total_pages metadata"
    - "Admin can filter user list by role and/or is_active query params (combinable, both optional)"
    - "Admin can deactivate a user: is_active set to false and all refresh tokens revoked atomically"
    - "Admin can reactivate a previously deactivated user: is_active set to true"
    - "Deactivating any admin account (self or others) is rejected with 403 and message 'Cannot deactivate admin accounts'"
    - "Deactivated user is immediately locked out on ALL protected routes (cart, orders, wishlist, admin): access token rejected via DB is_active check, login blocked, refresh already blocked"
    - "Deactivation and reactivation are idempotent: return 200 with user object when already in desired state"
  artifacts:
    - path: "app/admin/router.py"
      provides: "GET /admin/users, PATCH /admin/users/{id}/deactivate, PATCH /admin/users/{id}/reactivate"
      min_lines: 40
    - path: "app/admin/schemas.py"
      provides: "AdminUserResponse and UserListResponse Pydantic models"
      exports: ["AdminUserResponse", "UserListResponse"]
    - path: "app/admin/service.py"
      provides: "AdminUserService with list_users, deactivate_user, reactivate_user"
      exports: ["AdminUserService"]
    - path: "app/users/repository.py"
      provides: "list_paginated() on UserRepository, revoke_all_for_user() on RefreshTokenRepository"
      contains: "revoke_all_for_user"
    - path: "app/core/deps.py"
      provides: "get_active_user dependency and ActiveUser type alias"
      exports: ["ActiveUser"]
  key_links:
    - from: "app/admin/router.py"
      to: "app/admin/service.py"
      via: "AdminUserService instantiated in router with repos from db session"
      pattern: "AdminUserService"
    - from: "app/admin/service.py"
      to: "app/users/repository.py"
      via: "UserRepository.list_paginated() and RefreshTokenRepository.revoke_all_for_user()"
      pattern: "list_paginated|revoke_all_for_user"
    - from: "app/core/deps.py"
      to: "app/users/repository.py"
      via: "get_active_user calls UserRepository.get_by_id() to check is_active"
      pattern: "UserRepository.*get_by_id"
    - from: "app/users/service.py"
      to: "User.is_active"
      via: "login() checks is_active after password verification"
      pattern: "is_active.*403"
    - from: "app/main.py"
      to: "app/admin/router.py"
      via: "include_router registration"
      pattern: "admin_users_router"
---

<objective>
Implement the complete admin user management feature: repository extensions for paginated user queries and bulk token revocation, is_active enforcement in the auth dependency chain and login flow, admin module with schemas/service/router, and router registration.

Purpose: Give admins the ability to view, filter, deactivate, and reactivate user accounts with immediate lockout enforcement for deactivated users.
Output: Working admin user management endpoints at /admin/users with immediate is_active lockout on ALL protected routes (admin, cart, orders, wishlist).
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-admin-user-management/10-CONTEXT.md
@.planning/phases/10-admin-user-management/10-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From app/users/models.py:
```python
class UserRole(enum.StrEnum):
    USER = "user"
    ADMIN = "admin"

class User(Base):
    __tablename__ = "users"
    id: Mapped[int] = mapped_column(primary_key=True)
    email: Mapped[str] = mapped_column(String(255), unique=True, index=True, nullable=False)
    hashed_password: Mapped[str | None] = mapped_column(String(255), nullable=True)
    role: Mapped[UserRole] = mapped_column(SAEnum(UserRole, name="userrole"), default=UserRole.USER, nullable=False)
    is_active: Mapped[bool] = mapped_column(Boolean, default=True, nullable=False)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now(), nullable=False)

class RefreshToken(Base):
    __tablename__ = "refresh_tokens"
    id: Mapped[int] = mapped_column(primary_key=True)
    token: Mapped[str] = mapped_column(String(512), unique=True, index=True, nullable=False)
    token_family: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), default=uuid.uuid4, nullable=False, index=True)
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"), nullable=False)
    expires_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False)
    revoked_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=True), nullable=True)
```

From app/core/deps.py:
```python
DbSession = Annotated[AsyncSession, Depends(get_db)]

def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]) -> dict:
    """Decode the JWT access token. Returns payload dict with sub and role."""
    return decode_access_token(token)

def require_admin(current_user: Annotated[dict, Depends(get_current_user)]) -> dict:
    """Require admin role. Raises AppError(403) if role is not admin."""
    ...

CurrentUser = Annotated[dict, Depends(get_current_user)]
AdminUser = Annotated[dict, Depends(require_admin)]
```

From app/users/repository.py:
```python
class UserRepository:
    def __init__(self, session: AsyncSession) -> None: ...
    async def get_by_email(self, email: str) -> User | None: ...
    async def get_by_id(self, user_id: int) -> User | None: ...
    async def create(self, email: str, hashed_password: str) -> User: ...
    async def set_role_admin(self, user_id: int) -> None: ...

class RefreshTokenRepository:
    def __init__(self, session: AsyncSession) -> None: ...
    async def revoke_family(self, token_family: uuid.UUID) -> None: ...
```

From app/users/service.py:
```python
class AuthService:
    async def login(self, email: str, password: str) -> tuple[str, str]: ...
    async def refresh(self, refresh_token: str) -> tuple[str, str]: ...
```

From app/books/repository.py (pagination pattern to follow):
```python
# Count total before pagination
count_stmt = select(func.count()).select_from(stmt.subquery())
total = await self.session.scalar(count_stmt)
# Apply pagination
offset = (page - 1) * size
stmt = stmt.limit(size).offset(offset)
result = await self.session.execute(stmt)
books = list(result.scalars().all())
return books, total or 0
```

From app/main.py (router registration pattern):
```python
from app.orders.router import admin_router as orders_admin_router
application.include_router(orders_admin_router)
```

From app/core/exceptions.py:
```python
class AppError(Exception):
    def __init__(self, status_code: int, detail: str, code: str, field: str | None = None): ...
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend repositories and enforce is_active in auth chain</name>
  <files>
    app/users/repository.py
    app/users/service.py
    app/core/deps.py
  </files>
  <action>
**1. Add `list_paginated()` to UserRepository** in `app/users/repository.py`:

```python
async def list_paginated(
    self,
    *,
    page: int = 1,
    per_page: int = 20,
    role: UserRole | None = None,
    is_active: bool | None = None,
) -> tuple[list[User], int]:
```

Follow the exact BookRepository.search() pattern:
- Base query: `select(User).order_by(User.created_at.desc())` (newest first per CONTEXT.md)
- If `role is not None`: `.where(User.role == role)` (pass UserRole enum value, NOT string)
- If `is_active is not None`: `.where(User.is_active == is_active)`
- Count: `select(func.count()).select_from(stmt.subquery())` — reuses filter conditions
- Pagination: `.limit(per_page).offset((page - 1) * per_page)`
- Return `(users, total or 0)`

Add necessary import: `from sqlalchemy import func` (already imported in some modules; verify).

**2. Add `revoke_all_for_user()` to RefreshTokenRepository** in `app/users/repository.py`:

```python
async def revoke_all_for_user(self, user_id: int) -> int:
```

Follow the exact `revoke_family()` pattern:
- `update(RefreshToken).where(RefreshToken.user_id == user_id, RefreshToken.revoked_at.is_(None)).values(revoked_at=datetime.now(UTC))`
- Return the rowcount so callers know how many tokens were revoked (useful for logging/testing)

**3. Add `is_active` check to `AuthService.login()`** in `app/users/service.py`:

Add AFTER password verification succeeds (line 82, after the `if not await verify_password(...)` block), BEFORE token creation:

```python
if not user.is_active:
    raise AppError(
        status_code=403,
        detail="Account deactivated. Contact support.",
        code="AUTH_ACCOUNT_DEACTIVATED",
    )
```

IMPORTANT: This check MUST come AFTER password verification to prevent account status enumeration. A deactivated user with wrong password should still get AUTH_INVALID_CREDENTIALS, not AUTH_ACCOUNT_DEACTIVATED.

**4. Add `get_active_user` dependency and `ActiveUser` type alias** in `app/core/deps.py`:

```python
async def get_active_user(
    db: DbSession,
    current_user: Annotated[dict, Depends(get_current_user)],
) -> dict:
    """Verify user is still active via DB lookup. Raises 403 if deactivated.

    Called on every protected request. Adds one DB round-trip per request.
    This is acceptable per CONTEXT.md decision for immediate lockout.
    """
    from app.users.repository import UserRepository  # local import to avoid circular

    user_id = int(current_user["sub"])
    repo = UserRepository(db)
    user = await repo.get_by_id(user_id)
    if user is None or not user.is_active:
        raise AppError(
            status_code=403,
            detail="Account deactivated. Contact support.",
            code="AUTH_ACCOUNT_DEACTIVATED",
        )
    return current_user

ActiveUser = Annotated[dict, Depends(get_active_user)]
```

Note: Use local import for `UserRepository` inside the function to avoid circular import (deps.py is imported by many modules).

**5. Update `require_admin` to chain through `get_active_user`** in `app/core/deps.py`:

Change `require_admin` signature from:
```python
def require_admin(current_user: Annotated[dict, Depends(get_current_user)]) -> dict:
```
to:
```python
def require_admin(current_user: Annotated[dict, Depends(get_active_user)]) -> dict:
```

This ensures admin endpoints also enforce is_active check. The AdminUser type alias remains unchanged — it now inherits the is_active check via the dependency chain: `AdminUser -> require_admin -> get_active_user -> get_current_user`.

**Scope note on ActiveUser for existing routes:** Task 1 creates the `ActiveUser` dependency and wires it into the admin chain. Task 3 (below) migrates cart/orders/wishlist routers from `CurrentUser` to `ActiveUser` so that deactivated users are locked out of ALL protected routes, per the CONTEXT.md locked decision "check is_active on every protected request."
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && python -c "from app.users.repository import UserRepository, RefreshTokenRepository; from app.core.deps import ActiveUser, AdminUser, get_active_user; from app.users.service import AuthService; print('All imports OK')"</automated>
  </verify>
  <done>
    - UserRepository has list_paginated() with optional role/is_active filters and offset pagination
    - RefreshTokenRepository has revoke_all_for_user() using bulk UPDATE statement
    - AuthService.login() rejects deactivated users with 403 after password verification
    - get_active_user dependency in deps.py checks is_active via DB lookup
    - ActiveUser type alias exported from deps.py
    - require_admin chains through get_active_user (AdminUser inherits is_active check)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create admin module and register router</name>
  <files>
    app/admin/__init__.py
    app/admin/schemas.py
    app/admin/service.py
    app/admin/router.py
    app/main.py
  </files>
  <action>
**1. Create `app/admin/__init__.py`** — empty file (standard Python package marker).

**2. Create `app/admin/schemas.py`** with Pydantic v2 response schemas:

```python
from datetime import datetime
from pydantic import BaseModel

class AdminUserResponse(BaseModel):
    """Admin view of a user account."""
    id: int
    email: str
    full_name: str | None = None  # User model has no full_name column yet; always None until migration adds it
    role: str
    is_active: bool
    created_at: datetime

    model_config = {"from_attributes": True}

class UserListResponse(BaseModel):
    """Paginated envelope for admin user list."""
    items: list[AdminUserResponse]
    total_count: int
    page: int
    per_page: int
    total_pages: int
```

Per CONTEXT.md decision: includes id, email, full_name, role, is_active, created_at. full_name is `str | None = None` — the User model has no full_name column yet, so `model_validate()` will produce None for all users. This honors the locked response shape without requiring a schema migration in Phase 10.

**3. Create `app/admin/service.py`** with AdminUserService:

```python
from app.core.exceptions import AppError
from app.users.models import User, UserRole
from app.users.repository import RefreshTokenRepository, UserRepository

class AdminUserService:
    def __init__(self, user_repo: UserRepository, rt_repo: RefreshTokenRepository) -> None:
        self.user_repo = user_repo
        self.rt_repo = rt_repo

    async def list_users(
        self,
        *,
        page: int = 1,
        per_page: int = 20,
        role: UserRole | None = None,
        is_active: bool | None = None,
    ) -> tuple[list[User], int]:
        return await self.user_repo.list_paginated(
            page=page, per_page=per_page, role=role, is_active=is_active,
        )

    async def deactivate_user(self, target_user_id: int) -> User:
        user = await self._get_user_or_404(target_user_id)
        if user.role == UserRole.ADMIN:
            raise AppError(
                status_code=403,
                detail="Cannot deactivate admin accounts",
                code="ADMN_CANNOT_DEACTIVATE_ADMIN",
            )
        # Idempotent: skip if already deactivated
        if user.is_active:
            user.is_active = False
            await self.user_repo.session.flush()
            await self.rt_repo.revoke_all_for_user(user.id)
        return user

    async def reactivate_user(self, target_user_id: int) -> User:
        user = await self._get_user_or_404(target_user_id)
        # Idempotent: skip if already active
        if not user.is_active:
            user.is_active = True
            await self.user_repo.session.flush()
        return user

    async def _get_user_or_404(self, user_id: int) -> User:
        user = await self.user_repo.get_by_id(user_id)
        if user is None:
            raise AppError(
                status_code=404,
                detail="User not found",
                code="USER_NOT_FOUND",
            )
        return user
```

Key decisions per CONTEXT.md:
- Blanket admin protection: `user.role == UserRole.ADMIN` check rejects deactivation of ANY admin (self or other), 403 "Cannot deactivate admin accounts"
- Idempotent: deactivating already-deactivated user returns 200, reactivating already-active user returns 200
- Uses flush() not commit() (session lifecycle managed by get_db dependency)
- Deactivation atomically sets is_active=False AND revokes all refresh tokens

**4. Create `app/admin/router.py`**:

```python
import math
from fastapi import APIRouter, Query
from app.admin.schemas import AdminUserResponse, UserListResponse
from app.admin.service import AdminUserService
from app.core.deps import AdminUser, DbSession
from app.users.models import UserRole
from app.users.repository import RefreshTokenRepository, UserRepository

router = APIRouter(prefix="/admin/users", tags=["admin"])

def _make_service(db) -> AdminUserService:
    return AdminUserService(
        user_repo=UserRepository(db),
        rt_repo=RefreshTokenRepository(db),
    )

@router.get("", response_model=UserListResponse)
async def list_users(
    db: DbSession,
    _admin: AdminUser,
    page: int = Query(1, ge=1),
    per_page: int = Query(20, ge=1, le=100),
    role: UserRole | None = Query(None),
    is_active: bool | None = Query(None),
) -> UserListResponse:
    svc = _make_service(db)
    users, total = await svc.list_users(
        page=page, per_page=per_page, role=role, is_active=is_active,
    )
    return UserListResponse(
        items=[AdminUserResponse.model_validate(u) for u in users],
        total_count=total,
        page=page,
        per_page=per_page,
        total_pages=math.ceil(total / per_page) if total > 0 else 0,
    )

@router.patch("/{user_id}/deactivate", response_model=AdminUserResponse)
async def deactivate_user(
    user_id: int,
    db: DbSession,
    _admin: AdminUser,
) -> AdminUserResponse:
    svc = _make_service(db)
    user = await svc.deactivate_user(user_id)
    return AdminUserResponse.model_validate(user)

@router.patch("/{user_id}/reactivate", response_model=AdminUserResponse)
async def reactivate_user(
    user_id: int,
    db: DbSession,
    _admin: AdminUser,
) -> AdminUserResponse:
    svc = _make_service(db)
    user = await svc.reactivate_user(user_id)
    return AdminUserResponse.model_validate(user)
```

Key details:
- Uses `UserRole | None` as Query type — FastAPI/Pydantic handles enum validation automatically, returns 422 for invalid role values
- `_make_service(db)` pattern matches existing _make_service pattern in orders/books routers
- `_admin: AdminUser` parameter enforces admin-only access (chains through get_active_user per Task 1)
- `total_pages = math.ceil(total / per_page)` for correct page count calculation
- All endpoints return AdminUserResponse (single user) or UserListResponse (paginated list)

**5. Register admin router in `app/main.py`**:

Add import:
```python
from app.admin.router import router as admin_users_router
```

Add router registration after `orders_admin_router`:
```python
application.include_router(admin_users_router)
```
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && python -c "from app.admin.router import router; from app.admin.schemas import AdminUserResponse, UserListResponse; from app.admin.service import AdminUserService; print(f'Routes: {[r.path for r in router.routes]}'); print('All admin module imports OK')"</automated>
  </verify>
  <done>
    - app/admin/ package exists with __init__.py, schemas.py, service.py, router.py
    - AdminUserResponse schema has id, email, full_name (nullable), role, is_active, created_at
    - UserListResponse has items, total_count, page, per_page, total_pages
    - AdminUserService has list_users, deactivate_user, reactivate_user with correct business logic
    - Router exposes GET /admin/users, PATCH /admin/users/{id}/deactivate, PATCH /admin/users/{id}/reactivate
    - Admin router registered in main.py
    - All three endpoints require AdminUser dependency (admin-only, is_active enforced)
  </done>
</task>

<task type="auto">
  <name>Task 3: Migrate cart, orders, and wishlist routers from CurrentUser to ActiveUser</name>
  <files>
    app/cart/router.py
    app/orders/router.py
    app/wishlist/router.py
  </files>
  <action>
Per CONTEXT.md locked decision: "Immediate lockout: check is_active on every protected request, reject deactivated users instantly." This requires ALL user-facing protected routes to use ActiveUser instead of CurrentUser.

**1. Update `app/cart/router.py`:**

Change the import:
```python
# Before:
from app.core.deps import CurrentUser, DbSession
# After:
from app.core.deps import ActiveUser, DbSession
```

Replace all `CurrentUser` type annotations with `ActiveUser` in all four endpoint functions:
- `get_cart(db: DbSession, current_user: ActiveUser)`
- `add_cart_item(body: CartItemAdd, db: DbSession, current_user: ActiveUser)`
- `update_cart_item(item_id: int, body: CartItemUpdate, db: DbSession, current_user: ActiveUser)`
- `remove_cart_item(item_id: int, db: DbSession, current_user: ActiveUser)`

Keep parameter names as `current_user` (not `active_user`) — the variable name is conventional, the type annotation drives the dependency injection.

**2. Update `app/orders/router.py`:**

Change the import:
```python
# Before:
from app.core.deps import AdminUser, CurrentUser, DbSession
# After:
from app.core.deps import AdminUser, ActiveUser, DbSession
```

Replace all `CurrentUser` type annotations with `ActiveUser` in the three user-facing endpoints:
- `checkout(body: CheckoutRequest, db: DbSession, current_user: ActiveUser)`
- `list_orders(db: DbSession, current_user: ActiveUser)`
- `get_order(order_id: int, db: DbSession, current_user: ActiveUser)`

The `list_all_orders` admin endpoint uses `AdminUser` which already chains through `get_active_user` — no change needed.

**3. Update `app/wishlist/router.py`:**

Change the import:
```python
# Before:
from app.core.deps import CurrentUser, DbSession
# After:
from app.core.deps import ActiveUser, DbSession
```

Replace all `CurrentUser` type annotations with `ActiveUser` in all three endpoint functions:
- `add_to_wishlist(body: WishlistAdd, db: DbSession, current_user: ActiveUser)`
- `get_wishlist(db: DbSession, current_user: ActiveUser)`
- `remove_from_wishlist(book_id: int, db: DbSession, current_user: ActiveUser)`

**IMPORTANT:** The `ActiveUser` dependency returns the same `dict` payload as `CurrentUser` (it calls `get_current_user` internally, then checks `is_active`). So `current_user["sub"]` continues to work in all endpoint bodies — no logic changes needed, only type annotations and imports.
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && python -c "
from app.cart.router import router as cart_r
from app.orders.router import router as orders_r
from app.wishlist.router import router as wishlist_r
print('All router imports OK')
" && ruff check app/cart/router.py app/orders/router.py app/wishlist/router.py</automated>
  </verify>
  <done>
    - app/cart/router.py imports ActiveUser (not CurrentUser) and all 4 endpoints use ActiveUser type
    - app/orders/router.py imports ActiveUser (not CurrentUser) and all 3 user-facing endpoints use ActiveUser type
    - app/wishlist/router.py imports ActiveUser (not CurrentUser) and all 3 endpoints use ActiveUser type
    - Deactivated users are now rejected with 403 on ALL protected routes (cart, orders, wishlist, admin)
    - No functional logic changes — only dependency type annotations changed
  </done>
</task>

</tasks>

<verification>
1. Import verification: `python -c "from app.admin.router import router; from app.core.deps import ActiveUser; print('OK')"`
2. Route listing: `python -c "from app.main import app; routes = [r.path for r in app.routes if '/admin/users' in getattr(r, 'path', '')]; print(routes)"`
3. ActiveUser enforcement: `cd D:/Python/claude-test && python -c "import ast, sys; [sys.exit(1) for f in ['app/cart/router.py','app/orders/router.py','app/wishlist/router.py'] if 'CurrentUser' in open(f).read()]; print('No CurrentUser references remain')"`
4. Lint: `cd D:/Python/claude-test && ruff check app/admin/ app/core/deps.py app/users/repository.py app/users/service.py app/cart/router.py app/orders/router.py app/wishlist/router.py`
5. Format: `cd D:/Python/claude-test && ruff format --check app/admin/ app/core/deps.py app/users/repository.py app/users/service.py app/cart/router.py app/orders/router.py app/wishlist/router.py`
</verification>

<success_criteria>
- GET /admin/users returns paginated user list with page metadata
- GET /admin/users?role=user&is_active=false returns filtered results
- PATCH /admin/users/{id}/deactivate sets is_active=false and revokes all refresh tokens
- PATCH /admin/users/{id}/reactivate sets is_active=true
- Deactivating an admin returns 403 "Cannot deactivate admin accounts"
- Deactivated user cannot log in (403 from login)
- Deactivated user's access token is rejected on ALL protected endpoints including cart, orders, and wishlist (403 from ActiveUser dep)
- All code passes ruff check and ruff format
</success_criteria>

<output>
After completion, create `.planning/phases/10-admin-user-management/10-01-SUMMARY.md`
</output>
