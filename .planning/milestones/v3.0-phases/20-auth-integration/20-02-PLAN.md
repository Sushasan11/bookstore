---
phase: 20-auth-integration
plan: 02
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - frontend/src/app/(auth)/layout.tsx
  - frontend/src/app/(auth)/login/page.tsx
  - frontend/src/app/(auth)/register/page.tsx
  - frontend/src/components/auth/LoginForm.tsx
  - frontend/src/components/auth/RegisterForm.tsx
  - frontend/src/components/auth/GoogleSignInButton.tsx
  - frontend/src/components/layout/Header.tsx
  - frontend/src/components/layout/UserMenu.tsx
  - frontend/src/proxy.ts
  - frontend/src/components/providers.tsx
  - frontend/src/components/ui/input.tsx
  - frontend/src/components/ui/card.tsx
  - frontend/src/components/ui/label.tsx
autonomous: true
requirements: [AUTH-05, AUTH-06, AUTH-08]

must_haves:
  truths:
    - "User can log out and is redirected to the home page"
    - "Unauthenticated user visiting /account, /orders, /checkout, /wishlist, or /prebook is redirected to /login with callbackUrl"
    - "Deactivated user's next API call triggers automatic sign-out via 403 interceptor"
    - "Login page shows email/password form and Google sign-in button"
    - "Register page shows email/password form with validation"
    - "Header shows Sign In link when logged out and user info + Sign Out button when logged in"
  artifacts:
    - path: "frontend/src/proxy.ts"
      provides: "Route protection middleware for Next.js 16"
      exports: ["proxy", "config"]
    - path: "frontend/src/app/(auth)/login/page.tsx"
      provides: "Login page with LoginForm and GoogleSignInButton"
    - path: "frontend/src/app/(auth)/register/page.tsx"
      provides: "Register page with RegisterForm"
    - path: "frontend/src/components/auth/LoginForm.tsx"
      provides: "Client component for email/password sign-in"
    - path: "frontend/src/components/auth/RegisterForm.tsx"
      provides: "Client component for email/password registration"
    - path: "frontend/src/components/auth/GoogleSignInButton.tsx"
      provides: "Client component calling signIn('google')"
    - path: "frontend/src/components/layout/Header.tsx"
      provides: "Updated header with auth state (sign in / sign out)"
  key_links:
    - from: "frontend/src/proxy.ts"
      to: "frontend/src/auth.ts"
      via: "auth() function for session check"
      pattern: "import.*auth.*from.*@/auth"
    - from: "frontend/src/components/auth/LoginForm.tsx"
      to: "frontend/src/auth.ts"
      via: "signIn('credentials', { email, password })"
      pattern: "signIn.*credentials"
    - from: "frontend/src/components/providers.tsx"
      to: "signOut from next-auth/react"
      via: "QueryCache/MutationCache onError 403 interceptor"
      pattern: "signOut.*callbackUrl"
---

<objective>
Build the auth UI (login/register pages, Google button), route protection via proxy.ts, logout functionality, Header auth state display, and global 403 interceptor for deactivated users.

Purpose: After this plan, users have a complete auth UX — they can see login/register pages, sign in with email or Google, see their auth state in the header, log out, and be protected from accessing private routes without authentication. Deactivated users are automatically signed out.

Output: Auth pages in (auth) route group, proxy.ts for route protection, updated Header with auth controls, and 403 global interceptor.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-auth-integration/20-RESEARCH.md
@.planning/phases/20-auth-integration/20-01-SUMMARY.md

<interfaces>
<!-- Key types and contracts from Plan 20-01. -->

From frontend/src/auth.ts (created in 20-01):
```typescript
// Exports:
export const { handlers, auth, signIn, signOut } = NextAuth({...})

// Session type (module augmentation):
interface Session {
  accessToken: string
  error?: string
  user: { id: string; role: string } & DefaultSession["user"]
}

// JWT type:
interface JWT {
  accessToken: string
  refreshToken: string
  accessTokenExpiry: number
  userId: string
  role: string
  error?: string
}
```

From frontend/src/lib/api.ts:
```typescript
export class ApiError extends Error {
  constructor(message: string, public status: number, public detail?: string)
}
```

From frontend/src/components/providers.tsx (modified in 20-01):
```typescript
// Already has SessionProvider wrapping QueryClientProvider
// QueryClient created with useState factory pattern
```

From frontend/src/components/layout/Header.tsx:
```typescript
export function Header() {
  // Current: static header with Bookstore logo, Books nav link, cart icon, theme toggle
  // MobileNav (hamburger), ThemeToggle already present
  // NO auth state currently displayed
}
```

From frontend/src/app/layout.tsx:
```typescript
// Root layout with Providers > Header > main > Footer
// Auth pages use (auth) route group to skip Header/Footer
```

shadcn/ui components already installed: Button, Sheet, Sonner
shadcn/ui components needed: Input, Card, Label (install via `npx shadcn add input card label`)
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth UI pages with login, register forms, and Google sign-in button</name>
  <files>
    frontend/src/app/(auth)/layout.tsx
    frontend/src/app/(auth)/login/page.tsx
    frontend/src/app/(auth)/register/page.tsx
    frontend/src/components/auth/LoginForm.tsx
    frontend/src/components/auth/RegisterForm.tsx
    frontend/src/components/auth/GoogleSignInButton.tsx
    frontend/src/components/ui/input.tsx
    frontend/src/components/ui/card.tsx
    frontend/src/components/ui/label.tsx
  </files>
  <action>
**Step 0: Install shadcn/ui components needed for forms**

```bash
cd frontend && npx shadcn@latest add input card label
```

This adds Input, Card, and Label components to `src/components/ui/`.

**Step 1: Create (auth) route group layout — `frontend/src/app/(auth)/layout.tsx`**

This layout is for auth pages ONLY (login, register). It does NOT include the main site Header/Footer — just a centered card layout. This is a Server Component (no 'use client').

```tsx
export default function AuthLayout({ children }: { children: React.ReactNode }) {
  return (
    <div className="flex min-h-screen items-center justify-center bg-background px-4">
      <div className="w-full max-w-md">
        {children}
      </div>
    </div>
  )
}
```

The `(auth)` route group does NOT affect the URL — `/login` and `/register` are the actual paths. This layout overrides the root layout's Header/Footer for these pages only. The root layout.tsx Providers still wrap everything (including auth pages), so SessionProvider and ThemeProvider are available.

**Step 2: Create LoginForm client component — `frontend/src/components/auth/LoginForm.tsx`**

Mark as `'use client'`. This is a form component with:
- Email input (type="email", required)
- Password input (type="password", required, with show/hide toggle using an eye icon from lucide-react)
- "Sign in" submit button
- Error message display (top-of-form banner style using destructive variant styling)
- Loading state on the submit button (disabled + spinner text)

On submit: call `signIn("credentials", { email, password, redirect: false })` from `next-auth/react`. Check the result:
- If `result?.error`: display "Invalid email or password" error message (security-conscious — do not reveal whether email exists)
- If `result?.ok`: use `router.push(callbackUrl || "/")` to redirect. Get `callbackUrl` from `useSearchParams()`.

Import `signIn` from `next-auth/react` (client-side version), NOT from `@/auth` (server-side).

Use shadcn/ui components: Card, CardContent, CardDescription, CardHeader, CardTitle, Input, Label, Button.

**Step 3: Create RegisterForm client component — `frontend/src/components/auth/RegisterForm.tsx`**

Mark as `'use client'`. Similar to LoginForm but:
- Email input
- Password input (min 8 chars, with show/hide toggle)
- Confirm password input (must match — client-side validation only)
- "Create account" submit button
- Error display (same banner style as LoginForm)

On submit:
1. Validate confirm password matches password (client-side).
2. Call `fetch(\`${process.env.NEXT_PUBLIC_API_URL ?? "http://localhost:8000"}/auth/register\`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ email, password }) })` directly (registration is not a NextAuth flow).
3. If response is not ok: parse error body, display `body.detail` (e.g., "Email already registered").
4. If ok: call `signIn("credentials", { email, password, redirect: false })` to establish the NextAuth session, then `router.push("/")`.

Use the same shadcn/ui components as LoginForm.

**Step 4: Create GoogleSignInButton — `frontend/src/components/auth/GoogleSignInButton.tsx`**

Mark as `'use client'`. A simple button that calls `signIn("google")` from `next-auth/react`.

Style: Full-width button with a Google icon (use an inline SVG for the Google "G" logo or text "Continue with Google"). Use `variant="outline"` from shadcn Button. Add `callbackUrl` as a parameter: `signIn("google", { callbackUrl: callbackUrl || "/" })`.

**Step 5: Create login page — `frontend/src/app/(auth)/login/page.tsx`**

Server Component. Renders:
```tsx
import { LoginForm } from "@/components/auth/LoginForm"
import { GoogleSignInButton } from "@/components/auth/GoogleSignInButton"
import Link from "next/link"
```

Layout:
- Card with header: "Welcome back" title, "Sign in to your account" description
- LoginForm
- Horizontal divider with "or" text (the `<div className="relative my-4"><div className="absolute inset-0 flex items-center"><span className="w-full border-t" /></div><div className="relative flex justify-center text-xs uppercase"><span className="bg-card px-2 text-muted-foreground">or</span></div></div>` pattern)
- GoogleSignInButton
- Footer text: "Don't have an account? Sign up" with Link to /register

Export metadata: `{ title: "Sign In" }`

**Step 6: Create register page — `frontend/src/app/(auth)/register/page.tsx`**

Server Component. Renders:
- Card with header: "Create an account" title, "Enter your details to get started" description
- RegisterForm
- Divider with "or"
- GoogleSignInButton
- Footer text: "Already have an account? Sign in" with Link to /login

Export metadata: `{ title: "Create Account" }`

**Design decisions (Claude's discretion per CONTEXT.md):**
- Separate /login and /register pages (cleaner UX than toggle)
- Validation errors displayed as top-of-form banner (simple, consistent)
- Security-conscious error messages ("Invalid email or password" — no email enumeration)
- Password field with show/hide toggle (better UX than confirm field for login)
- Register has confirm password field (standard for registration)
- Centered card layout for auth pages (professional, focused)
- Google button below email form with "or" divider (standard pattern)
- Dark mode works automatically via shadcn tokens (bg-background, text-foreground)
  </action>
  <verify>
    <automated>cd D:/Python/claude-test/frontend && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>
- (auth) route group with centered card layout (no site header/footer)
- /login page with LoginForm + GoogleSignInButton + link to /register
- /register page with RegisterForm + GoogleSignInButton + link to /login
- LoginForm calls signIn("credentials") and handles errors
- RegisterForm calls POST /auth/register then signIn("credentials")
- GoogleSignInButton calls signIn("google")
- All components use shadcn/ui tokens for dark mode compatibility
- TypeScript compiles with zero errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add proxy.ts route protection, Header auth state, logout, and 403 interceptor</name>
  <files>
    frontend/src/proxy.ts
    frontend/src/components/layout/Header.tsx
    frontend/src/components/layout/UserMenu.tsx
    frontend/src/components/providers.tsx
  </files>
  <action>
**Step 1: Create frontend/src/proxy.ts — route protection for Next.js 16**

This file replaces `middleware.ts` (deprecated in Next.js 16). It uses the `auth()` function from `@/auth` to check session state and redirect unauthenticated users away from protected routes.

```typescript
import { auth } from "@/auth"
import { NextResponse } from "next/server"

export const proxy = auth((req) => {
  const isLoggedIn = !!req.auth
  const { pathname } = req.nextUrl

  // Routes that require authentication
  const protectedPrefixes = ["/account", "/orders", "/checkout", "/wishlist", "/prebook"]
  const isProtected = protectedPrefixes.some(p => pathname.startsWith(p))

  if (isProtected && !isLoggedIn) {
    const url = new URL("/login", req.nextUrl.origin)
    url.searchParams.set("callbackUrl", pathname)
    return NextResponse.redirect(url)
  }

  // Redirect authenticated users away from auth pages (optional but good UX)
  const authPaths = ["/login", "/register"]
  const isAuthPage = authPaths.some(p => pathname === p)
  if (isAuthPage && isLoggedIn) {
    return NextResponse.redirect(new URL("/", req.nextUrl.origin))
  }

  return NextResponse.next()
})

export const config = {
  matcher: ["/((?!api|_next/static|_next/image|favicon.ico).*)"],
}
```

**CRITICAL:** The file MUST be named `proxy.ts` (NOT `middleware.ts`) and placed in `frontend/src/proxy.ts`. Next.js 16 uses `proxy.ts` — the `middleware.ts` name is deprecated. The `auth()` wrapper makes `req.auth` available (contains the session or null).

**CRITICAL:** The exported function MUST be a **named export called `proxy`** (i.e., `export const proxy = auth(...)`) — NOT `export default`. Next.js 16 requires the named `proxy` export (see RESEARCH.md Pitfall 7). Using `export default` causes route protection to silently fail.

**Step 2: Update frontend/src/components/layout/Header.tsx**

Convert Header to show auth-aware controls. The Header needs to be a **server component** that uses `auth()` from `@/auth` to get session state, then renders different UI based on whether the user is logged in.

Create a new client component `AuthControls` (can be inline in a separate file or within Header). For simplicity, create it inline as a small client-side section.

**Approach:** Keep Header as a server component. Add a client component `UserMenu` for the interactive part.

Create `frontend/src/components/layout/UserMenu.tsx` as a `'use client'` component:
- Uses `useSession()` from `next-auth/react` to get session state
- If `status === "loading"`: render a small skeleton/placeholder (prevent layout shift)
- If `status === "unauthenticated"`: render a `<Link href="/login"><Button variant="ghost" size="sm">Sign In</Button></Link>`
- If `status === "authenticated"`: render user email (truncated) + a Sign Out button that calls `signOut({ callbackUrl: "/" })` from `next-auth/react`

For the mounted guard pattern (same as ThemeToggle from Phase 19): use `useEffect` + `useState` mounted flag to return `null` before hydration, preventing SSR/CSR mismatch. This is required because `useSession` returns "loading" on the server.

Update `Header.tsx`: Import and add `<UserMenu />` in the right actions area, between the cart button and ThemeToggle.

**Step 3: Update frontend/src/components/providers.tsx — add 403 interceptor**

The QueryClient creation already uses the `useState` factory pattern. Update it to include `QueryCache` and `MutationCache` with `onError` handlers that intercept 403 responses and trigger automatic sign-out.

Import at the top:
```typescript
import { QueryCache, MutationCache } from '@tanstack/react-query'
import { signOut } from 'next-auth/react'
import { ApiError } from '@/lib/api'
```

Update the QueryClient creation:
```typescript
const [queryClient] = useState(
  () => new QueryClient({
    queryCache: new QueryCache({
      onError: (error) => {
        if (error instanceof ApiError && error.status === 403) {
          signOut({ callbackUrl: "/login" })
        }
      },
    }),
    mutationCache: new MutationCache({
      onError: (error) => {
        if (error instanceof ApiError && error.status === 403) {
          signOut({ callbackUrl: "/login" })
        }
      },
    }),
    defaultOptions: {
      queries: {
        staleTime: 60 * 1000,
        retry: 1,
      },
    },
  })
)
```

This handles AUTH-08: when a deactivated user's token is used for any API call, the backend returns 403 with code `AUTH_ACCOUNT_DEACTIVATED`. The global error handler intercepts this and signs the user out.

**Also handle RefreshTokenError from session:** Add a small `useEffect` in providers.tsx or a dedicated `AuthGuard` component that watches the session for `session.error === "RefreshTokenError"` and calls `signOut()`. This handles the case where the jwt callback detects a refresh failure (per Pitfall 4 in RESEARCH.md — signOut cannot be called from the jwt callback).

Add inside the Providers component (or as a child component):
```typescript
function AuthGuard({ children }: { children: React.ReactNode }) {
  const { data: session } = useSession()
  useEffect(() => {
    if (session?.error === "RefreshTokenError") {
      signOut({ callbackUrl: "/login" })
    }
  }, [session?.error])
  return <>{children}</>
}
```

Wrap the children inside SessionProvider with this AuthGuard.
  </action>
  <verify>
    <automated>cd D:/Python/claude-test/frontend && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>
- proxy.ts exists at frontend/src/proxy.ts and redirects unauthenticated users from protected routes to /login?callbackUrl=...
- Header shows "Sign In" link when logged out and user email + "Sign Out" button when logged in
- Sign Out button calls signOut({ callbackUrl: "/" }) and ends the session
- QueryCache/MutationCache onError intercepts 403 responses and triggers signOut
- AuthGuard watches session.error for "RefreshTokenError" and triggers signOut
- Authenticated users visiting /login or /register are redirected to /
- TypeScript compiles with zero errors
  </done>
</task>

</tasks>

<verification>
1. TypeScript: `npx tsc --noEmit` passes with zero errors
2. Build: `npm run build` succeeds
3. proxy.ts: File exists at `frontend/src/proxy.ts` (NOT middleware.ts)
4. Auth pages: `/login` and `/register` routes exist with forms
5. Header: Shows different UI for logged-in vs logged-out states
6. 403 interceptor: QueryCache.onError checks for ApiError with status 403
7. Logout: signOut() called from UserMenu and from AuthGuard on RefreshTokenError
</verification>

<success_criteria>
- /login page renders email/password form + Google button
- /register page renders registration form + Google button
- proxy.ts redirects unauthenticated users from protected routes to /login with callbackUrl
- Header dynamically shows Sign In or user info + Sign Out based on auth state
- Deactivated users (403 from API) are automatically signed out
- Refresh token errors cause automatic sign-out
- TypeScript and production build both pass
</success_criteria>

<output>
After completion, create `.planning/phases/20-auth-integration/20-02-SUMMARY.md`
</output>
