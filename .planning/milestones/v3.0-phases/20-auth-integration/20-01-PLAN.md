---
phase: 20-auth-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/users/router.py
  - backend/app/users/schemas.py
  - backend/pyproject.toml
  - frontend/src/auth.ts
  - frontend/src/app/api/auth/[...nextauth]/route.ts
  - frontend/src/components/providers.tsx
  - frontend/.env.local
autonomous: true
requirements: [AUTH-01, AUTH-02, AUTH-03, AUTH-04, AUTH-07]

user_setup:
  - service: google-oauth
    why: "Google OAuth sign-in (AUTH-03) requires Google Cloud Console credentials"
    env_vars:
      - name: AUTH_GOOGLE_ID
        source: "Google Cloud Console -> APIs & Services -> Credentials -> OAuth 2.0 Client ID"
      - name: AUTH_GOOGLE_SECRET
        source: "Google Cloud Console -> APIs & Services -> Credentials -> OAuth 2.0 Client Secret"
      - name: AUTH_SECRET
        source: "Run `npx auth secret` in frontend/ to generate"
    dashboard_config:
      - task: "Create OAuth 2.0 Client ID (Web application type)"
        location: "Google Cloud Console -> APIs & Services -> Credentials"
      - task: "Add http://localhost:3000/api/auth/callback/google to Authorized redirect URIs"
        location: "Google Cloud Console -> OAuth 2.0 Client ID settings"

must_haves:
  truths:
    - "User can register with email+password via POST /auth/register and receive a NextAuth session"
    - "User can login with email+password via POST /auth/login and receive a NextAuth session"
    - "User can login with Google OAuth and receive a NextAuth session backed by FastAPI tokens"
    - "Session persists across page refresh (encrypted httpOnly cookie stores FastAPI token pair)"
    - "Expired access tokens are refreshed transparently in the jwt callback before API calls fail"
  artifacts:
    - path: "frontend/src/auth.ts"
      provides: "NextAuth config with Credentials + Google providers, jwt/session callbacks, token refresh"
      exports: ["handlers", "auth", "signIn", "signOut"]
    - path: "frontend/src/app/api/auth/[...nextauth]/route.ts"
      provides: "NextAuth route handler"
      exports: ["GET", "POST"]
    - path: "backend/app/users/router.py"
      provides: "POST /auth/google/token endpoint for Google id_token exchange"
      contains: "google_token_exchange"
  key_links:
    - from: "frontend/src/auth.ts"
      to: "POST /auth/login"
      via: "Credentials provider authorize callback"
      pattern: "fetch.*auth/login"
    - from: "frontend/src/auth.ts"
      to: "POST /auth/google/token"
      via: "jwt callback when account.provider === google"
      pattern: "fetch.*auth/google/token"
    - from: "frontend/src/auth.ts"
      to: "POST /auth/refresh"
      via: "refreshAccessToken called from jwt callback on token expiry"
      pattern: "fetch.*auth/refresh"
    - from: "frontend/src/components/providers.tsx"
      to: "frontend/src/auth.ts"
      via: "SessionProvider wrapping app"
      pattern: "SessionProvider"
---

<objective>
Wire NextAuth.js v5 to the existing FastAPI auth backend with Credentials (email/password) and Google OAuth providers, transparent token refresh, and session persistence.

Purpose: Establish the core auth session layer that all subsequent frontend features depend on. After this plan, users can authenticate (email or Google) and maintain sessions backed by FastAPI JWT tokens.

Output: NextAuth config (`auth.ts`), route handler, backend Google token exchange endpoint, SessionProvider integration, and env configuration.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-auth-integration/20-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From frontend/src/lib/api.ts:
```typescript
const API_BASE = process.env.NEXT_PUBLIC_API_URL ?? 'http://localhost:8000'

export class ApiError extends Error {
  constructor(message: string, public status: number, public detail?: string) {
    super(message)
    this.name = 'ApiError'
  }
}

export async function apiFetch<T>(path: string, options: RequestInit = {}): Promise<T>
```

From frontend/src/components/providers.tsx:
```typescript
'use client'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
import { ThemeProvider } from 'next-themes'
import { useState } from 'react'
import { Toaster } from '@/components/ui/sonner'

export function Providers({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(() => new QueryClient({
    defaultOptions: { queries: { staleTime: 60 * 1000, retry: 1 } },
  }))
  // Returns: QueryClientProvider > ThemeProvider > {children} + Toaster + ReactQueryDevtools
}
```

From backend/app/users/router.py:
```python
router = APIRouter(prefix="/auth", tags=["auth"])

# Existing endpoints:
# POST /auth/register -> TokenResponse (201)
# POST /auth/login -> TokenResponse
# POST /auth/refresh -> TokenResponse
# POST /auth/logout -> 204
# GET /auth/google -> redirect to Google consent
# GET /auth/google/callback -> TokenResponse
```

From backend/app/users/schemas.py:
```python
class TokenResponse(BaseModel):
    access_token: str
    refresh_token: str
    token_type: str = "bearer"

class UserCreate(BaseModel):
    email: EmailStr
    password: str = Field(min_length=8)

class LoginRequest(BaseModel):
    email: EmailStr
    password: str

class RefreshRequest(BaseModel):
    refresh_token: str
```

From backend/app/users/service.py:
```python
class AuthService:
    async def register(self, email: str, password: str) -> tuple[str, str]
    async def login(self, email: str, password: str) -> tuple[str, str]
    async def refresh(self, refresh_token: str) -> tuple[str, str]
    async def logout(self, refresh_token: str) -> None
    async def oauth_login(self, provider: str, provider_user_id: str, email: str) -> tuple[str, str]
```

From backend/app/core/security.py:
```python
# JWT claims: sub (str user_id), role, jti (UUID), iat, exp (15-min TTL)
# Algorithm: HS256
def create_access_token(user_id: int, role: str) -> str
```

From backend/app/core/config.py:
```python
class Settings(BaseSettings):
    GOOGLE_CLIENT_ID: str = ""
    GOOGLE_CLIENT_SECRET: str = ""
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add POST /auth/google/token backend endpoint for Google id_token exchange</name>
  <files>
    backend/app/users/router.py
    backend/app/users/schemas.py
    backend/pyproject.toml
  </files>
  <action>
Add a new backend endpoint `POST /auth/google/token` that accepts a Google `id_token` from NextAuth's Google provider and returns a FastAPI token pair. This endpoint bypasses the existing Authlib redirect flow (which requires server-side OAuth state) and instead validates the raw Google id_token directly.

**Step 1: Install google-auth**

Add `google-auth` to `backend/pyproject.toml` dependencies:
```
google-auth = "^2.0"
```
Run `cd backend && poetry add google-auth` to install.

**Step 2: Add schema to backend/app/users/schemas.py**

Add a new request schema after the existing ones:
```python
class GoogleTokenRequest(BaseModel):
    """POST /auth/google/token request body — Google id_token from NextAuth."""
    id_token: str
```

**Step 3: Add endpoint to backend/app/users/router.py**

Add the following imports at the top:
```python
from google.oauth2 import id_token as google_id_token
from google.auth.transport import requests as google_requests
from app.core.config import get_settings
```

Add the `GoogleTokenRequest` import from schemas.

Add the endpoint after the existing Google OAuth routes:
```python
@router.post("/google/token", response_model=TokenResponse)
async def google_token_exchange(body: GoogleTokenRequest, db: DbSession) -> TokenResponse:
    """Exchange a Google id_token (from NextAuth) for a FastAPI token pair.

    This endpoint validates the Google id_token using Google's public keys,
    extracts the user's email and Google user ID, then delegates to the
    existing oauth_login() service method.
    """
    settings = get_settings()
    try:
        idinfo = google_id_token.verify_oauth2_token(
            body.id_token,
            google_requests.Request(),
            settings.GOOGLE_CLIENT_ID,
        )
    except ValueError as e:
        raise AppError(
            status_code=401,
            detail="Invalid Google token",
            code="AUTH_GOOGLE_INVALID_TOKEN",
        ) from e

    if not idinfo.get("email_verified"):
        raise AppError(
            status_code=401,
            detail="Google email is not verified",
            code="AUTH_OAUTH_EMAIL_UNVERIFIED",
        )

    service = _make_service(db)
    access_token, refresh_token = await service.oauth_login(
        provider="google",
        provider_user_id=idinfo["sub"],
        email=idinfo["email"],
    )
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)
```

**Important:** The `verify_oauth2_token` call is synchronous and makes an HTTP call to fetch Google's public keys. This is acceptable for auth endpoints (not high-throughput). If needed later, wrap in `asyncio.to_thread()`.

**Do NOT** modify the existing `/auth/google` or `/auth/google/callback` endpoints — those still serve the server-side OAuth flow for the backend-only API.
  </action>
  <verify>
    <automated>cd D:/Python/claude-test/backend && poetry run python -c "from app.users.router import router; routes = [r.path for r in router.routes]; assert '/google/token' in routes, f'Missing route. Found: {routes}'; print('OK: /auth/google/token route registered')"</automated>
  </verify>
  <done>POST /auth/google/token endpoint exists in router, accepts GoogleTokenRequest body, validates id_token via google-auth library, and returns TokenResponse via existing oauth_login() service method.</done>
</task>

<task type="auto">
  <name>Task 2: Create NextAuth.js v5 configuration with Credentials + Google providers and transparent token refresh</name>
  <files>
    frontend/src/auth.ts
    frontend/src/app/api/auth/[...nextauth]/route.ts
    frontend/src/components/providers.tsx
    frontend/.env.local
  </files>
  <action>
**Step 1: Install next-auth@beta and jose**

```bash
cd frontend && npm install next-auth@beta jose
```

`next-auth@beta` is Auth.js v5 for Next.js. `jose` is for decoding the FastAPI JWT payload to extract `sub` (userId) and `role` claims without a separate /me API call.

**Step 2: Create frontend/src/auth.ts**

This is the central NextAuth configuration. Create the file with:

1. **Module augmentation** at the top — extend `next-auth` Session type and `next-auth/jwt` JWT type:
   ```typescript
   declare module "next-auth" {
     interface Session {
       accessToken: string
       error?: string
       user: { id: string; role: string } & DefaultSession["user"]
     }
     interface User {
       accessToken: string
       refreshToken: string
       accessTokenExpiry: number
       role: string
     }
   }
   declare module "next-auth/jwt" {
     interface JWT {
       accessToken: string
       refreshToken: string
       accessTokenExpiry: number
       userId: string
       role: string
       error?: string
     }
   }
   ```

2. **`refreshAccessToken` function** — calls `POST /auth/refresh` with the stored refresh_token. On success, returns updated token with new access_token, refresh_token, and accessTokenExpiry (Date.now() + 14 * 60 * 1000 — 14 min, 1 min buffer before 15-min TTL). On failure, returns `{ ...token, error: "RefreshTokenError" }`. Use a module-level `refreshPromise` variable as a concurrent-refresh guard: if a refresh is already in-flight, return the existing promise instead of starting a new one.

3. **`decodeJwtPayload` helper** — use `jose` library's `decodeJwt` (NOT verify — verification is server-side) to extract `sub` and `role` from the FastAPI access_token. This avoids an extra /me API call.

4. **NextAuth config** — export `{ handlers, auth, signIn, signOut }` from `NextAuth({...})`:
   - **providers:**
     - `Credentials` with email+password fields. The `authorize` callback: validate with zod (`z.object({ email: z.string().email(), password: z.string().min(8) })`), call `POST ${API}/auth/login` with the credentials, on success decode the JWT to get userId and role, return user object `{ id: userId, email, accessToken, refreshToken, accessTokenExpiry: Date.now() + 14*60*1000, role }`. On failure (non-2xx), return `null` (NOT throw — per Pitfall 6 in RESEARCH.md).
     - `Google` — just `Google` (auto-reads `AUTH_GOOGLE_ID` and `AUTH_GOOGLE_SECRET` from env).
   - **session:** `{ strategy: "jwt" }`
   - **pages:** `{ signIn: "/login", error: "/login" }` — custom login page
   - **callbacks:**
     - `jwt({ token, user, account })`:
       - If `user` exists (first sign-in via Credentials): copy accessToken, refreshToken, accessTokenExpiry, userId (user.id), role from user to token.
       - If `account?.provider === "google" && account.id_token`: call `POST ${API}/auth/google/token` with `{ id_token: account.id_token }`. On success: decode the returned access_token with jose to get userId and role, set token.accessToken, token.refreshToken, token.accessTokenExpiry, token.userId, token.role. On failure: set `token.error = "GoogleTokenExchangeError"`.
       - Check expiry: if `Date.now() < token.accessTokenExpiry`, return token as-is. Otherwise, call `refreshAccessToken(token)`.
     - `session({ session, token })`: copy `token.accessToken` → `session.accessToken`, `token.userId` → `session.user.id`, `token.role` → `session.user.role`, `token.error` → `session.error`.

**API base URL:** Use `const API = process.env.NEXT_PUBLIC_API_URL ?? "http://localhost:8000"` at top of file.

**Step 3: Create frontend/src/app/api/auth/[...nextauth]/route.ts**

Create the directory structure `frontend/src/app/api/auth/[...nextauth]/` and add `route.ts`:
```typescript
import { handlers } from "@/auth"
export const { GET, POST } = handlers
```

**Step 4: Update frontend/src/components/providers.tsx**

Add `SessionProvider` from `next-auth/react` as the outermost provider wrapper. Import at the top:
```typescript
import { SessionProvider } from "next-auth/react"
```

Wrap the return JSX so SessionProvider is outside QueryClientProvider:
```tsx
return (
  <SessionProvider>
    <QueryClientProvider client={queryClient}>
      <ThemeProvider ...>
        {children}
        <Toaster richColors position="bottom-right" />
      </ThemeProvider>
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  </SessionProvider>
)
```

**Step 5: Update frontend/.env.local**

Add the following env vars (these are development placeholders — user will need to set real Google OAuth values):
```
AUTH_SECRET=generate-with-npx-auth-secret
AUTH_GOOGLE_ID=your-google-client-id
AUTH_GOOGLE_SECRET=your-google-client-secret
```

The `AUTH_SECRET` is required by NextAuth v5 for encrypting the session cookie. The user must run `npx auth secret` in the frontend/ directory to generate a real value.

**CRITICAL ANTI-PATTERNS TO AVOID (from RESEARCH.md):**
- Do NOT use `middleware.ts` filename — Next.js 16 uses `proxy.ts` (handled in Plan 20-02)
- Do NOT store tokens in localStorage — NextAuth's encrypted httpOnly cookie is the storage
- Do NOT call `signOut()` from the jwt callback — it's server-side; set `token.error` instead
- Credentials `authorize` MUST return `null` on login failure, NOT throw
- Do NOT forget to update `accessTokenExpiry` after refresh
  </action>
  <verify>
    <automated>cd D:/Python/claude-test/frontend && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>
- frontend/src/auth.ts exports { handlers, auth, signIn, signOut } with Credentials + Google providers
- JWT callback handles: initial Credentials sign-in, Google id_token exchange, transparent token refresh
- Session callback exposes accessToken, user.id, user.role, and error to client
- Route handler at /api/auth/[...nextauth] exports GET and POST from handlers
- SessionProvider wraps the app in providers.tsx
- TypeScript compiles with zero errors
  </done>
</task>

</tasks>

<verification>
1. Backend: `POST /auth/google/token` route exists and imports are correct
2. Frontend: `npx tsc --noEmit` passes with zero errors
3. Frontend: `npm run build` succeeds (production build)
4. auth.ts: exports `handlers`, `auth`, `signIn`, `signOut`
5. route.ts: exports `GET` and `POST` from handlers
6. providers.tsx: SessionProvider wraps the component tree
</verification>

<success_criteria>
- NextAuth.js v5 is installed and configured with Credentials + Google providers
- JWT callback stores FastAPI token pair (access_token + refresh_token) in encrypted session cookie
- Token refresh happens transparently when access token expires (14-min threshold)
- Google id_token exchange endpoint exists on backend and is wired in jwt callback
- SessionProvider enables `useSession` in client components
- TypeScript compiles and production build succeeds
</success_criteria>

<deferred_gaps>
**Authorization header injection in `frontend/src/lib/api.ts` — deferred to Phase 21.**

RESEARCH.md Pattern 9 identifies that `lib/api.ts` must inject `Authorization: Bearer {accessToken}` into every authenticated API request. This is NOT implemented in Phase 20 because:
1. Phase 20 establishes the **session layer** (storing FastAPI tokens in NextAuth's encrypted cookie).
2. No Phase 20 feature actually makes authenticated API calls to the backend (auth endpoints handle their own tokens).
3. The wiring belongs in Phase 21+ when authenticated API calls (cart, orders, user profile) are first needed.

**Phase 21 must:** Update `lib/api.ts` to accept an optional token parameter, or create a `useApiFetch()` client hook that reads the session token via `useSession()` and a server-side `authedApiFetch()` that reads the token via `auth()`. See RESEARCH.md Pattern 9 for the approach.
</deferred_gaps>

<output>
After completion, create `.planning/phases/20-auth-integration/20-01-SUMMARY.md`
</output>
