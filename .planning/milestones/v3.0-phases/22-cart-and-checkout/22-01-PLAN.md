---
phase: 22-cart-and-checkout
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/lib/api.ts
  - frontend/src/lib/cart.ts
  - frontend/src/components/layout/CartBadge.tsx
  - frontend/src/components/layout/Header.tsx
  - frontend/src/proxy.ts
  - frontend/src/components/ui/dialog.tsx
  - frontend/src/components/ui/separator.tsx
autonomous: true
requirements: [SHOP-09, SHOP-10]

must_haves:
  truths:
    - "Cart count badge appears in the navbar when user has items in cart"
    - "Badge disappears when cart is empty (no '0' badge shown)"
    - "Unauthenticated user visiting /cart is redirected to /login"
    - "ApiError carries full response body for structured error handling"
  artifacts:
    - path: "frontend/src/lib/cart.ts"
      provides: "Cart API functions, useCart hook with optimistic mutations, CART_KEY constant"
      exports: ["fetchCart", "addCartItem", "updateCartItem", "removeCartItem", "checkout", "fetchOrder", "useCart", "CART_KEY"]
    - path: "frontend/src/components/layout/CartBadge.tsx"
      provides: "Client component showing cart item count on Header ShoppingCart icon"
      min_lines: 20
    - path: "frontend/src/lib/api.ts"
      provides: "Extended ApiError with optional data field for structured error bodies"
      contains: "data?"
  key_links:
    - from: "frontend/src/lib/cart.ts"
      to: "frontend/src/lib/api.ts"
      via: "apiFetch with Authorization header"
      pattern: "apiFetch.*Authorization.*Bearer"
    - from: "frontend/src/components/layout/CartBadge.tsx"
      to: "frontend/src/lib/cart.ts"
      via: "useCart hook for badge count"
      pattern: "useCart|CART_KEY"
    - from: "frontend/src/components/layout/Header.tsx"
      to: "frontend/src/components/layout/CartBadge.tsx"
      via: "CartBadge rendered inside ShoppingCart link"
      pattern: "<CartBadge"
    - from: "frontend/src/proxy.ts"
      to: "/cart"
      via: "protectedPrefixes array"
      pattern: '"/cart"'
---

<objective>
Create the cart data layer (API functions + useCart hook with optimistic mutations), integrate CartBadge into the Header, protect /cart behind auth, and extend ApiError for structured error bodies.

Purpose: Establish the foundation that all subsequent cart/checkout plans depend on — every cart UI component will consume the useCart hook and CART_KEY from this plan.
Output: `lib/cart.ts` with full API + hook, `CartBadge.tsx` in Header, `/cart` protected, shadcn dialog + separator installed.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-cart-and-checkout/22-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From frontend/src/lib/api.ts:
```typescript
const API_BASE = process.env.NEXT_PUBLIC_API_URL ?? 'http://localhost:8000'

export class ApiError extends Error {
  constructor(
    message: string,
    public status: number,
    public detail?: string
  ) {
    super(message)
    this.name = 'ApiError'
  }
}

export async function apiFetch<T>(
  path: string,
  options: RequestInit = {}
): Promise<T>
```

From frontend/src/components/layout/Header.tsx:
```typescript
// Server Component — ShoppingCart link section:
<Link href="/cart">
  <Button variant="ghost" size="icon" aria-label="Shopping cart">
    <ShoppingCart className="h-5 w-5" />
  </Button>
</Link>
```

From frontend/src/components/layout/UserMenu.tsx (mounted guard pattern):
```typescript
'use client'
import { useEffect, useState } from 'react'
import { useSession } from 'next-auth/react'

export function UserMenu() {
  const { data: session, status } = useSession()
  const [mounted, setMounted] = useState(false)
  useEffect(() => { setMounted(true) }, [])
  if (!mounted) return null
  // ...
}
```

From frontend/src/proxy.ts:
```typescript
const protectedPrefixes = ["/account", "/orders", "/checkout", "/wishlist", "/prebook"]
```

From frontend/src/types/api.generated.ts (key types):
```typescript
type CartResponse = {
  items: CartItemResponse[]
  readonly total_items: number
  readonly total_price: string  // decimal e.g. "49.98"
}

type CartItemResponse = {
  id: number
  book_id: number
  quantity: number
  book: {
    id: number; title: string; author: string;
    price: string; cover_image_url: string | null
  }
}

type OrderResponse = {
  id: number; status: string; created_at: string;
  items: OrderItemResponse[]
  readonly total_price: string
}

type OrderItemResponse = {
  id: number; book_id: number | null; quantity: number;
  unit_price: string;
  book: { id: number; title: string; author: string } | null
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend ApiError, create cart API functions and useCart hook</name>
  <files>
    frontend/src/lib/api.ts
    frontend/src/lib/cart.ts
  </files>
  <action>
**Step 1: Extend ApiError in `frontend/src/lib/api.ts`**

Add an optional `data` field to the `ApiError` class to carry structured error response bodies (needed for 409 ORDER_INSUFFICIENT_STOCK which returns `items[]`):

```typescript
export class ApiError extends Error {
  constructor(
    message: string,
    public status: number,
    public detail?: string,
    public data?: unknown  // NEW: full response body for structured errors
  ) {
    super(message)
    this.name = 'ApiError'
  }
}
```

Update the `apiFetch` error handler to pass the full body:

```typescript
throw new ApiError(
  body.detail ?? `API error ${res.status}`,
  res.status,
  body.detail,
  body  // Pass full response body
)
```

**Step 2: Create `frontend/src/lib/cart.ts`**

Create the cart API module with:

1. **Type imports** from `@/types/api.generated` — `CartResponse`, `CartItemResponse`, `OrderResponse`
2. **Cart API functions** — all accept `accessToken: string` as first arg, use `apiFetch` with `Authorization: Bearer ${accessToken}` header:
   - `fetchCart(accessToken)` → GET /cart → CartResponse
   - `addCartItem(accessToken, bookId, quantity=1)` → POST /cart/items → CartItemResponse
   - `updateCartItem(accessToken, itemId, quantity)` → PUT /cart/items/{itemId} → CartItemResponse
   - `removeCartItem(accessToken, itemId)` → DELETE /cart/items/{itemId} → void
   - `checkout(accessToken)` → POST /orders/checkout with `{force_payment_failure: false}` → OrderResponse
   - `fetchOrder(accessToken, orderId)` → GET /orders/{orderId} → OrderResponse
3. **CART_KEY constant** — `['cart'] as const`
4. **useCart() hook** — shared hook that returns cart query + all mutations with optimistic updates:
   - Uses `useSession()` to get `accessToken` from `session?.accessToken`
   - `cartQuery` — `useQuery({ queryKey: CART_KEY, queryFn: () => fetchCart(accessToken), enabled: !!accessToken, staleTime: 30_000 })`
   - `addItem` mutation — optimistically increments `total_items` in cache; `onError` checks `ApiError.status === 409` for "Already in cart" toast with "View Cart" action link using `router.push('/cart')`; `onSuccess` shows `toast.success('Added to cart')`
   - `updateItem` mutation — optimistically updates the item's quantity and recomputes `total_items` and `total_price` locally (using `parseFloat(item.book.price) * item.quantity` summed, `.toFixed(2)`); rolls back on error with toast
   - `removeItem` mutation — optimistically filters out the item, recomputes totals; rolls back on error with toast
   - `checkoutMutation` — on success: clears cart cache with `setQueryData(CART_KEY, { items: [], total_items: 0, total_price: '0.00' })` and calls `router.push(\`/orders/${order.id}?confirmed=true\`)`; on error: handles 409 (insufficient stock), 402 (payment failed), 422 (empty cart) with specific toasts
   - All mutations use `onMutate` → `cancelQueries` → `getQueryData` snapshot → `setQueryData` optimistic → return `{ previousCart }`; `onError` → rollback + toast; `onSettled` → `invalidateQueries`

All optimistic total recomputation must use `parseFloat()` for price strings and `.toFixed(2)` for display. Cast optimistic cart as `CartResponse` since `total_items` and `total_price` are readonly.

Import `useRouter` from `next/navigation`, `toast` from `sonner`, `useSession` from `next-auth/react`, `useQuery`/`useMutation`/`useQueryClient` from `@tanstack/react-query`.
  </action>
  <verify>
    <automated>cd D:/Python/claude-test/frontend && npx tsc --noEmit 2>&1 | head -30</automated>
  </verify>
  <done>
    - `lib/api.ts` ApiError has `data?: unknown` field and `apiFetch` passes full body
    - `lib/cart.ts` exports all 6 API functions, CART_KEY, and useCart hook
    - useCart returns cartQuery + addItem + updateItem + removeItem + checkoutMutation
    - All mutations implement optimistic update pattern with rollback
    - TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CartBadge, integrate into Header, protect /cart route, install shadcn components</name>
  <files>
    frontend/src/components/layout/CartBadge.tsx
    frontend/src/components/layout/Header.tsx
    frontend/src/proxy.ts
    frontend/src/components/ui/dialog.tsx
    frontend/src/components/ui/separator.tsx
  </files>
  <action>
**Step 1: Install shadcn dialog and separator components** (needed by later plans)

```bash
cd frontend
npx shadcn@latest add dialog --yes
npx shadcn@latest add separator --yes
```

**Step 2: Create `frontend/src/components/layout/CartBadge.tsx`**

A `'use client'` component following the `UserMenu.tsx` mounted-guard pattern to prevent hydration mismatch:

```typescript
'use client'

import { useEffect, useState } from 'react'
import { useSession } from 'next-auth/react'
import { useQuery } from '@tanstack/react-query'
import { fetchCart, CART_KEY } from '@/lib/cart'

export function CartBadge() {
  const { data: session } = useSession()
  const accessToken = session?.accessToken ?? ''
  const [mounted, setMounted] = useState(false)

  useEffect(() => { setMounted(true) }, [])

  const { data: cart } = useQuery({
    queryKey: CART_KEY,
    queryFn: () => fetchCart(accessToken),
    enabled: !!accessToken && mounted,
    staleTime: 30_000,
  })

  if (!mounted || !cart || cart.total_items === 0) return null

  return (
    <span className="absolute -top-1 -right-1 flex h-4 w-4 items-center justify-center rounded-full bg-primary text-[10px] font-bold text-primary-foreground">
      {cart.total_items > 99 ? '99+' : cart.total_items}
    </span>
  )
}
```

**Step 3: Update `frontend/src/components/layout/Header.tsx`**

Import `CartBadge` and wrap the ShoppingCart link with `relative` positioning:

Change the cart link section from:
```tsx
<Link href="/cart">
  <Button variant="ghost" size="icon" aria-label="Shopping cart">
    <ShoppingCart className="h-5 w-5" />
  </Button>
</Link>
```
To:
```tsx
<Link href="/cart" className="relative">
  <Button variant="ghost" size="icon" aria-label="Shopping cart">
    <ShoppingCart className="h-5 w-5" />
  </Button>
  <CartBadge />
</Link>
```

Add the import: `import { CartBadge } from '@/components/layout/CartBadge'`

**Step 4: Add `/cart` to protected routes in `frontend/src/proxy.ts`**

Change:
```typescript
const protectedPrefixes = ["/account", "/orders", "/checkout", "/wishlist", "/prebook"]
```
To:
```typescript
const protectedPrefixes = ["/account", "/orders", "/checkout", "/wishlist", "/prebook", "/cart"]
```

This ensures unauthenticated users visiting /cart are redirected to /login with callbackUrl=/cart.
  </action>
  <verify>
    <automated>cd D:/Python/claude-test/frontend && npx tsc --noEmit 2>&1 | head -30 && test -f src/components/ui/dialog.tsx && test -f src/components/ui/separator.tsx && echo "PASS: dialog and separator installed"</automated>
  </verify>
  <done>
    - CartBadge.tsx is a 'use client' component with mounted guard, shows count from useCart query
    - Header.tsx renders CartBadge inside the ShoppingCart link with relative positioning
    - proxy.ts protects /cart — unauthenticated users redirect to /login
    - shadcn dialog and separator components are installed
    - TypeScript compiles without errors
  </done>
</task>

</tasks>

<verification>
1. `cd frontend && npx tsc --noEmit` passes (no type errors)
2. `cd frontend && npm run build` completes without errors
3. CartBadge renders null when not authenticated (no hydration mismatch)
4. `/cart` redirects to `/login?callbackUrl=%2Fcart` when not logged in
</verification>

<success_criteria>
- lib/cart.ts exports 6 API functions, CART_KEY, and useCart hook with optimistic mutations
- CartBadge shows item count in Header when user has cart items, hidden when empty or unauthenticated
- /cart is auth-protected via proxy.ts
- ApiError carries full response body in data field
- shadcn dialog and separator components are installed for use by later plans
</success_criteria>

<output>
After completion, create `.planning/phases/22-cart-and-checkout/22-01-SUMMARY.md`
</output>
