---
phase: 28-book-catalog-crud
plan: "02"
type: execute
wave: 2
depends_on: ["28-01"]
files_modified:
  - frontend/src/components/admin/BookForm.tsx
  - frontend/src/components/admin/ConfirmDialog.tsx
  - frontend/src/components/admin/StockUpdateModal.tsx
  - frontend/src/app/admin/catalog/page.tsx
  - frontend/src/app/admin/inventory/page.tsx
autonomous: true
requirements: [CATL-03, CATL-04, CATL-05, CATL-06]

must_haves:
  truths:
    - "Admin can open an Add Book side drawer, fill fields with validation, submit, and see the new book in the table"
    - "Admin can click Edit on a row to open a pre-populated side drawer, change fields, save, and see updates reflected"
    - "Admin can click Delete on a row, see a confirmation dialog with book title and warning text, confirm, and have the book removed"
    - "Admin can open a stock update modal on any row, enter a new quantity, save, and see a special toast when restocking from zero"
    - "All mutations invalidate both admin catalog cache and customer-facing book queries"
  artifacts:
    - path: "frontend/src/components/admin/BookForm.tsx"
      provides: "Dual-mode add/edit form with react-hook-form + zod validation in Sheet side drawer"
      exports: ["BookForm"]
    - path: "frontend/src/components/admin/ConfirmDialog.tsx"
      provides: "Reusable delete confirmation dialog with customizable title, description, and destructive action"
      exports: ["ConfirmDialog"]
    - path: "frontend/src/components/admin/StockUpdateModal.tsx"
      provides: "Shared stock update modal with pre-booking toast logic"
      exports: ["StockUpdateModal"]
    - path: "frontend/src/app/admin/catalog/page.tsx"
      provides: "Full catalog page wiring all CRUD operations"
    - path: "frontend/src/app/admin/inventory/page.tsx"
      provides: "Inventory page updated to use shared StockUpdateModal"
  key_links:
    - from: "frontend/src/app/admin/catalog/page.tsx"
      to: "frontend/src/lib/admin.ts"
      via: "createBook, updateBook, deleteBook, updateBookStock mutations"
      pattern: "useMutation"
    - from: "frontend/src/app/admin/catalog/page.tsx"
      to: "frontend/src/components/admin/BookForm.tsx"
      via: "Sheet side drawer for add/edit"
      pattern: "<BookForm"
    - from: "frontend/src/app/admin/catalog/page.tsx"
      to: "frontend/src/components/admin/ConfirmDialog.tsx"
      via: "Delete confirmation dialog"
      pattern: "<ConfirmDialog"
    - from: "frontend/src/app/admin/catalog/page.tsx"
      to: "frontend/src/components/admin/StockUpdateModal.tsx"
      via: "Stock update modal"
      pattern: "<StockUpdateModal"
---

<objective>
Build the CRUD forms, confirmation dialogs, and stock update modal for the catalog page. Wire all mutations (add, edit, delete, stock update) with cross-cache invalidation and toast feedback.

Purpose: Complete the full book catalog management experience — admin can create, read, update, and delete books from a single page.
Output: Fully functional CRUD catalog page with BookForm, ConfirmDialog, and StockUpdateModal components.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-book-catalog-crud/28-RESEARCH.md
@.planning/phases/28-book-catalog-crud/28-01-SUMMARY.md

<interfaces>
<!-- Key types, contracts, and patterns the executor needs. -->

From frontend/src/lib/admin.ts (after Plan 01):
```typescript
export const adminKeys = {
  all: ['admin'] as const,
  sales: { /* ... */ },
  inventory: {
    all: ['admin', 'inventory'] as const,
    lowStock: (threshold: number) => ['admin', 'inventory', 'low-stock', threshold] as const,
  },
  catalog: {
    all: ['admin', 'catalog'] as const,
    list: (params: { q?: string; genre_id?: number; page?: number }) =>
      ['admin', 'catalog', 'list', params] as const,
    genres: ['admin', 'catalog', 'genres'] as const,
  },
} as const

export async function createBook(accessToken: string, data: BookCreate): Promise<BookResponse>
export async function updateBook(accessToken: string, bookId: number, data: BookUpdate): Promise<BookResponse>
export async function deleteBook(accessToken: string, bookId: number): Promise<void>
export async function updateBookStock(accessToken: string, bookId: number, quantity: number): Promise<void>
```

From frontend/src/types/api.generated.ts:
```typescript
BookCreate: {
  title: string; author: string; price: number | string;
  isbn?: string | null; genre_id?: number | null; description?: string | null;
  cover_image_url?: string | null; publish_date?: string | null;
}
BookUpdate: {
  title?: string | null; author?: string | null; price?: number | string | null;
  isbn?: string | null; genre_id?: number | null; description?: string | null;
  cover_image_url?: string | null; publish_date?: string | null;
}
BookResponse: {
  id: number; title: string; author: string; price: string;
  isbn: string | null; genre_id: number | null; description: string | null;
  cover_image_url: string | null; publish_date: string | null; stock_quantity: number;
}
GenreResponse: { id: number; name: string; }
```

From frontend/src/lib/api.ts:
```typescript
export class ApiError extends Error {
  constructor(message: string, public status: number, public detail?: string, public data?: unknown)
}
```

From frontend/src/app/admin/catalog/page.tsx (after Plan 01):
- 'use client' page with useSession, useQuery for books + genres
- DataTable with column definitions including Actions dropdown
- searchInput, selectedGenre, page state
- Placeholder action handlers for Edit, Delete, Update Stock

From frontend/src/components/ui/sheet.tsx:
```typescript
export { Sheet, SheetContent, SheetHeader, SheetTitle, SheetDescription, SheetFooter, SheetTrigger, SheetClose }
```

From frontend/src/components/ui/dialog.tsx:
```typescript
export { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter, DialogTrigger, DialogClose }
```

From frontend/src/app/admin/inventory/page.tsx (stock update modal pattern):
- Uses Dialog for stock update modal
- selectedBook state: { book_id, title, current_stock }
- newQuantity state
- stockMutation with useMutation calling updateBookStock
- onSuccess: invalidateQueries + toast.success + close modal
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BookForm, ConfirmDialog, and StockUpdateModal components</name>
  <files>
    frontend/src/components/admin/BookForm.tsx,
    frontend/src/components/admin/ConfirmDialog.tsx,
    frontend/src/components/admin/StockUpdateModal.tsx
  </files>
  <action>
**Step 1: Create BookForm.tsx** — A dual-mode form (Add/Edit) using react-hook-form + zod inside a Sheet side drawer.

Key implementation details:
- Define `bookSchema` with zod (v4.3.6 — basic API same as v3 for this use case):
  ```typescript
  import { z } from 'zod'
  const bookSchema = z.object({
    title: z.string().min(1, 'Title is required'),
    author: z.string().min(1, 'Author is required'),
    price: z.string().min(1, 'Price is required').regex(/^\d+(\.\d{1,2})?$/, 'Invalid price (e.g. 9.99)'),
    isbn: z.string().optional().or(z.literal('')),
    genre_id: z.union([z.number(), z.literal('')]).optional(),
    description: z.string().optional().or(z.literal('')),
    cover_image_url: z.string().url('Invalid URL').optional().or(z.literal('')),
    publish_date: z.string().optional().or(z.literal('')),
  })
  type BookFormValues = z.infer<typeof bookSchema>
  ```
- Props interface:
  ```typescript
  interface BookFormProps {
    book?: BookResponse | null       // null/undefined = Add mode, defined = Edit mode
    genres: GenreResponse[]           // for genre Select dropdown
    onSubmit: (data: BookFormValues) => void
    onCancel: () => void
    isPending?: boolean               // disables submit button during mutation
  }
  ```
- Use `useForm<BookFormValues>` with `resolver: zodResolver(bookSchema)` from `@hookform/resolvers/zod`
- For Edit mode: use `useEffect` to call `form.reset(bookToFormValues(book))` when `book` prop changes. Helper function converts `BookResponse` to `BookFormValues` (map null fields to empty strings, genre_id null to '').
- Render form fields in a vertical stack inside the Sheet body area:
  - title: `<Input>` with `{...form.register('title')}` — required
  - author: `<Input>` with `{...form.register('author')}` — required
  - price: `<Input type="text">` with `{...form.register('price')}` — required, regex validated
  - isbn: `<Input>` with `{...form.register('isbn')}`
  - genre_id: `<Select>` with "No Genre" default + genre options from props. Use `form.setValue('genre_id', ...)` on change and `form.watch('genre_id')` for controlled value. Convert genre_id between number and string for Select component compatibility.
  - description: `<Textarea>` with `{...form.register('description')}`
  - cover_image_url: `<Input type="url">` with `{...form.register('cover_image_url')}`
  - publish_date: `<Input type="date">` with `{...form.register('publish_date')}`
- Each field wrapped with `<Label>` above and error text below: `{form.formState.errors.fieldName && <p className="text-sm text-red-500">{form.formState.errors.fieldName.message}</p>}`
- Footer: Cancel button (calls onCancel) and Submit button (type="submit", disabled when isPending, shows "Adding..." or "Saving..." during mutation)
- Wrap entire form in `<form onSubmit={form.handleSubmit(onSubmit)}>`

**Step 2: Create ConfirmDialog.tsx** — Reusable confirmation dialog for delete and other destructive actions.

```typescript
interface ConfirmDialogProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  title: string
  description: string
  confirmLabel?: string        // defaults to "Delete"
  onConfirm: () => void
  isPending?: boolean
}
```
- Uses existing `Dialog` from `dialog.tsx` (NOT a separate AlertDialog — project doesn't have one)
- DialogContent with DialogHeader (title + description), DialogFooter with Cancel + red destructive confirm button
- Confirm button disabled when isPending, shows loading text ("{confirmLabel}ing..." pattern or "Deleting...")
- Per CONTEXT.md: warning text "This action cannot be undone" included in description by the caller, not hardcoded in ConfirmDialog

**Step 3: Create StockUpdateModal.tsx** — Shared stock update modal extracted from the inventory page pattern.

```typescript
interface StockUpdateModalProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  book: { book_id: number; title: string; current_stock: number } | null
  accessToken: string
  onSuccess?: () => void     // additional actions after mutation success (e.g. extra invalidation)
}
```
- Uses Dialog from dialog.tsx
- Internal `newQuantity` state, initialized to `book?.current_stock ?? 0` via useEffect when book changes
- Internal `useMutation` calling `updateBookStock(accessToken, bookId, quantity)`
- onSuccess handler:
  1. Invalidate `adminKeys.inventory.all` (inventory page)
  2. Invalidate `adminKeys.catalog.all` (catalog table)
  3. Invalidate `['books']` (customer-facing, forward-compat)
  4. Pre-booking toast logic: if `book.current_stock === 0` and `newQuantity > 0`, show `toast.success('Stock updated — pre-booking notifications sent')`, else show `toast.success('Stock updated successfully')`
  5. Call `onSuccess?.()` prop for any additional caller-specific actions
  6. Close modal via `onOpenChange(false)`
- onError: `toast.error('Failed to update stock')`
- Same dialog layout as the existing inventory page modal: title "Update Stock", description with book title, current stock display, quantity input, Cancel/Save buttons
  </action>
  <verify>
    <automated>cd frontend && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>
    - BookForm renders 8 fields with labels, inline validation errors, and handles both Add and Edit modes
    - ConfirmDialog shows title, description, Cancel/Confirm buttons with pending state
    - StockUpdateModal shows book title, current stock, quantity input, and triggers pre-booking toast when restocking from zero
    - All three components compile without TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire CRUD operations into catalog page and update inventory page to use shared StockUpdateModal</name>
  <files>
    frontend/src/app/admin/catalog/page.tsx,
    frontend/src/app/admin/inventory/page.tsx
  </files>
  <action>
**Step 1: Update catalog/page.tsx** to wire all CRUD operations. Replace the Plan 01 placeholder handlers with real state and mutations.

Add these state variables:
```typescript
const [drawerOpen, setDrawerOpen] = useState(false)
const [editingBook, setEditingBook] = useState<BookResponse | null>(null)
const [deleteTarget, setDeleteTarget] = useState<BookResponse | null>(null)
const [stockTarget, setStockTarget] = useState<{ book_id: number; title: string; current_stock: number } | null>(null)
```

Add mutations (inside the component, after the queries):
```typescript
const queryClient = useQueryClient()

const createMutation = useMutation({
  mutationFn: (data: BookFormValues) => {
    // Convert form values to BookCreate shape
    const payload = {
      ...data,
      isbn: data.isbn || null,
      genre_id: typeof data.genre_id === 'number' ? data.genre_id : null,
      description: data.description || null,
      cover_image_url: data.cover_image_url || null,
      publish_date: data.publish_date || null,
    }
    return createBook(accessToken, payload as BookCreate)
  },
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: adminKeys.catalog.all })
    queryClient.invalidateQueries({ queryKey: ['books'] })
    toast.success('Book added successfully')
    setDrawerOpen(false)
  },
  onError: (error) => {
    toast.error(error instanceof ApiError ? error.detail ?? 'Failed to add book' : 'Failed to add book')
  },
})

const updateMutation = useMutation({
  mutationFn: (data: BookFormValues) => {
    const payload = {
      ...data,
      isbn: data.isbn || null,
      genre_id: typeof data.genre_id === 'number' ? data.genre_id : null,
      description: data.description || null,
      cover_image_url: data.cover_image_url || null,
      publish_date: data.publish_date || null,
    }
    return updateBook(accessToken, editingBook!.id, payload as BookUpdate)
  },
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: adminKeys.catalog.all })
    queryClient.invalidateQueries({ queryKey: ['books'] })
    toast.success('Book updated successfully')
    setDrawerOpen(false)
    setEditingBook(null)
  },
  onError: (error) => {
    toast.error(error instanceof ApiError ? error.detail ?? 'Failed to update book' : 'Failed to update book')
  },
})

const deleteMutation = useMutation({
  mutationFn: () => deleteBook(accessToken, deleteTarget!.id),
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: adminKeys.catalog.all })
    queryClient.invalidateQueries({ queryKey: ['books'] })
    toast.success('Book deleted successfully')
    setDeleteTarget(null)
  },
  onError: (error) => {
    toast.error(error instanceof ApiError ? error.detail ?? 'Failed to delete book' : 'Failed to delete book')
  },
})
```

Wire the action handlers in the column definitions' DropdownMenu:
- Edit: `setEditingBook(book); setDrawerOpen(true)`
- Delete: `setDeleteTarget(book)`
- Update Stock: `setStockTarget({ book_id: book.id, title: book.title, current_stock: book.stock_quantity })`

Wire the "Add Book" button: `setEditingBook(null); setDrawerOpen(true)`

Add the UI components to the page JSX:

1. **Sheet side drawer** for BookForm:
```jsx
<Sheet open={drawerOpen} onOpenChange={(open) => { if (!open) { setDrawerOpen(false); setEditingBook(null) } else { setDrawerOpen(true) } }}>
  <SheetContent side="right" className="sm:max-w-md overflow-y-auto">
    <SheetHeader>
      <SheetTitle>{editingBook ? 'Edit Book' : 'Add Book'}</SheetTitle>
      <SheetDescription>{editingBook ? 'Update book details' : 'Add a new book to the catalog'}</SheetDescription>
    </SheetHeader>
    <BookForm
      book={editingBook}
      genres={genresQuery.data ?? []}
      onSubmit={(data) => editingBook ? updateMutation.mutate(data) : createMutation.mutate(data)}
      onCancel={() => { setDrawerOpen(false); setEditingBook(null) }}
      isPending={createMutation.isPending || updateMutation.isPending}
    />
  </SheetContent>
</Sheet>
```

2. **ConfirmDialog** for delete:
```jsx
<ConfirmDialog
  open={deleteTarget !== null}
  onOpenChange={(open) => { if (!open) setDeleteTarget(null) }}
  title="Delete Book"
  description={`Are you sure you want to delete '${deleteTarget?.title}'? This action cannot be undone.`}
  confirmLabel="Delete"
  onConfirm={() => deleteMutation.mutate()}
  isPending={deleteMutation.isPending}
/>
```

3. **StockUpdateModal**:
```jsx
<StockUpdateModal
  open={stockTarget !== null}
  onOpenChange={(open) => { if (!open) setStockTarget(null) }}
  book={stockTarget}
  accessToken={accessToken}
/>
```

Import all required components: `BookForm`, `ConfirmDialog`, `StockUpdateModal`, `Sheet`/`SheetContent`/`SheetHeader`/`SheetTitle`/`SheetDescription` from sheet.tsx, `useMutation`/`useQueryClient` from TanStack Query, `toast` from sonner, `ApiError` from api.ts.

**Step 2: Update inventory/page.tsx** to use the shared `StockUpdateModal` component.

Replace the inline Dialog + stockMutation code in inventory/page.tsx with the shared `StockUpdateModal`:
1. Remove the inline `stockMutation`, the `newQuantity` state, and the `<Dialog>` JSX block for stock update
2. Import `StockUpdateModal` from `@/components/admin/StockUpdateModal`
3. Add `<StockUpdateModal open={selectedBook !== null} onOpenChange={(open) => { if (!open) setSelectedBook(null) }} book={selectedBook} accessToken={accessToken} />` at the end of the JSX
4. Keep the `selectedBook` state and the "Update Stock" button onClick that sets it — the StockUpdateModal reads from this same state shape

This refactoring means both the catalog page and inventory page share the same stock update UI with consistent behavior (pre-booking toast, cross-cache invalidation).
  </action>
  <verify>
    <automated>cd frontend && npx tsc --noEmit 2>&1 | head -20 && npm run build 2>&1 | tail -20</automated>
  </verify>
  <done>
    - "Add Book" button opens a side drawer with empty form; submission creates a book and shows success toast
    - Edit action opens side drawer pre-populated with book data; saving updates the book
    - Delete action opens confirmation dialog showing book title and "This action cannot be undone"; confirming deletes the book
    - Stock update action opens modal; saving from zero stock shows "pre-booking notifications sent" toast
    - All mutations invalidate adminKeys.catalog.all AND ['books'] for cross-cache consistency
    - Inventory page now uses the shared StockUpdateModal (no duplicate modal code)
    - Next.js build succeeds
  </done>
</task>

</tasks>

<verification>
1. `cd frontend && npx tsc --noEmit` — zero TypeScript errors
2. `cd frontend && npm run build` — production build succeeds
3. Grep check: `grep -r "BookForm" frontend/src/` confirms BookForm used in catalog page
4. Grep check: `grep -r "ConfirmDialog" frontend/src/` confirms ConfirmDialog used in catalog page
5. Grep check: `grep -r "StockUpdateModal" frontend/src/` confirms shared modal used in BOTH catalog and inventory pages
6. Grep check: `grep -r "invalidateQueries.*catalog" frontend/src/app/admin/catalog/` confirms admin cache invalidation
7. Grep check: `grep -r "invalidateQueries.*books" frontend/src/app/admin/catalog/` confirms customer cache invalidation
8. Grep check: `grep -r "pre-booking" frontend/src/components/admin/StockUpdateModal` confirms pre-booking toast logic
9. Grep check: `grep -r "react-hook-form\|useForm\|zodResolver" frontend/src/components/admin/BookForm` confirms form library usage
</verification>

<success_criteria>
- Admin can add a new book: opens side drawer, fills fields, sees inline validation errors for invalid input, submits, sees success toast, new book appears in table
- Admin can edit a book: clicks Edit in row menu, drawer opens pre-populated, changes fields, saves, table updates
- Admin can delete a book: clicks Delete in row menu, confirmation dialog shows title + warning, confirms, book removed, success toast
- Admin can update stock: clicks Update Stock in row menu, modal shows with current stock, enters new quantity, saves, gets appropriate toast (special text when restocking from zero)
- All mutations invalidate both admin and customer caches
- Inventory page uses the same StockUpdateModal component — no duplicate code
- BookForm handles zod validation with inline error messages under each field
</success_criteria>

<output>
After completion, create `.planning/phases/28-book-catalog-crud/28-02-SUMMARY.md`
</output>
