---
phase: 28-book-catalog-crud
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/lib/admin.ts
  - frontend/src/components/admin/DataTable.tsx
  - frontend/src/components/admin/AdminPagination.tsx
  - frontend/src/components/ui/dropdown-menu.tsx
  - frontend/src/app/admin/catalog/page.tsx
  - frontend/package.json
  - frontend/package-lock.json
autonomous: true
requirements: [CATL-01, CATL-02]

must_haves:
  truths:
    - "Admin sees a paginated catalog table with columns: Title, Author, Price, Genre, Stock, Actions"
    - "Admin can type in a search box and after 500ms debounce the table filters by matching text"
    - "Admin can select a genre from a dropdown and the table filters to only that genre"
    - "Admin can click Previous/Next to navigate pages of 20 books each"
    - "Row actions three-dot menu shows Edit, Delete, Update Stock options (wired in Plan 02)"
  artifacts:
    - path: "frontend/src/components/admin/DataTable.tsx"
      provides: "Generic TanStack Table wrapper for all admin tables"
      exports: ["DataTable"]
    - path: "frontend/src/components/admin/AdminPagination.tsx"
      provides: "Reusable prev/next pagination with page info"
      exports: ["AdminPagination"]
    - path: "frontend/src/lib/admin.ts"
      provides: "Extended adminKeys.catalog namespace and catalog fetch functions"
      contains: "adminKeys.catalog"
    - path: "frontend/src/app/admin/catalog/page.tsx"
      provides: "Full catalog CRUD page replacing placeholder"
    - path: "frontend/src/components/ui/dropdown-menu.tsx"
      provides: "shadcn DropdownMenu wrapper for row actions"
  key_links:
    - from: "frontend/src/app/admin/catalog/page.tsx"
      to: "frontend/src/lib/catalog.ts"
      via: "fetchBooks and fetchGenres for data"
      pattern: "fetchBooks\\("
    - from: "frontend/src/app/admin/catalog/page.tsx"
      to: "frontend/src/lib/admin.ts"
      via: "adminKeys.catalog.list for TanStack Query cache"
      pattern: "adminKeys\\.catalog"
    - from: "frontend/src/app/admin/catalog/page.tsx"
      to: "frontend/src/components/admin/DataTable.tsx"
      via: "DataTable component with column definitions"
      pattern: "<DataTable"
---

<objective>
Install TanStack Table and scaffold the reusable DataTable component, AdminPagination component, and DropdownMenu. Extend admin.ts with catalog query keys and fetch functions. Build the catalog page with paginated table, debounced search, and genre filter.

Purpose: Establish the foundational table infrastructure that Plan 02 (forms, dialogs, stock modal) builds upon, and that Phase 29 reuses directly.
Output: Working paginated catalog table at /admin/catalog with search and genre filter.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-book-catalog-crud/28-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From frontend/src/lib/api.ts:
```typescript
export class ApiError extends Error {
  constructor(message: string, public status: number, public detail?: string, public data?: unknown)
}
export async function apiFetch<T>(path: string, options?: RequestInit): Promise<T>
// Handles 204 No Content (returns undefined as T)
```

From frontend/src/lib/catalog.ts:
```typescript
export async function fetchBooks(params: {
  q?: string; genre_id?: number; min_price?: number; max_price?: number;
  sort?: string; sort_dir?: 'asc' | 'desc'; page?: number; size?: number;
}): Promise<BookListResponse>
export async function fetchGenres(): Promise<GenreResponse[]>
export type BookResponse = components['schemas']['BookResponse']
```

From frontend/src/types/api.generated.ts:
```typescript
BookResponse: {
  id: number; title: string; author: string; price: string;
  isbn: string | null; genre_id: number | null; description: string | null;
  cover_image_url: string | null; publish_date: string | null; stock_quantity: number;
}
BookListResponse: {
  items: BookResponse[]; total: number; page: number; size: number;
}
GenreResponse: { id: number; name: string; }
```

From frontend/src/lib/admin.ts (existing adminKeys):
```typescript
export const adminKeys = {
  all: ['admin'] as const,
  sales: { /* ... */ },
  inventory: { /* ... */ },
} as const
```

From frontend/src/app/admin/inventory/page.tsx (established patterns):
- useDebounce from 'use-debounce' for 500ms debounce
- useSession from 'next-auth/react' for accessToken
- useQuery + useMutation + useQueryClient from '@tanstack/react-query'
- StockBadge inline component (stock===0 red, stock<=threshold amber)
- HTML table with Tailwind classes (no shadcn table component installed)
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and scaffold DropdownMenu, extend admin.ts with catalog namespace</name>
  <files>
    frontend/package.json,
    frontend/package-lock.json,
    frontend/src/components/ui/dropdown-menu.tsx,
    frontend/src/lib/admin.ts
  </files>
  <action>
**Step 1: Install packages** (from frontend/ directory):
```bash
cd frontend
npm install @tanstack/react-table react-hook-form @hookform/resolvers
npx shadcn@latest add dropdown-menu --yes
```
- `@tanstack/react-table` ^8.x — headless table logic for DataTable.tsx
- `react-hook-form` ^7.x + `@hookform/resolvers` ^3.x — form state for Plan 02's BookForm
- `dropdown-menu.tsx` — shadcn wrapper for radix-ui DropdownMenu (radix-ui already installed)

Install react-hook-form and @hookform/resolvers now (even though they're used in Plan 02) to avoid a second install step later. This is a single `npm install` — trivial cost, prevents Plan 02 from needing to install mid-execution.

**Step 2: Extend admin.ts** — Add `catalog` namespace to `adminKeys` and add `createBook`, `updateBook`, `deleteBook` fetch functions. Do NOT add a `fetchAdminBooks` — the catalog page will use `fetchBooks` from `catalog.ts` directly (GET /books is a public endpoint, no auth needed for reading).

Add to adminKeys (after the `inventory` entry):
```typescript
catalog: {
  all: ['admin', 'catalog'] as const,
  list: (params: { q?: string; genre_id?: number; page?: number }) =>
    ['admin', 'catalog', 'list', params] as const,
  genres: ['admin', 'catalog', 'genres'] as const,
},
```

Add these fetch functions after `updateBookStock`:
```typescript
import type { components } from '@/types/api.generated'
type BookCreate = components['schemas']['BookCreate']
type BookUpdate = components['schemas']['BookUpdate']
type BookResponse = components['schemas']['BookResponse']

export async function createBook(
  accessToken: string,
  data: BookCreate
): Promise<BookResponse> {
  return apiFetch<BookResponse>('/books', {
    method: 'POST',
    body: JSON.stringify(data),
    headers: { Authorization: `Bearer ${accessToken}` },
  })
}

export async function updateBook(
  accessToken: string,
  bookId: number,
  data: BookUpdate
): Promise<BookResponse> {
  return apiFetch<BookResponse>(`/books/${bookId}`, {
    method: 'PUT',
    body: JSON.stringify(data),
    headers: { Authorization: `Bearer ${accessToken}` },
  })
}

export async function deleteBook(
  accessToken: string,
  bookId: number
): Promise<void> {
  return apiFetch<void>(`/books/${bookId}`, {
    method: 'DELETE',
    headers: { Authorization: `Bearer ${accessToken}` },
  })
}
```

Note: `apiFetch` already handles 204 No Content for DELETE (returns undefined as T). The `import { apiFetch } from '@/lib/api'` is already at the top of admin.ts.
  </action>
  <verify>
    <automated>cd frontend && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>
    - @tanstack/react-table, react-hook-form, @hookform/resolvers in package.json
    - dropdown-menu.tsx exists in components/ui/
    - adminKeys.catalog.all, adminKeys.catalog.list, adminKeys.catalog.genres accessible
    - createBook, updateBook, deleteBook functions exported from admin.ts
    - TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DataTable, AdminPagination, and build catalog page with search, filter, and pagination</name>
  <files>
    frontend/src/components/admin/DataTable.tsx,
    frontend/src/components/admin/AdminPagination.tsx,
    frontend/src/app/admin/catalog/page.tsx
  </files>
  <action>
**Step 1: Create DataTable.tsx** — Generic headless TanStack Table wrapper component.

```typescript
'use client'

import {
  useReactTable,
  getCoreRowModel,
  flexRender,
  type ColumnDef,
} from '@tanstack/react-table'
import { Skeleton } from '@/components/ui/skeleton'

interface DataTableProps<TData> {
  columns: ColumnDef<TData, unknown>[]
  data: TData[]
  isLoading?: boolean
  emptyMessage?: string
  loadingRows?: number
}

export function DataTable<TData>({ columns, data, isLoading, emptyMessage = 'No results found', loadingRows = 5 }: DataTableProps<TData>) {
  const table = useReactTable({
    data,
    columns,
    getCoreRowModel: getCoreRowModel(),
    manualPagination: true,
  })

  return (
    <div className="rounded-lg border">
      <table className="w-full text-sm">
        <thead>
          {table.getHeaderGroups().map((headerGroup) => (
            <tr key={headerGroup.id} className="border-b bg-muted/50">
              {headerGroup.headers.map((header) => (
                <th key={header.id} className="text-left text-muted-foreground font-medium py-2 px-4">
                  {header.isPlaceholder ? null : flexRender(header.column.columnDef.header, header.getContext())}
                </th>
              ))}
            </tr>
          ))}
        </thead>
        <tbody>
          {isLoading ? (
            // Loading skeleton rows
            Array.from({ length: loadingRows }).map((_, i) => (
              <tr key={i} className="border-t">
                {columns.map((_, j) => (
                  <td key={j} className="py-3 px-4">
                    <Skeleton className="h-4 w-full" />
                  </td>
                ))}
              </tr>
            ))
          ) : data.length === 0 ? (
            // Empty state
            <tr>
              <td colSpan={columns.length} className="py-8 px-4 text-center text-muted-foreground">
                {emptyMessage}
              </td>
            </tr>
          ) : (
            // Data rows
            table.getRowModel().rows.map((row) => (
              <tr key={row.id} className="border-t hover:bg-muted/30 transition-colors">
                {row.getVisibleCells().map((cell) => (
                  <td key={cell.id} className="py-3 px-4">
                    {flexRender(cell.column.columnDef.cell, cell.getContext())}
                  </td>
                ))}
              </tr>
            ))
          )}
        </tbody>
      </table>
    </div>
  )
}
```

Matches the HTML table + Tailwind pattern from inventory page (no shadcn table component). Generic `<TData>` for Phase 29 reuse. `manualPagination: true` since pagination is server-side.

**Step 2: Create AdminPagination.tsx** — Prev/next pagination with page count display.

```typescript
import { Button } from '@/components/ui/button'

interface AdminPaginationProps {
  page: number
  total: number
  size: number
  onPageChange: (page: number) => void
}

export function AdminPagination({ page, total, size, onPageChange }: AdminPaginationProps) {
  const totalPages = Math.ceil(total / size)
  const from = Math.min((page - 1) * size + 1, total)
  const to = Math.min(page * size, total)

  return (
    <div className="flex items-center justify-between text-sm text-muted-foreground">
      <span>Showing {from}–{to} of {total}</span>
      <div className="flex gap-2">
        <Button variant="outline" size="sm" disabled={page <= 1} onClick={() => onPageChange(page - 1)}>
          Previous
        </Button>
        <Button variant="outline" size="sm" disabled={page >= totalPages} onClick={() => onPageChange(page + 1)}>
          Next
        </Button>
      </div>
    </div>
  )
}
```

**Step 3: Replace catalog/page.tsx placeholder** with the full catalog page.

The catalog page is a `'use client'` component that:
1. Uses `useSession` for `accessToken` (needed for mutations in Plan 02, and for `fetchGenres` query key consistency)
2. Has `searchInput` state + `useDebounce(searchInput, 500)` for debounced search
3. Has `selectedGenre` state (number | undefined) for genre filter dropdown
4. Has `page` state (number, starting at 1) for pagination — resets to 1 when search or genre changes
5. Fetches books via `useQuery` with `queryKey: adminKeys.catalog.list({ q: debouncedSearch, genre_id: selectedGenre, page })` and `queryFn: () => fetchBooks({ q: debouncedSearch || undefined, genre_id: selectedGenre || undefined, page, size: 20 })`
6. Fetches genres via `useQuery` with `queryKey: adminKeys.catalog.genres` and `queryFn: fetchGenres`
7. Builds a `genreMap: Map<number, string>` from genres data for O(1) genre name lookup in table cells
8. Defines column definitions array for DataTable using `ColumnDef<BookResponse>[]`:
   - Title column: `accessorKey: 'title'`, bold font
   - Author column: `accessorKey: 'author'`, muted text
   - Price column: `accessorKey: 'price'`, right-aligned, formatted with `$` prefix
   - Genre column: custom cell using `genreMap.get(row.original.genre_id)` or "—" if null
   - Stock column: custom cell rendering a StockBadge-style display (stock===0 red Badge "Out of Stock", stock<=10 amber Badge "Low Stock (N)", else plain number) — inline helper, same pattern as inventory page
   - Actions column: `id: 'actions'`, renders a DropdownMenu with MoreHorizontal trigger button and three items: Edit, Delete (text-destructive), Update Stock. The action handlers are callback props (onEdit, onDelete, onUpdateStock) that will be wired in Plan 02. For now, define them as no-ops or `console.log` placeholders — Plan 02 replaces with real handlers.

Page layout:
- Header row: `<h1>Book Catalog</h1>` on the left, an "Add Book" `<Button>` on the right (onClick placeholder for Plan 02)
- Search/filter row: `<Input>` for search text (onChange -> setSearchInput, also reset page to 1), `<Select>` for genre filter with "All Genres" default option + fetched genres (onChange -> setSelectedGenre + reset page to 1)
- `<DataTable>` component with columns, data from booksQuery, isLoading, emptyMessage
- `<AdminPagination>` below the table with page, total, size from booksQuery.data, onPageChange -> setPage
- Error state: if booksQuery.isError, show error message with Retry button (same pattern as inventory page)

Important implementation details:
- Page state resets to 1 on search or genre change — use `useEffect` or inline in the onChange handlers
- `staleTime: 30_000` on the books query for reasonable caching
- The "Add Book" button and DropdownMenu action handlers are placeholder no-ops in this plan. Plan 02 wires them to real drawer/dialog state. Use `() => {}` or log statements so TypeScript is satisfied.
- Use `'use client'` directive at top of page.tsx
  </action>
  <verify>
    <automated>cd frontend && npx tsc --noEmit 2>&1 | head -20 && npm run build 2>&1 | tail -20</automated>
  </verify>
  <done>
    - DataTable.tsx renders header groups and body rows from TanStack Table with loading skeletons and empty state
    - AdminPagination.tsx shows "Showing X-Y of Z" with Previous/Next buttons, disabled at boundaries
    - /admin/catalog page shows paginated table of books with 6 columns
    - Search input debounces at 500ms and filters the table
    - Genre dropdown filters by genre, showing genre names (not IDs)
    - Pagination navigates pages of 20 books
    - Actions dropdown (⋮) shows Edit, Delete, Update Stock menu items
    - Next.js build succeeds with /admin/catalog as dynamic route
  </done>
</task>

</tasks>

<verification>
1. `cd frontend && npx tsc --noEmit` — zero TypeScript errors
2. `cd frontend && npm run build` — production build succeeds, /admin/catalog listed as dynamic route
3. Grep check: `grep -r "adminKeys.catalog" frontend/src/` confirms query key usage in catalog page
4. Grep check: `grep -r "DataTable" frontend/src/` confirms DataTable imported in catalog page
5. Grep check: `grep -r "AdminPagination" frontend/src/` confirms pagination wired
6. Grep check: `grep -r "DropdownMenu" frontend/src/app/admin/catalog/` confirms row actions menu
7. Grep check: `grep -r "useDebounce" frontend/src/app/admin/catalog/` confirms debounced search
</verification>

<success_criteria>
- Admin visiting /admin/catalog sees a table with Title, Author, Price, Genre, Stock, Actions columns
- Typing in the search box updates the table after 500ms debounce
- Selecting a genre from the dropdown filters the table
- Previous/Next buttons navigate pages; "Showing X-Y of Z" text updates
- Three-dot menu on each row shows Edit, Delete, Update Stock options
- DataTable.tsx is generic (accepts ColumnDef<TData>[]) — ready for Phase 29 reuse
- All dependencies installed: @tanstack/react-table, react-hook-form, @hookform/resolvers, dropdown-menu.tsx
</success_criteria>

<output>
After completion, create `.planning/phases/28-book-catalog-crud/28-01-SUMMARY.md`
</output>
