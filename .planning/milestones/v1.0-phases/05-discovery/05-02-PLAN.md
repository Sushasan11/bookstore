---
phase: 05-discovery
plan: "02"
type: execute
wave: 2
depends_on:
  - "05-01"
files_modified:
  - app/books/repository.py
  - app/books/schemas.py
  - app/books/service.py
  - app/books/router.py
autonomous: true
requirements:
  - DISC-01
  - DISC-02
  - DISC-03
  - DISC-04

must_haves:
  truths:
    - "GET /books with no params returns a paginated envelope with items, total, page, size"
    - "GET /books?sort=price returns books sorted by price ascending"
    - "GET /books?sort=date returns books sorted by publish_date ascending"
    - "GET /books?sort=created_at returns books sorted by created_at descending (newest first)"
    - "GET /books?q=tolkien returns books matching 'tolkien' in title or author via FTS"
    - "GET /books?q=tolk returns books matching the prefix 'tolk' (prefix matching)"
    - "GET /books?genre_id=1 returns only books in genre 1"
    - "GET /books?author=tolkien returns books with 'tolkien' in author (case-insensitive)"
    - "GET /books?q=tolkien&genre_id=1 combines FTS and genre filter with AND"
    - "GET /books/{id} returns book with in_stock boolean field (true if stock_quantity > 0)"
    - "GET /books/{id} still returns 404 for unknown book IDs"
  artifacts:
    - path: "app/books/repository.py"
      provides: "BookRepository.search() with FTS + filter + sort + pagination"
      contains: "_build_tsquery"
    - path: "app/books/schemas.py"
      provides: "BookDetailResponse (in_stock computed field) and BookListResponse (paginated envelope)"
      contains: "BookDetailResponse"
    - path: "app/books/service.py"
      provides: "BookService.list_books() delegating to BookRepository.search()"
      contains: "list_books"
    - path: "app/books/router.py"
      provides: "GET /books endpoint with q/genre_id/author/sort/page/size params; GET /books/{id} returning BookDetailResponse"
      contains: "BookListResponse"
  key_links:
    - from: "app/books/router.py"
      to: "app/books/service.py"
      via: "service.list_books(q=q, genre_id=genre_id, author=author, sort=sort, page=page, size=size)"
      pattern: "list_books"
    - from: "app/books/service.py"
      to: "app/books/repository.py"
      via: "self.book_repo.search(q=q, genre_id=genre_id, author=author, sort=sort, page=page, size=size)"
      pattern: "book_repo.search"
    - from: "app/books/repository.py"
      to: "Book.search_vector"
      via: "Book.search_vector.bool_op('@@')(func.to_tsquery('simple', tsquery_str))"
      pattern: "bool_op.*@@"
    - from: "app/books/schemas.py"
      to: "Book.stock_quantity"
      via: "BookDetailResponse.in_stock @computed_field returning self.stock_quantity > 0"
      pattern: "stock_quantity > 0"
---

<objective>
Implement the complete discovery service layer: BookRepository.search() with FTS + filters + sort + pagination; BookDetailResponse and BookListResponse schemas; BookService.list_books(); and updated router GET /books (new paginated endpoint) and GET /books/{id} (extended with in_stock field).

Purpose: This is the full implementation of DISC-01, DISC-02, DISC-03, and DISC-04. After this plan, all four discovery requirements are implemented end-to-end. Plan 03 adds the integration test coverage.

Output: Four modified source files. The GET /books endpoint changes from returning a flat list to returning a paginated envelope. GET /books/{id} is extended with in_stock boolean.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-discovery/05-CONTEXT.md
@.planning/phases/05-discovery/05-RESEARCH.md
@app/books/models.py
@app/books/repository.py
@app/books/schemas.py
@app/books/service.py
@app/books/router.py
@.planning/phases/05-discovery/05-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add _build_tsquery helper and BookRepository.search() method</name>
  <files>app/books/repository.py</files>
  <action>
Add a module-level `_build_tsquery` helper function and a `search()` async method to `BookRepository`.

**Add to the top of `app/books/repository.py`** (after existing imports, before GenreRepository):

```python
import re

from sqlalchemy import func, select


def _build_tsquery(q: str) -> str:
    """Convert raw user search input to a safe prefix tsquery string.

    Each whitespace-delimited token gets ':*' appended for prefix matching.
    Non-word, non-hyphen characters are stripped to prevent tsquery injection.

    Examples:
      'tolkien' -> 'tolkien:*'
      'lord rings' -> 'lord:* & rings:*'
      'C++ programming' -> 'C:* & programming:*'
      '' -> '' (caller skips FTS when empty)
    """
    tokens = re.split(r"\s+", q.strip())
    clean = [re.sub(r"[^\w-]", "", t, flags=re.UNICODE) for t in tokens if t]
    prefix_tokens = [f"{t}:*" for t in clean if t]
    return " & ".join(prefix_tokens)
```

**Add `search()` method to `BookRepository`** (after the existing `set_stock` method):

```python
async def search(
    self,
    *,
    q: str | None = None,
    genre_id: int | None = None,
    author: str | None = None,
    sort: str = "title",
    page: int = 1,
    size: int = 20,
) -> tuple[list[Book], int]:
    """Return (books, total_count) for the given search/filter/sort/page.

    When q is provided: filters by FTS match AND sorts by ts_rank DESC
      (relevance sort overrides the sort parameter — locked decision).
    When q is absent: sorts by the sort parameter.

    Sort values: 'title' (A-Z), 'price' (asc), 'date' (publish_date asc),
      'created_at' (desc — newest first). Tiebreaker: Book.id asc (stable pagination).

    genre_id and author filters combine with AND when both are provided.
    """
    stmt = select(Book)

    # FTS filter
    if q:
        tsquery_str = _build_tsquery(q)
        if tsquery_str:
            ts_query = func.to_tsquery("simple", tsquery_str)
            stmt = stmt.where(Book.search_vector.bool_op("@@")(ts_query))

    # Genre filter (exact match by ID — clients pick from GET /genres list)
    if genre_id is not None:
        stmt = stmt.where(Book.genre_id == genre_id)

    # Author filter (case-insensitive substring — covers "J.R.R. Tolkien" when searching "tolkien")
    if author:
        stmt = stmt.where(Book.author.ilike(f"%{author}%"))

    # Sort order
    if q:
        tsquery_str_for_rank = _build_tsquery(q)
        if tsquery_str_for_rank:
            ts_query_rank = func.to_tsquery("simple", tsquery_str_for_rank)
            stmt = stmt.order_by(
                func.ts_rank(Book.search_vector, ts_query_rank).desc(),
                Book.id,
            )
        # If tsquery_str is empty (all special chars stripped), fall through to default sort
        else:
            stmt = stmt.order_by(Book.title, Book.id)
    else:
        sort_map = {
            "title": (Book.title, Book.id),
            "price": (Book.price, Book.id),
            "date": (Book.publish_date, Book.id),
            "created_at": (Book.created_at.desc(), Book.id),
        }
        order_cols = sort_map.get(sort, (Book.title, Book.id))
        stmt = stmt.order_by(*order_cols)

    # Total count BEFORE pagination (reuses same filters)
    count_stmt = select(func.count()).select_from(stmt.subquery())
    total = await self.session.scalar(count_stmt)

    # Apply pagination
    offset = (page - 1) * size
    stmt = stmt.limit(size).offset(offset)

    result = await self.session.execute(stmt)
    books = list(result.scalars().all())

    return books, total or 0
```

**Important implementation notes:**
- `Book.id` as secondary sort column on every sort path ensures stable offset pagination (avoids duplicates across pages).
- `created_at` sort is DESC (newest first) — this is the natural expectation for "newly added" browsing.
- The count query reuses the same `stmt` with all filters applied (via `.subquery()`) — avoids duplicating filter logic.
- Do NOT use lazy-loaded `book.genre.name` in this method — genre is not needed in list response; `genre_id` is included in `BookResponse` and clients resolve names from the cached `/genres` list.
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && poetry run python -c "from app.books.repository import BookRepository, _build_tsquery; print(_build_tsquery('tolkien rings')); print(_build_tsquery('C++')); print('OK')"</automated>
    <manual>
      Confirm output:
        tolkien:* &amp; rings:*
        C:*
        OK
    </manual>
  </verify>
  <done>
    - `_build_tsquery` function present in module scope, handles special chars and multi-word input
    - `BookRepository.search()` method exists with all parameters (q, genre_id, author, sort, page, size)
    - Method returns `tuple[list[Book], int]`
    - `from app.books.repository import BookRepository, _build_tsquery` imports without error
  </done>
</task>

<task type="auto">
  <name>Task 2: Add BookDetailResponse and BookListResponse schemas; add BookService.list_books(); update router</name>
  <files>
    app/books/schemas.py
    app/books/service.py
    app/books/router.py
  </files>
  <action>
Three coordinated changes to wire the discovery layer end-to-end.

**A. Update `app/books/schemas.py`**

Add these two schemas after the existing `BookResponse` class:

```python
from pydantic import BaseModel, computed_field, Field, field_validator
```
(Add `computed_field` to the existing pydantic import.)

```python
class BookDetailResponse(BaseModel):
    """Response for GET /books/{id} — extends BookResponse with computed in_stock field.

    in_stock is a derived boolean (stock_quantity > 0) — not stored in DB.
    stock_quantity is still included for admin-facing clients that need the exact count.
    """

    id: int
    title: str
    author: str
    price: Decimal
    isbn: str | None
    genre_id: int | None
    description: str | None
    cover_image_url: str | None
    publish_date: date | None
    stock_quantity: int

    @computed_field  # type: ignore[misc]
    @property
    def in_stock(self) -> bool:
        """True when at least one copy is available."""
        return self.stock_quantity > 0

    model_config = {"from_attributes": True}


class BookListResponse(BaseModel):
    """Paginated book list response envelope for GET /books."""

    items: list[BookResponse]
    total: int
    page: int
    size: int
```

**B. Update `app/books/service.py`**

Add `list_books()` method to `BookService` after `set_stock`:

```python
async def list_books(
    self,
    *,
    q: str | None = None,
    genre_id: int | None = None,
    author: str | None = None,
    sort: str = "title",
    page: int = 1,
    size: int = 20,
) -> tuple[list[Book], int]:
    """Browse catalog with optional FTS search, genre/author filters, sort, and pagination.

    Delegates entirely to BookRepository.search() — no additional business logic.
    Returns (books, total_count) for the route to wrap in BookListResponse.
    """
    return await self.book_repo.search(
        q=q,
        genre_id=genre_id,
        author=author,
        sort=sort,
        page=page,
        size=size,
    )
```

**C. Update `app/books/router.py`**

1. Add new imports at the top:
   ```python
   from typing import Literal
   from fastapi import APIRouter, Query, status
   from app.books.schemas import (
       BookCreate,
       BookDetailResponse,
       BookListResponse,
       BookResponse,
       BookUpdate,
       GenreCreate,
       GenreResponse,
       StockUpdate,
   )
   ```

2. Add a new `GET /books` endpoint BEFORE the existing `GET /books/{book_id}` endpoint (path ordering matters — `/books` must appear before `/books/{book_id}` in FastAPI router registration):

   ```python
   @router.get("/books", response_model=BookListResponse)
   async def list_books(
       db: DbSession,
       q: str | None = Query(None, description="Full-text search across title and author"),
       genre_id: int | None = Query(None, description="Filter by genre ID (from GET /genres)"),
       author: str | None = Query(None, description="Filter by author name (case-insensitive partial match)"),
       sort: Literal["title", "price", "date", "created_at"] = Query(
           "title", description="Sort order: title (A-Z), price (asc), date (publish_date asc), created_at (newest first)"
       ),
       page: int = Query(1, ge=1, description="Page number, 1-indexed"),
       size: int = Query(20, ge=1, le=100, description="Items per page (max 100)"),
   ) -> BookListResponse:
       """Browse the book catalog. Public — no auth required.

       Supports pagination (page/size), sorting (sort), full-text search (q),
       and filtering by genre (genre_id) and author. Filters combine with AND.

       When q is present, results are sorted by relevance (ts_rank) regardless of sort param.
       """
       service = _make_service(db)
       books, total = await service.list_books(
           q=q,
           genre_id=genre_id,
           author=author,
           sort=sort,
           page=page,
           size=size,
       )
       return BookListResponse(
           items=[BookResponse.model_validate(b) for b in books],
           total=total,
           page=page,
           size=size,
       )
   ```

3. Update the existing `GET /books/{book_id}` endpoint to return `BookDetailResponse`:
   ```python
   @router.get("/books/{book_id}", response_model=BookDetailResponse)
   async def get_book(book_id: int, db: DbSession) -> BookDetailResponse:
       """Get book by ID including stock status. Public — no auth required.

       Returns in_stock boolean (true when stock_quantity > 0).
       404 if book not found.
       """
       service = _make_service(db)
       book = await service._get_book_or_404(book_id)
       return BookDetailResponse.model_validate(book)
   ```

IMPORTANT: The `GET /books` route must be registered BEFORE `GET /books/{book_id}` in the file. FastAPI uses first-match routing, so `/books` as a literal path needs to appear before the parameterized `/books/{book_id}`.
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && poetry run python -c "from app.books.schemas import BookDetailResponse, BookListResponse; r = BookDetailResponse(id=1, title='t', author='a', price='9.99', isbn=None, genre_id=None, description=None, cover_image_url=None, publish_date=None, stock_quantity=5); print('in_stock:', r.in_stock); r2 = BookDetailResponse(id=2, title='t', author='a', price='9.99', isbn=None, genre_id=None, description=None, cover_image_url=None, publish_date=None, stock_quantity=0); print('out_of_stock:', r2.in_stock)"</automated>
    <manual>
      Confirm output:
        in_stock: True
        out_of_stock: False
    </manual>
  </verify>
  <done>
    - `BookDetailResponse` exists in schemas.py with `in_stock` @computed_field returning `self.stock_quantity > 0`
    - `BookListResponse` exists in schemas.py with `items: list[BookResponse]`, `total`, `page`, `size`
    - `BookService.list_books()` delegates to `self.book_repo.search()` with all params
    - `GET /books` route exists in router.py with q/genre_id/author/sort/page/size Query params, returns BookListResponse
    - `GET /books/{book_id}` route updated to return `BookDetailResponse` (not `BookResponse`)
    - `GET /books` route appears BEFORE `GET /books/{book_id}` in router.py
    - `from app.books.router import router` imports without error
    - `poetry run task test` passes all existing tests (regression check)
  </done>
</task>

</tasks>

<verification>
Run the full test suite to confirm no regression from the router and schema changes:

```bash
cd D:/Python/claude-test && poetry run task test
```

All Phase 2, 3, and 4 tests should still pass. The `GET /books/{id}` now returns `BookDetailResponse` instead of `BookResponse` — but `BookDetailResponse` is a superset (adds `in_stock`), so existing catalog tests checking `GET /books/{id}` should still pass (additional field is additive, not breaking).

Quick smoke test of the new schema:
```bash
poetry run python -c "
from app.books.schemas import BookDetailResponse, BookListResponse, BookResponse
from decimal import Decimal
b = BookDetailResponse(id=1, title='Dune', author='Herbert', price=Decimal('12.99'), isbn=None, genre_id=None, description=None, cover_image_url=None, publish_date=None, stock_quantity=10)
print('in_stock:', b.in_stock)
bl = BookListResponse(items=[], total=0, page=1, size=20)
print('list schema OK:', bl.total)
"
```
</verification>

<success_criteria>
- `BookDetailResponse.in_stock` returns True when stock_quantity > 0, False when 0
- `BookListResponse` wraps `items: list[BookResponse]` with pagination metadata
- `BookService.list_books()` exists and delegates to `BookRepository.search()`
- `GET /books` endpoint accepts q, genre_id, author, sort, page, size query params
- `GET /books/{id}` returns BookDetailResponse (with in_stock field)
- `poetry run task test` passes all existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/05-discovery/05-02-SUMMARY.md` following the summary template.
</output>
