---
phase: 03-oauth
plan: 03
type: execute
wave: 3
depends_on:
  - 03-02
files_modified:
  - tests/test_oauth.py
autonomous: true
requirements:
  - AUTH-06

must_haves:
  truths:
    - "Google login redirect returns a redirect response to Google's OAuth URL"
    - "Google callback with valid OAuth data returns JWT access + refresh tokens"
    - "GitHub login redirect returns a redirect response to GitHub's OAuth URL"
    - "GitHub callback with valid OAuth data returns JWT access + refresh tokens"
    - "OAuth email matching existing user links to that account (no duplicate)"
    - "OAuth-only user has no password (hashed_password is None)"
    - "Repeated OAuth login with same provider identity is idempotent"
    - "OAuth-only user attempting password login gets a clear 400 error"
  artifacts:
    - path: "tests/test_oauth.py"
      provides: "Integration tests covering all AUTH-06 sub-requirements"
      min_lines: 100
  key_links:
    - from: "tests/test_oauth.py"
      to: "app/users/router.py"
      via: "httpx AsyncClient hitting /auth/google, /auth/github, callbacks"
      pattern: "client\\.(get|post).*auth/(google|github)"
    - from: "tests/test_oauth.py"
      to: "app/core/oauth.py"
      via: "monkeypatch/mock of oauth.google and oauth.github to simulate provider responses"
      pattern: "mock.*oauth\\.(google|github)"
---

<objective>
Create comprehensive integration tests for all OAuth flows, mocking Authlib's OAuth client to simulate Google and GitHub provider responses without real OAuth credentials.

Purpose: Validates AUTH-06 requirement across all sub-behaviors: redirect, callback token issuance, account linking, OAuth-only users, duplicate handling, and password login guard.
Output: tests/test_oauth.py with 8+ test cases covering the complete OAuth surface.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@D:/Python/claude-test/.planning/ROADMAP.md
@D:/Python/claude-test/.planning/STATE.md
@D:/Python/claude-test/.planning/phases/03-oauth/03-RESEARCH.md
@D:/Python/claude-test/.planning/phases/03-oauth/03-01-SUMMARY.md
@D:/Python/claude-test/.planning/phases/03-oauth/03-02-SUMMARY.md
@D:/Python/claude-test/tests/conftest.py
@D:/Python/claude-test/tests/test_auth.py
@D:/Python/claude-test/app/users/router.py
@D:/Python/claude-test/app/core/oauth.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create OAuth integration tests with mocked Authlib providers</name>
  <files>
    tests/test_oauth.py
  </files>
  <action>
Create `tests/test_oauth.py` with comprehensive OAuth tests. The key challenge is mocking Authlib's OAuth client so tests run without real OAuth credentials.

**Mocking strategy:**
- Mock `oauth.google.authorize_redirect` to return a redirect response without actually contacting Google
- Mock `oauth.google.authorize_access_token` to return a fake token dict with userinfo (simulating Google OIDC)
- Mock `oauth.github.authorize_redirect` similarly for GitHub
- Mock `oauth.github.authorize_access_token` to return a fake token dict (no userinfo -- GitHub is not OIDC)
- Mock `oauth.github.get` to return fake user profile and emails responses

Use `unittest.mock.AsyncMock` and `pytest.monkeypatch` or `unittest.mock.patch` to replace the Authlib client methods.

**Test classes and cases:**

```python
import pytest
from unittest.mock import AsyncMock, MagicMock, patch
from httpx import AsyncClient

# --- Fixtures ---

# Fixture: mock_google_oauth -- patches oauth.google methods
# Returns a dict with authorize_redirect (AsyncMock returning RedirectResponse)
# and authorize_access_token (AsyncMock returning fake token with userinfo)

# Fixture: mock_github_oauth -- patches oauth.github methods
# Returns a dict with authorize_redirect, authorize_access_token, and get (for /user and /user/emails)

# --- TestGoogleOAuth ---

class TestGoogleOAuth:

    async def test_google_login_redirects(self, client, mock_google_oauth):
        """GET /auth/google returns a redirect response."""
        # The mock authorize_redirect should return a RedirectResponse to a Google URL.
        # Assert response status is 302 or 307 (redirect).
        # Assert Location header contains accounts.google.com.

    async def test_google_callback_returns_tokens(self, client, db_session, mock_google_oauth):
        """GET /auth/google/callback with valid OAuth returns JWT tokens."""
        # Mock authorize_access_token returns {"userinfo": {"sub": "google-123", "email": "oauth@test.com", "email_verified": True}}
        # Hit /auth/google/callback
        # Assert 200 with access_token, refresh_token, token_type="bearer"
        # Decode access_token and verify sub contains a user ID

    async def test_google_callback_unverified_email_rejected(self, client, mock_google_oauth):
        """Google OAuth with unverified email returns 401."""
        # Mock authorize_access_token returns userinfo with email_verified=False
        # Assert 401 with AUTH_OAUTH_EMAIL_UNVERIFIED code

    async def test_google_callback_no_email_rejected(self, client, mock_google_oauth):
        """Google OAuth with no email in userinfo returns 401."""
        # Mock authorize_access_token returns userinfo without email
        # Assert 401 with AUTH_OAUTH_NO_EMAIL code


# --- TestGitHubOAuth ---

class TestGitHubOAuth:

    async def test_github_login_redirects(self, client, mock_github_oauth):
        """GET /auth/github returns a redirect response."""
        # Similar to Google -- assert redirect to github.com

    async def test_github_callback_returns_tokens(self, client, db_session, mock_github_oauth):
        """GET /auth/github/callback with valid OAuth returns JWT tokens."""
        # Mock authorize_access_token returns a token
        # Mock oauth.github.get("user") returns {"id": 456, "email": "ghuser@test.com"}
        # Assert 200 with access_token, refresh_token

    async def test_github_callback_private_email(self, client, db_session, mock_github_oauth):
        """GitHub callback fetches email from /user/emails when profile email is null."""
        # Mock oauth.github.get("user") returns {"id": 789, "email": null}
        # Mock oauth.github.get("user/emails") returns [{"email": "private@test.com", "primary": true, "verified": true}]
        # Assert 200 with tokens

    async def test_github_callback_no_verified_email(self, client, mock_github_oauth):
        """GitHub callback with no verified email returns 401."""
        # Mock get("user") returns {"id": 999, "email": null}
        # Mock get("user/emails") returns [{"email": "unverified@test.com", "primary": true, "verified": false}]
        # Assert 401 with AUTH_OAUTH_NO_EMAIL


# --- TestAccountLinking ---

class TestAccountLinking:

    async def test_oauth_links_existing_email(self, client, db_session, mock_google_oauth):
        """OAuth login with email matching existing user links to that account."""
        # First, register a user via POST /auth/register with email "existing@test.com"
        # Then mock Google callback returning email "existing@test.com", sub "google-existing"
        # Hit /auth/google/callback
        # Verify: same user (decode JWT sub matches first registration)
        # Verify: no second user created (query db for user count or check by email uniqueness)

    async def test_oauth_user_no_password(self, client, db_session, mock_google_oauth):
        """OAuth-only user has hashed_password=None."""
        # Mock Google callback for a new email "newuser@test.com"
        # Hit /auth/google/callback
        # Query the User from DB by email
        # Assert user.hashed_password is None

    async def test_duplicate_oauth_login(self, client, db_session, mock_google_oauth):
        """Logging in via the same OAuth identity twice is idempotent."""
        # Mock Google callback with same sub "google-repeat" and email "repeat@test.com"
        # Hit /auth/google/callback twice
        # Both return 200 with tokens
        # Only one User exists in DB with that email
        # Only one OAuthAccount row exists for ("google", "google-repeat")

    async def test_oauth_user_password_login_rejected(self, client, db_session, mock_google_oauth):
        """OAuth-only user trying to log in with password gets 400 error."""
        # Create user via Google OAuth (no password)
        # Try POST /auth/login with that email and any password
        # Assert 400 with code AUTH_OAUTH_ONLY_ACCOUNT
```

**Implementation notes:**
- Use the existing `client` and `db_session` fixtures from conftest.py
- For mocking Authlib, use `unittest.mock.patch.object` on the `oauth` instance imported from `app.core.oauth`
- When mocking `oauth.github.get`, the mock needs to return different responses based on the URL argument ("user" vs "user/emails"). Use `side_effect` to dispatch based on the first argument.
- For the mock response from `oauth.github.get`, create a mock object with `.raise_for_status()` method and `.json()` method returning the desired data.
- Follow the existing test conventions: `pytest.mark.anyio` or asyncio_mode auto, use the project's conftest fixtures.
- Read `tests/conftest.py` and `tests/test_auth.py` for exact fixture names and patterns before writing tests.
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && poetry run pytest tests/test_oauth.py -v -x</automated>
    <manual>Verify each test case name matches the behaviors listed above</manual>
  </verify>
  <done>tests/test_oauth.py exists with 10+ test cases. All tests pass. Coverage includes: Google redirect, Google callback with tokens, Google unverified email rejection, Google no-email rejection, GitHub redirect, GitHub callback with tokens, GitHub private email handling, GitHub no verified email rejection, account linking to existing user, OAuth-only user has no password, duplicate OAuth login idempotent, OAuth-only user rejected from password login.</done>
</task>

<task type="auto">
  <name>Task 2: Run full test suite and verify all tests pass</name>
  <files></files>
  <action>
1. Run the complete test suite to verify no regressions:
   ```
   poetry run task test
   ```
   Or equivalently:
   ```
   poetry run pytest tests/ -v
   ```

2. Run ruff check on the entire project:
   ```
   poetry run ruff check app/ tests/
   ```

3. If any existing tests fail due to the hashed_password nullable change or the AuthService constructor change:
   - The AuthService constructor change is backward-compatible (oauth_repo is optional with default None), so existing tests should NOT break.
   - If any test creates a User directly with hashed_password, it should still work since the column is nullable (both None and a string value are valid).
   - Fix any issues found.

4. Verify test count: should be at least 30+ tests total (20 existing auth + 10+ new OAuth tests).
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && poetry run pytest tests/ -v --tb=short && poetry run ruff check app/ tests/</automated>
    <manual>Confirm total test count includes both existing and new OAuth tests</manual>
  </verify>
  <done>Full test suite passes with zero failures. Ruff reports zero violations. Total test count is 30+ (existing auth tests + new OAuth tests). No regressions from Phase 2 changes.</done>
</task>

</tasks>

<verification>
1. `poetry run pytest tests/test_oauth.py -v` -- all OAuth tests pass
2. `poetry run pytest tests/ -v` -- full suite passes (no regressions)
3. `poetry run ruff check app/ tests/` -- zero violations
4. Test coverage includes: redirect flows, callback token issuance, account linking, OAuth-only users, duplicate handling, error cases
</verification>

<success_criteria>
- tests/test_oauth.py exists with 10+ test cases
- All OAuth test cases pass
- All existing tests still pass (no regressions from nullable password or AuthService changes)
- Ruff check clean across entire project
- AUTH-06 fully covered: Google login, GitHub login, JWT token pair returned, account linking by email
</success_criteria>

<output>
After completion, create `.planning/phases/03-oauth/03-03-SUMMARY.md`
</output>
