---
phase: 03-oauth
plan: 02
type: execute
wave: 2
depends_on:
  - 03-01
files_modified:
  - app/users/repository.py
  - app/users/service.py
  - app/users/router.py
autonomous: true
requirements:
  - AUTH-06

must_haves:
  truths:
    - "User can initiate Google OAuth via GET /auth/google and be redirected to Google consent screen"
    - "User can initiate GitHub OAuth via GET /auth/github and be redirected to GitHub authorization screen"
    - "After completing OAuth flow, user receives JWT access + refresh token pair"
    - "If OAuth email matches existing account, OAuth login authenticates to that existing account"
    - "OAuth-only user trying password login gets a clear error, not a crash"
  artifacts:
    - path: "app/users/repository.py"
      provides: "OAuthAccountRepository with get_by_provider_and_id and create methods; UserRepository.create_oauth_user for passwordless users"
      contains: "class OAuthAccountRepository"
    - path: "app/users/service.py"
      provides: "AuthService.oauth_login() method for provider-based authentication"
      contains: "async def oauth_login"
    - path: "app/users/router.py"
      provides: "GET /auth/google, /auth/google/callback, /auth/github, /auth/github/callback endpoints"
      contains: "google_callback"
  key_links:
    - from: "app/users/router.py"
      to: "app/core/oauth.py"
      via: "import oauth instance for authorize_redirect and authorize_access_token"
      pattern: "from app.core.oauth import oauth"
    - from: "app/users/router.py"
      to: "app/users/service.py"
      via: "AuthService.oauth_login() called from callback endpoints"
      pattern: "service\\.oauth_login"
    - from: "app/users/service.py"
      to: "app/users/repository.py"
      via: "OAuthAccountRepository for link lookup/creation, UserRepository for user lookup/creation"
      pattern: "oauth_repo\\.get_by_provider_and_id"
    - from: "app/users/service.py"
      to: "app/core/security.py"
      via: "create_access_token and generate_refresh_token for JWT issuance (same as email/password)"
      pattern: "create_access_token"
---

<objective>
Add the OAuth account repository, AuthService.oauth_login() method, login guard for OAuth-only users, and the four OAuth endpoints (Google redirect + callback, GitHub redirect + callback) to produce JWT tokens identical to email/password login.

Purpose: Completes the OAuth authentication flow so users can actually log in with Google or GitHub and receive JWT tokens.
Output: Updated repository.py, service.py, and router.py with full OAuth support.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@D:/Python/claude-test/.planning/ROADMAP.md
@D:/Python/claude-test/.planning/STATE.md
@D:/Python/claude-test/.planning/phases/03-oauth/03-RESEARCH.md
@D:/Python/claude-test/.planning/phases/03-oauth/03-01-SUMMARY.md
@D:/Python/claude-test/app/users/repository.py
@D:/Python/claude-test/app/users/service.py
@D:/Python/claude-test/app/users/router.py
@D:/Python/claude-test/app/core/security.py
@D:/Python/claude-test/app/core/exceptions.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add OAuthAccountRepository, UserRepository.create_oauth_user, and AuthService.oauth_login</name>
  <files>
    app/users/repository.py
    app/users/service.py
  </files>
  <action>
1. In `app/users/repository.py`:

   a. Add import for OAuthAccount model:
      ```python
      from app.users.models import OAuthAccount, RefreshToken, User, UserRole
      ```

   b. Add `create_oauth_user` method to `UserRepository` (after existing `create` method):
      ```python
      async def create_oauth_user(self, email: str) -> User:
          """Create a new user without a password (OAuth-only).
          Default role=USER, hashed_password=None."""
          user = User(email=email, hashed_password=None)
          self.session.add(user)
          await self.session.flush()
          return user
      ```

   c. Add `OAuthAccountRepository` class (after `RefreshTokenRepository`):
      ```python
      class OAuthAccountRepository:
          def __init__(self, session: AsyncSession) -> None:
              self.session = session

          async def get_by_provider_and_id(
              self, provider: str, provider_account_id: str
          ) -> OAuthAccount | None:
              result = await self.session.execute(
                  select(OAuthAccount).where(
                      OAuthAccount.oauth_provider == provider,
                      OAuthAccount.oauth_account_id == provider_account_id,
                  )
              )
              return result.scalar_one_or_none()

          async def create(
              self, user_id: int, oauth_provider: str, oauth_account_id: str
          ) -> OAuthAccount:
              account = OAuthAccount(
                  user_id=user_id,
                  oauth_provider=oauth_provider,
                  oauth_account_id=oauth_account_id,
              )
              self.session.add(account)
              await self.session.flush()
              return account
      ```

2. In `app/users/service.py`:

   a. Add import for OAuthAccountRepository:
      ```python
      from app.users.repository import OAuthAccountRepository, RefreshTokenRepository, UserRepository
      ```

   b. Update `AuthService.__init__` to accept an optional `oauth_repo` parameter:
      ```python
      def __init__(
          self,
          user_repo: UserRepository,
          rt_repo: RefreshTokenRepository,
          oauth_repo: OAuthAccountRepository | None = None,
      ) -> None:
          self.user_repo = user_repo
          self.rt_repo = rt_repo
          self.oauth_repo = oauth_repo
      ```
      Making it optional preserves backward compatibility with existing code that creates AuthService without it.

   c. In the existing `login` method, add a guard AFTER finding the user by email and BEFORE `verify_password`. If the user has no password (OAuth-only), raise a clear error:
      ```python
      if user.hashed_password is None:
          raise AppError(
              status_code=400,
              detail="This account uses social login. Please log in with Google or GitHub.",
              code="AUTH_OAUTH_ONLY_ACCOUNT",
          )
      ```

   d. Add `oauth_login` method to `AuthService` (after `logout` method):
      ```python
      async def oauth_login(
          self, provider: str, provider_user_id: str, email: str
      ) -> tuple[str, str]:
          """Authenticate via OAuth. Links to existing account if email matches.
          Returns (access_token, refresh_token)."""
          if self.oauth_repo is None:
              raise AppError(
                  status_code=500,
                  detail="OAuth not configured",
                  code="AUTH_OAUTH_NOT_CONFIGURED",
              )

          # 1. Check if this OAuth identity already exists
          oauth_account = await self.oauth_repo.get_by_provider_and_id(
              provider, provider_user_id
          )
          if oauth_account:
              user = await self.user_repo.get_by_id(oauth_account.user_id)
          else:
              # 2. Check if email matches existing user
              user = await self.user_repo.get_by_email(email)
              if not user:
                  # 3. Create new user (no password -- OAuth-only)
                  user = await self.user_repo.create_oauth_user(email=email)
              # 4. Link OAuth identity to user
              await self.oauth_repo.create(
                  user_id=user.id,
                  oauth_provider=provider,
                  oauth_account_id=provider_user_id,
              )

          if user is None or not user.is_active:
              raise AppError(
                  status_code=401,
                  detail="User not found or inactive",
                  code="AUTH_USER_INACTIVE",
              )

          # 5. Issue same JWT token pair as email/password login
          access_token = create_access_token(user.id, user.role.value)
          raw_rt = generate_refresh_token()
          await self.rt_repo.create(raw_rt, user.id)
          return access_token, raw_rt
      ```
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && poetry run python -c "from app.users.repository import OAuthAccountRepository; from app.users.service import AuthService; print('imports OK')" && poetry run ruff check app/users/repository.py app/users/service.py</automated>
    <manual>Verify oauth_login method correctly handles: existing OAuth link, email match with existing user, brand new user</manual>
  </verify>
  <done>OAuthAccountRepository has get_by_provider_and_id and create. UserRepository has create_oauth_user. AuthService has oauth_login with 3-path logic (existing link / email match / new user). Login guards OAuth-only users from password login with clear error message.</done>
</task>

<task type="auto">
  <name>Task 2: Add OAuth redirect and callback endpoints for Google and GitHub</name>
  <files>
    app/users/router.py
  </files>
  <action>
1. In `app/users/router.py`, add new imports:
   ```python
   from authlib.integrations.starlette_client import OAuthError
   from starlette.requests import Request
   from starlette.responses import RedirectResponse

   from app.core.exceptions import AppError
   from app.core.oauth import oauth
   from app.users.repository import OAuthAccountRepository, RefreshTokenRepository, UserRepository
   ```

2. Update `_make_service` to include `OAuthAccountRepository`:
   ```python
   def _make_service(db: DbSession) -> AuthService:
       return AuthService(
           user_repo=UserRepository(db),
           rt_repo=RefreshTokenRepository(db),
           oauth_repo=OAuthAccountRepository(db),
       )
   ```

3. Add Google OAuth endpoints (after the existing `logout` endpoint):

   ```python
   @router.get("/google")
   async def google_login(request: Request):
       """Redirect to Google's consent screen for OAuth login."""
       redirect_uri = request.url_for("google_callback")
       return await oauth.google.authorize_redirect(request, redirect_uri)

   @router.get("/google/callback", response_model=TokenResponse)
   async def google_callback(request: Request, db: DbSession) -> TokenResponse:
       """Handle Google's OAuth callback. Returns JWT token pair."""
       try:
           token = await oauth.google.authorize_access_token(request)
       except OAuthError as e:
           raise AppError(
               status_code=401,
               detail=f"Google authentication failed: {e.description}",
               code="AUTH_OAUTH_FAILED",
           )

       userinfo = token.get("userinfo")
       if not userinfo or not userinfo.get("email"):
           raise AppError(
               status_code=401,
               detail="Could not retrieve email from Google",
               code="AUTH_OAUTH_NO_EMAIL",
           )

       if not userinfo.get("email_verified"):
           raise AppError(
               status_code=401,
               detail="Google email is not verified",
               code="AUTH_OAUTH_EMAIL_UNVERIFIED",
           )

       service = _make_service(db)
       access_token, refresh_token = await service.oauth_login(
           provider="google",
           provider_user_id=userinfo["sub"],
           email=userinfo["email"],
       )
       return TokenResponse(access_token=access_token, refresh_token=refresh_token)
   ```

4. Add GitHub OAuth endpoints:

   ```python
   @router.get("/github")
   async def github_login(request: Request):
       """Redirect to GitHub's authorization screen for OAuth login."""
       redirect_uri = request.url_for("github_callback")
       return await oauth.github.authorize_redirect(request, redirect_uri)

   @router.get("/github/callback", response_model=TokenResponse)
   async def github_callback(request: Request, db: DbSession) -> TokenResponse:
       """Handle GitHub's OAuth callback. Returns JWT token pair.

       GitHub does not support OIDC, so we must fetch user info via API calls.
       Email may be null if user has private email -- fetch from /user/emails.
       """
       try:
           token = await oauth.github.authorize_access_token(request)
       except OAuthError as e:
           raise AppError(
               status_code=401,
               detail=f"GitHub authentication failed: {e.description}",
               code="AUTH_OAUTH_FAILED",
           )

       # Fetch user profile
       resp = await oauth.github.get("user", token=token)
       resp.raise_for_status()
       profile = resp.json()
       provider_user_id = str(profile["id"])

       # Email may be null if user has private email settings
       email = profile.get("email")
       if not email:
           email_resp = await oauth.github.get("user/emails", token=token)
           email_resp.raise_for_status()
           emails = email_resp.json()
           primary = next(
               (e for e in emails if e["primary"] and e["verified"]),
               None,
           )
           if primary:
               email = primary["email"]

       if not email:
           raise AppError(
               status_code=401,
               detail="Could not retrieve a verified email from GitHub",
               code="AUTH_OAUTH_NO_EMAIL",
           )

       service = _make_service(db)
       access_token, refresh_token = await service.oauth_login(
           provider="github",
           provider_user_id=provider_user_id,
           email=email,
       )
       return TokenResponse(access_token=access_token, refresh_token=refresh_token)
   ```

Note: The `RedirectResponse` import may not be explicitly used since `authorize_redirect` returns the response directly, but import it for type clarity. If ruff flags it as unused, remove the import.
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && poetry run python -c "from app.users.router import router; routes = [r.path for r in router.routes]; assert '/google' in routes; assert '/google/callback' in routes; assert '/github' in routes; assert '/github/callback' in routes; print('All 4 OAuth routes registered')" && poetry run ruff check app/users/router.py && poetry run task test</automated>
    <manual>Verify all 4 new endpoints appear in the router, existing tests still pass</manual>
  </verify>
  <done>GET /auth/google and /auth/github redirect to provider consent screens. GET /auth/google/callback and /auth/github/callback exchange OAuth code for JWT token pair. Google checks email_verified. GitHub fetches /user/emails if email is null in profile. All existing auth tests still pass.</done>
</task>

</tasks>

<verification>
1. `poetry run python -c "from app.users.router import router; print([r.path for r in router.routes])"` shows all 8 auth routes (4 existing + 4 OAuth)
2. `poetry run ruff check app/` passes with zero violations
3. `poetry run task test` -- all existing tests pass (no regressions)
4. `poetry run python -c "from app.users.service import AuthService; import inspect; assert 'oauth_login' in [m[0] for m in inspect.getmembers(AuthService, predicate=inspect.isfunction)]; print('oauth_login exists')"` confirms method exists
</verification>

<success_criteria>
- OAuthAccountRepository exists with get_by_provider_and_id and create methods
- UserRepository.create_oauth_user creates users without password
- AuthService.oauth_login handles three paths: existing OAuth link, email match, new user
- AuthService.login rejects OAuth-only users (hashed_password is None) with clear 400 error
- GET /auth/google redirects to Google consent screen via Authlib
- GET /auth/google/callback exchanges code for JWT tokens, checks email_verified
- GET /auth/github redirects to GitHub authorization screen via Authlib
- GET /auth/github/callback exchanges code for JWT tokens, handles private email via /user/emails
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-oauth/03-02-SUMMARY.md`
</output>
