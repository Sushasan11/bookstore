---
phase: 01-infrastructure
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - app/db/session.py
  - app/db/base.py
  - app/core/deps.py
autonomous: true
requirements:
  - INFRA-DATABASE

must_haves:
  truths:
    - "Async SQLAlchemy engine connects to PostgreSQL via asyncpg"
    - "Session factory uses expire_on_commit=False to prevent MissingGreenlet errors"
    - "get_db dependency yields a per-request AsyncSession with commit/rollback semantics"
    - "DeclarativeBase is defined in base.py and ready for model imports"
  artifacts:
    - path: "app/db/session.py"
      provides: "Async engine and session factory"
      contains: "create_async_engine"
    - path: "app/db/base.py"
      provides: "DeclarativeBase for all models"
      contains: "class Base"
    - path: "app/core/deps.py"
      provides: "get_db dependency and DbSession type alias"
      contains: "async def get_db"
  key_links:
    - from: "app/db/session.py"
      to: "app/core/config.py"
      via: "get_settings() for DATABASE_URL"
      pattern: "get_settings.*DATABASE_URL"
    - from: "app/core/deps.py"
      to: "app/db/session.py"
      via: "imports AsyncSessionLocal"
      pattern: "from app\\.db\\.session import"
    - from: "app/db/session.py"
      to: "asyncpg driver"
      via: "postgresql+asyncpg:// URL scheme"
      pattern: "postgresql\\+asyncpg"
---

<objective>
Create the async database layer: SQLAlchemy async engine with connection pooling, async session factory with expire_on_commit=False, DeclarativeBase for model inheritance, and the get_db FastAPI dependency for per-request sessions.

Purpose: Every feature phase needs database access. The session factory and get_db dependency are imported by every repository and router. Getting expire_on_commit=False right here prevents MissingGreenlet errors everywhere.
Output: Working async database infrastructure that connects to PostgreSQL via asyncpg with proper session lifecycle management.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create async engine, session factory, and DeclarativeBase</name>
  <files>
    app/db/__init__.py
    app/db/session.py
    app/db/base.py
  </files>
  <action>
    1. Create app/db/session.py (per RESEARCH.md Pattern 1):
       - Import create_async_engine, async_sessionmaker, AsyncSession from sqlalchemy.ext.asyncio
       - Import get_settings from app.core.config
       - Create engine with get_settings().DATABASE_URL:
         - pool_size=5, max_overflow=10
         - pool_pre_ping=True (catches stale connections)
         - pool_recycle=1800 (30-minute recycle)
         - echo=settings.DEBUG (SQL logging in debug mode only)
       - Create AsyncSessionLocal = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False, autocommit=False, autoflush=False)
       - CRITICAL: expire_on_commit=False is NON-NEGOTIABLE. Without it, accessing model attributes after commit raises MissingGreenlet in every route.

    2. Create app/db/base.py (per RESEARCH.md Pattern 3 â€” model aggregator):
       - Import DeclarativeBase from sqlalchemy.orm
       - Define class Base(DeclarativeBase): pass
       - Add comments explaining that model imports go here as phases are added
       - No model imports yet (Phase 1 has no models)

    3. Ensure app/db/__init__.py exists (should already exist from Plan 01, but verify).
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && poetry run python -c "from app.db.session import engine, AsyncSessionLocal; print(f'Engine URL: {engine.url}'); print(f'expire_on_commit: {AsyncSessionLocal.kw[\"expire_on_commit\"]}')"</automated>
    <manual>Verify expire_on_commit is False, engine URL uses postgresql+asyncpg scheme</manual>
  </verify>
  <done>Async engine connects to PostgreSQL via asyncpg URL. Session factory has expire_on_commit=False. DeclarativeBase exists in base.py ready for model inheritance.</done>
</task>

<task type="auto">
  <name>Task 2: Create get_db dependency with per-request session lifecycle</name>
  <files>
    app/core/deps.py
  </files>
  <action>
    1. Replace the placeholder app/core/deps.py with the full implementation (per RESEARCH.md Pattern 1):
       - Import AsyncGenerator, Annotated from typing
       - Import Depends from fastapi
       - Import AsyncSession from sqlalchemy.ext.asyncio
       - Import AsyncSessionLocal from app.db.session
       - Define async def get_db() -> AsyncGenerator[AsyncSession, None]:
         - Use `async with AsyncSessionLocal() as session:` context manager
         - try: yield session, await session.commit()
         - except Exception: await session.rollback(), raise
         - finally: await session.close()
       - Define type alias: DbSession = Annotated[AsyncSession, Depends(get_db)]
       - This DbSession type alias allows routes to declare `db: DbSession` instead of `db: AsyncSession = Depends(get_db)`.
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && poetry run python -c "from app.core.deps import get_db, DbSession; print(f'get_db: {get_db.__name__}'); print(f'DbSession: {DbSession}')"</automated>
    <manual>Verify get_db is an async generator, DbSession is an Annotated type</manual>
  </verify>
  <done>get_db dependency yields AsyncSession with commit-on-success/rollback-on-error semantics. DbSession type alias available for route parameter declarations.</done>
</task>

</tasks>

<verification>
1. `from app.db.session import engine, AsyncSessionLocal` imports without errors
2. `AsyncSessionLocal.kw["expire_on_commit"]` is False
3. Engine URL starts with `postgresql+asyncpg://`
4. `from app.db.base import Base` imports without errors
5. `from app.core.deps import get_db, DbSession` imports without errors
6. get_db is an async generator function
</verification>

<success_criteria>
- Async engine created with pool_pre_ping=True and connection pooling configured
- Session factory has expire_on_commit=False (prevents MissingGreenlet)
- DeclarativeBase defined and importable from app.db.base
- get_db yields per-request sessions with commit/rollback lifecycle
- DbSession type alias works as a FastAPI dependency annotation
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure/01-02-SUMMARY.md`
</output>
