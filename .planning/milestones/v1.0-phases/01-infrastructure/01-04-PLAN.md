---
phase: 01-infrastructure
plan: 04
type: execute
wave: 4
depends_on:
  - 01-02
  - 01-03
files_modified:
  - tests/__init__.py
  - tests/conftest.py
  - tests/test_health.py
autonomous: true
requirements:
  - INFRA-TOOLING

must_haves:
  truths:
    - "pytest discovers and runs async tests with asyncio_mode=auto"
    - "Test fixtures create/drop tables on test database (port 5433) per session"
    - "Each test gets an isolated database session that rolls back after the test"
    - "httpx AsyncClient sends requests to the FastAPI app in-process without network"
    - "ruff check and ruff format --check pass with zero violations"
    - "Health check test proves the full stack works end-to-end"
  artifacts:
    - path: "tests/conftest.py"
      provides: "Async test fixtures: engine, db_session, client"
      contains: "async def test_engine"
    - path: "tests/test_health.py"
      provides: "Smoke tests for health endpoint and error handling"
      contains: "test_health_returns_200"
  key_links:
    - from: "tests/conftest.py"
      to: "app/db/base.py"
      via: "imports Base for create_all/drop_all"
      pattern: "from app\\.db\\.base import Base"
    - from: "tests/conftest.py"
      to: "app/core/deps.py"
      via: "overrides get_db with test session"
      pattern: "dependency_overrides.*get_db"
    - from: "tests/conftest.py"
      to: "app/main.py"
      via: "imports app for ASGITransport"
      pattern: "from app\\.main import"
    - from: "tests/test_health.py"
      to: "tests/conftest.py"
      via: "uses client fixture"
      pattern: "client.*AsyncClient"
---

<objective>
Create the test infrastructure (conftest.py with async fixtures) and smoke tests, then verify all tooling passes: pytest runs async tests, ruff reports zero violations, and the health endpoint works end-to-end.

Purpose: This plan validates the entire infrastructure stack works together. The conftest.py fixtures are used by every test in every subsequent phase. The smoke tests prove the FastAPI app, database connection, and error handling all work.
Output: A passing test suite, clean ruff output, and confidence that the infrastructure is solid.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure/01-RESEARCH.md
@.planning/phases/01-infrastructure/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pytest conftest.py with async database and client fixtures</name>
  <files>
    tests/__init__.py
    tests/conftest.py
  </files>
  <action>
    1. Create tests/__init__.py (empty file to make tests a package).

    2. Create tests/conftest.py (per RESEARCH.md Pattern 7):

       a. Imports: asyncio, pytest, pytest_asyncio, httpx (AsyncClient, ASGITransport), sqlalchemy.ext.asyncio (create_async_engine, async_sessionmaker, AsyncSession), app.main (app), app.core.deps (get_db), app.db.base (Base)

       b. TEST_DATABASE_URL constant: Read from environment with fallback to "postgresql+asyncpg://postgres:postgres@localhost:5433/bookstore_test"

       c. Session-scoped fixture `test_engine`:
          - Creates async engine with TEST_DATABASE_URL, echo=False
          - In setup: `async with engine.begin()` -> `await conn.run_sync(Base.metadata.create_all)`
          - yield engine
          - In teardown: `async with engine.begin()` -> `await conn.run_sync(Base.metadata.drop_all)`, then `await engine.dispose()`

       d. Function-scoped fixture `db_session(test_engine)`:
          - Creates async_sessionmaker bound to test_engine with expire_on_commit=False, autocommit=False, autoflush=False
          - `async with TestSessionLocal() as session:` yield session, then `await session.rollback()`

       e. Function-scoped fixture `client(db_session)`:
          - Defines async def override_get_db() that yields db_session
          - Sets app.dependency_overrides[get_db] = override_get_db
          - Creates AsyncClient with ASGITransport(app=app), base_url="http://test"
          - yield ac
          - Clears app.dependency_overrides

       Important: Use `pytest_asyncio.fixture` (not plain `pytest.fixture`) for all async fixtures. The `scope="session"` fixture for test_engine requires `pytest_asyncio.fixture(scope="session")`.
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && poetry run python -c "from tests.conftest import test_engine, db_session, client; print('Fixtures importable: test_engine, db_session, client')"</automated>
    <manual>Check that conftest.py has session-scoped engine, function-scoped session with rollback, and client with dependency override</manual>
  </verify>
  <done>conftest.py defines three async fixtures: session-scoped test_engine (create_all/drop_all), function-scoped db_session (rollback per test), and function-scoped client (httpx AsyncClient with get_db override). All fixtures importable without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Create smoke tests and verify all tooling passes</name>
  <files>
    tests/test_health.py
  </files>
  <action>
    1. Create tests/test_health.py with three smoke tests (per RESEARCH.md Code Examples):

       a. async def test_health_returns_200(client):
          - GET /health, assert status 200
          - Assert response JSON has "status" == "ok"

       b. async def test_404_returns_structured_error(client):
          - GET /nonexistent, assert status 404
          - Assert response JSON has "detail" and "code" keys

       c. async def test_db_session_connects(db_session):
          - Execute `SELECT 1` via `await db_session.execute(text("SELECT 1"))`
          - Assert result.scalar() == 1
          - This proves the test database connection works

       Note: All tests are plain `async def` functions â€” NO @pytest.mark.asyncio decorator needed because asyncio_mode="auto" is set in pyproject.toml.

    2. Run the full test suite: `poetry run pytest tests/ -v`
       - All 3 tests must pass
       - Requires Docker Compose running (bookstore_test on port 5433)

    3. Run ruff on the entire project: `poetry run ruff check .` and `poetry run ruff format --check .`
       - Fix any violations found in files from Plans 01-04
       - This includes all project files: app/**, tests/**, alembic/env.py
       - All files must pass with zero violations
       - Common issues: unused imports, import ordering, trailing whitespace

    4. If ruff finds violations, fix them in the affected files and re-run until clean.
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && docker compose up -d --wait 2>&1 && poetry run pytest tests/ -v 2>&1 && poetry run ruff check . 2>&1 && poetry run ruff format --check . 2>&1</automated>
    <manual>All 3 tests pass, ruff check and format report zero violations</manual>
  </verify>
  <done>All 3 smoke tests pass (health 200, structured 404, DB session connects). ruff check reports zero violations. ruff format --check reports no formatting changes needed. The entire infrastructure stack is verified end-to-end.</done>
</task>

</tasks>

<verification>
1. `poetry run pytest tests/ -v` passes all 3 tests with no errors
2. `poetry run ruff check .` reports zero violations
3. `poetry run ruff format --check .` reports no changes needed
4. Test output shows asyncio_mode=auto working (no "coroutine never awaited" warnings)
5. test_db_session_connects proves the test database is reachable on port 5433
</verification>

<success_criteria>
- pytest discovers and runs 3 async tests using asyncio_mode="auto"
- test_health_returns_200: GET /health returns 200 with {"status": "ok"}
- test_404_returns_structured_error: GET /nonexistent returns 404 with {"detail": ..., "code": ...}
- test_db_session_connects: SELECT 1 against test DB returns 1
- ruff check passes with zero violations across all project files
- ruff format --check passes with no formatting changes needed
- No MissingGreenlet errors, no import errors, no coroutine warnings
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure/01-04-SUMMARY.md`
</output>
