---
phase: 01-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - docker-compose.yml
  - .env
  - .env.example
  - .gitignore
  - app/__init__.py
  - app/main.py
  - app/core/__init__.py
  - app/core/config.py
  - app/core/exceptions.py
  - app/core/health.py
  - app/books/__init__.py
  - app/users/__init__.py
  - app/orders/__init__.py
  - app/cart/__init__.py
  - app/wishlist/__init__.py
  - app/prebooks/__init__.py
autonomous: true
requirements:
  - INFRA-SCAFFOLD

must_haves:
  truths:
    - "Poetry project initializes and installs all dependencies without errors"
    - "FastAPI app starts via uvicorn and responds to requests"
    - "pydantic-settings reads config from .env without hardcoded secrets"
    - "Docker Compose starts dev and test PostgreSQL containers"
    - "Health endpoint returns 200 with application status (app-level ping only, no DB check)"
    - "Structured error responses follow the JSON convention for all error types"
  artifacts:
    - path: "pyproject.toml"
      provides: "Project configuration with all dependencies and tool configs"
      contains: "fastapi"
    - path: "app/main.py"
      provides: "FastAPI application factory with exception handlers and health router"
      contains: "create_app"
    - path: "app/core/config.py"
      provides: "pydantic-settings configuration with lru_cache"
      contains: "class Settings"
    - path: "app/core/exceptions.py"
      provides: "Global exception handlers and AppError class"
      contains: "class AppError"
    - path: "app/core/health.py"
      provides: "Health check endpoint (application-level, not database)"
      contains: "/health"
    - path: "docker-compose.yml"
      provides: "Dev and test PostgreSQL services"
      contains: "bookstore_test"
    - path: ".env.example"
      provides: "Environment variable template"
      contains: "DATABASE_URL"
  key_links:
    - from: "app/main.py"
      to: "app/core/exceptions.py"
      via: "add_exception_handler registration"
      pattern: "add_exception_handler"
    - from: "app/main.py"
      to: "app/core/health.py"
      via: "include_router"
      pattern: "include_router.*health"
    - from: "app/core/config.py"
      to: ".env"
      via: "pydantic-settings env_file"
      pattern: "env_file.*\\.env"
---

<objective>
Create the complete project scaffold: Poetry project with all dependencies, FastAPI application factory with exception handlers, pydantic-settings configuration, Docker Compose for PostgreSQL, and the domain directory structure.

Purpose: This is the foundation every subsequent plan and phase depends on. Without a working app factory, config system, and database containers, nothing else can be built.
Output: A Poetry project that installs cleanly, a FastAPI app that starts and responds on /health, Docker Compose with dev+test PostgreSQL, and the domain-first directory structure ready for feature work.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Poetry project with all dependencies and configuration</name>
  <files>
    pyproject.toml
    docker-compose.yml
    .env
    .env.example
    .gitignore
  </files>
  <action>
    1. Initialize a new Poetry project in the current directory. Do NOT use `poetry new` (which creates a subdirectory). Instead, create `pyproject.toml` directly with:
       - name = "bookstore", version = "0.1.0", packages = [{include = "app"}]
       - Python ^3.13
       - Production deps: fastapi[standard]^0.133.0, uvicorn[standard]^0.41.0, sqlalchemy[asyncio]^2.0.47, alembic^1.18.4, asyncpg^0.31.0, pydantic^2.12.5, pydantic-settings^2.13.1, python-multipart, email-validator, python-dotenv
       - Dev deps group: pytest^9.0.2, pytest-asyncio^1.3.0, httpx^0.28.1, ruff^0.15.2, mypy, taskipy
       - [build-system] requires = ["poetry-core"] with build-backend = "poetry.core.masonry.api"

    2. Add tool configurations to pyproject.toml:
       - [tool.pytest.ini_options]: asyncio_mode = "auto", testpaths = ["tests"]
       - [tool.taskipy.tasks]: dev, test, lint, format, migrate, makemigration commands (see RESEARCH.md Pattern 6)
       - [tool.ruff]: line-length = 88, target-version = "py313"
       - [tool.ruff.lint]: select = ["E","W","F","I","B","UP","N"], ignore = ["E501"]
       - [tool.ruff.lint.isort]: known-first-party = ["app"]
       - [tool.mypy]: python_version = "3.13", ignore_missing_imports = true

    3. Create docker-compose.yml with two PostgreSQL 17 services:
       - bookstore_dev: port 5432, POSTGRES_DB=bookstore_dev, volume for persistence, healthcheck
       - bookstore_test: port 5433 mapped to container 5432, POSTGRES_DB=bookstore_test, NO volume (ephemeral)

    4. Create .env with development defaults:
       - DATABASE_URL=postgresql+asyncpg://postgres:postgres@localhost:5432/bookstore_dev
       - TEST_DATABASE_URL=postgresql+asyncpg://postgres:postgres@localhost:5433/bookstore_test
       - SECRET_KEY=dev-secret-key-change-in-production
       - DEBUG=true
       - ALLOWED_ORIGINS=["http://localhost:3000"]
       - ACCESS_TOKEN_EXPIRE_MINUTES=30
       - ENV=development

    5. Create .env.example with placeholder values (same keys, no real secrets).

    6. Create .gitignore with Python defaults: __pycache__/, *.pyc, .env, .mypy_cache/, .pytest_cache/, .ruff_cache/, *.egg-info/, dist/, .venv/

    7. Run `poetry install` to install all dependencies and verify no resolution errors.
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && poetry install --no-interaction 2>&1 | tail -5</automated>
    <manual>Check that pyproject.toml has all sections, .env and .env.example exist, docker-compose.yml has two services</manual>
  </verify>
  <done>Poetry project installs without errors. pyproject.toml contains all deps, tool configs, and taskipy tasks. docker-compose.yml defines bookstore_dev (5432) and bookstore_test (5433). .env has all config vars. .env.example committed as template. .gitignore excludes .env and Python artifacts.</done>
</task>

<task type="auto">
  <name>Task 2: Create FastAPI app factory with exception handlers, health endpoint, and domain directory structure</name>
  <files>
    app/__init__.py
    app/main.py
    app/core/__init__.py
    app/core/config.py
    app/core/exceptions.py
    app/core/health.py
    app/core/deps.py
    app/core/security.py
    app/db/__init__.py
    app/books/__init__.py
    app/users/__init__.py
    app/orders/__init__.py
    app/cart/__init__.py
    app/wishlist/__init__.py
    app/prebooks/__init__.py
  </files>
  <action>
    1. Create the domain-first directory structure with empty __init__.py files:
       - app/ (root package)
       - app/core/ (cross-cutting concerns)
       - app/db/ (database infrastructure — files created in Plan 02)
       - app/books/, app/users/, app/orders/, app/cart/, app/wishlist/, app/prebooks/ (domain stubs)

    2. Create app/core/config.py (per RESEARCH.md Pattern 2):
       - class Settings(BaseSettings) with: DATABASE_URL, TEST_DATABASE_URL (optional, default to test DB URL), SECRET_KEY, ACCESS_TOKEN_EXPIRE_MINUTES (int, default 30), DEBUG (bool, default False), ALLOWED_ORIGINS (list[str]), ENV (str, default "development")
       - SettingsConfigDict with env_file=".env", env_file_encoding="utf-8", case_sensitive=False
       - @lru_cache def get_settings() -> Settings

    3. Create app/core/exceptions.py (per RESEARCH.md Pattern 5):
       - class AppError(Exception) with status_code, detail, code, field attributes
       - async def app_error_handler — returns {"detail": ..., "code": ..., "field": ...}
       - async def http_exception_handler — reformats HTTPException to include "code" field
       - async def generic_exception_handler — logs real error, returns generic {"detail": "Internal server error", "code": "INTERNAL_ERROR"}
       - async def validation_exception_handler — keeps Pydantic 422 format, adds "code": "VALIDATION_ERROR"

    4. Create app/core/health.py (per RESEARCH.md Pattern 8):
       - APIRouter with tags=["health"]
       - GET /health returning {"status": "ok", "version": "1.0.0"}
       - This is an application-level ping only. It does NOT check database connectivity. Database connectivity is verified separately via the test suite (Plan 04, test_db_session_connects).

    5. Create app/core/deps.py as a placeholder (empty file with docstring — get_db dependency added in Plan 02).

    6. Create app/core/security.py as a placeholder (empty file with docstring — JWT/password logic added in Phase 2).

    7. Create app/main.py with create_app() factory function:
       - Register all four exception handlers (AppError, StarletteHTTPException, RequestValidationError, Exception)
       - Include health_router
       - Set title="Bookstore API", version="1.0.0"
       - Module-level: app = create_app()
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && poetry run python -c "from app.main import app; print(f'Routes: {len(app.routes)}')" && poetry run python -c "from app.core.config import get_settings; s = get_settings(); print(f'DB: {s.DATABASE_URL[:20]}...')"</automated>
    <manual>Verify app imports without errors, config reads from .env, health router is registered</manual>
  </verify>
  <done>FastAPI app factory creates app with all exception handlers registered. GET /health is routable. Settings loads from .env via pydantic-settings with @lru_cache. All domain directories exist as empty packages. app/core/deps.py and app/core/security.py exist as placeholders.</done>
</task>

</tasks>

<verification>
1. `poetry install` completes without errors
2. `poetry run python -c "from app.main import app; print('OK')"` prints OK
3. `poetry run python -c "from app.core.config import get_settings; print(get_settings().DATABASE_URL)"` prints the DATABASE_URL from .env
4. Docker Compose file is valid YAML with two services
5. All domain directories have __init__.py files
</verification>

<success_criteria>
- Poetry project installs all dependencies without resolution errors
- FastAPI app imports and creates without errors
- pydantic-settings reads DATABASE_URL from .env
- Health endpoint is registered in the app routes (app-level ping, no DB check)
- Exception handlers are registered for AppError, HTTPException, RequestValidationError, and generic Exception
- Domain directory structure matches the locked decision layout
- Database connectivity is NOT checked by the health endpoint (verified separately in Plan 04 test suite)
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure/01-01-SUMMARY.md`
</output>
