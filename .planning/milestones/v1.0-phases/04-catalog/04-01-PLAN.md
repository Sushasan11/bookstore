---
phase: 04-catalog
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - app/books/__init__.py
  - app/books/models.py
  - app/books/schemas.py
  - app/books/repository.py
  - app/books/service.py
  - app/db/base.py
  - alembic/env.py
  - alembic/versions/XXXX_create_genres_and_books.py
autonomous: true
requirements:
  - CATL-01
  - CATL-02
  - CATL-03
  - CATL-04
  - CATL-05

must_haves:
  truths:
    - "Book and Genre SQLAlchemy models exist with all required fields and constraints"
    - "Alembic migration creates genres and books tables with CHECK CONSTRAINTS and indexes"
    - "ISBN-10 and ISBN-13 checksum validation rejects invalid ISBNs at the schema layer"
    - "Price is stored as Numeric(10,2) and validated as > 0"
    - "BookService raises 404 AppError on missing book and 409 on duplicate ISBN"
    - "BookRepository and GenreRepository provide all CRUD operations via async SQLAlchemy"
  artifacts:
    - path: "app/books/models.py"
      provides: "Genre and Book SQLAlchemy models"
      contains: "class Genre"
    - path: "app/books/schemas.py"
      provides: "Pydantic schemas with ISBN validator"
      contains: "_validate_isbn"
    - path: "app/books/repository.py"
      provides: "GenreRepository and BookRepository async data access"
      contains: "class BookRepository"
    - path: "app/books/service.py"
      provides: "BookService business rules (404, 409, stock set)"
      contains: "class BookService"
    - path: "alembic/versions/XXXX_create_genres_and_books.py"
      provides: "genres and books table migration"
      contains: "ck_books_stock_non_negative"
  key_links:
    - from: "app/books/models.py"
      to: "app/db/base.py"
      via: "class Genre(Base) and class Book(Base)"
      pattern: "from app.db.base import Base"
    - from: "alembic/env.py"
      to: "app/books/models.py"
      via: "import for Alembic autogenerate discovery"
      pattern: "from app.books.models import"
    - from: "app/books/service.py"
      to: "app/books/repository.py"
      via: "BookService receives BookRepository and GenreRepository in __init__"
      pattern: "class BookService"
---

<objective>
Create the books domain foundation: Genre and Book SQLAlchemy models, Alembic migration for both tables, Pydantic schemas with ISBN-10/13 checksum validation, async repository layer, and BookService with business rule enforcement.

Purpose: All catalog endpoints in Plan 02 depend on this layer. The models, migration, schemas, repository, and service must exist before any HTTP routing can be wired.
Output: app/books/ module with models, schemas, repository, and service; Alembic migration that creates genres and books tables with CHECK CONSTRAINTs.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-catalog/04-CONTEXT.md
@.planning/phases/04-catalog/04-RESEARCH.md
@app/db/base.py
@app/users/models.py
@alembic/env.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Genre and Book SQLAlchemy models with Alembic migration</name>
  <files>app/books/__init__.py, app/books/models.py, app/db/base.py, alembic/env.py, alembic/versions/XXXX_create_genres_and_books.py</files>
  <action>
Create `app/books/__init__.py` as an empty file.

Create `app/books/models.py` with Genre and Book models using SQLAlchemy 2.0 `Mapped`/`mapped_column` API (same pattern as `app/users/models.py`):

```python
"""Book catalog models: Genre (flat taxonomy) and Book (with stock tracking)."""

from datetime import date, datetime
from decimal import Decimal

from sqlalchemy import (
    CheckConstraint,
    Date,
    DateTime,
    ForeignKey,
    Integer,
    Numeric,
    String,
    Text,
    func,
)
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.db.base import Base


class Genre(Base):
    __tablename__ = "genres"

    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(100), unique=True, nullable=False, index=True)
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), nullable=False
    )

    books: Mapped[list["Book"]] = relationship(back_populates="genre")


class Book(Base):
    __tablename__ = "books"

    __table_args__ = (
        CheckConstraint("stock_quantity >= 0", name="ck_books_stock_non_negative"),
        CheckConstraint("price > 0", name="ck_books_price_positive"),
    )

    id: Mapped[int] = mapped_column(primary_key=True)
    title: Mapped[str] = mapped_column(String(500), nullable=False, index=True)
    author: Mapped[str] = mapped_column(String(255), nullable=False, index=True)
    price: Mapped[Decimal] = mapped_column(Numeric(10, 2), nullable=False)
    isbn: Mapped[str | None] = mapped_column(String(17), unique=True, nullable=True, index=True)
    description: Mapped[str | None] = mapped_column(Text, nullable=True)
    cover_image_url: Mapped[str | None] = mapped_column(String(2048), nullable=True)
    publish_date: Mapped[date | None] = mapped_column(Date, nullable=True)
    stock_quantity: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    genre_id: Mapped[int | None] = mapped_column(
        ForeignKey("genres.id"), nullable=True, index=True
    )
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), nullable=False
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now(),
        nullable=False,
    )

    genre: Mapped["Genre | None"] = relationship(back_populates="books")
```

Key model decisions (per RESEARCH.md):
- `Numeric(10, 2)` for price — exact decimal arithmetic, no floating-point errors
- `stock_quantity` defaults to 0, DB-enforced non-negative via CHECK CONSTRAINT
- `isbn` is nullable + unique — PostgreSQL unique index on nullable correctly allows multiple NULLs
- `genre_id` nullable FK — a book can exist without a genre (single genre per book, flat taxonomy)
- `updated_at` uses `onupdate=func.now()` — triggers on ORM-level updates only; always use `setattr()` not raw UPDATE statement

Next, READ `app/db/base.py`. It currently only imports `DeclarativeBase`. No changes needed there (the comment says model imports for Alembic live in alembic/env.py).

READ `alembic/env.py`. Add the books models import on the line after the existing user model imports:

```python
from app.books.models import Book, Genre  # noqa: F401
```

Place it directly after:
```python
from app.users.models import OAuthAccount, RefreshToken, User  # noqa: F401
```

Now create the Alembic migration file. First determine the next migration version by reading the existing migration files in `alembic/versions/`. The existing migration is `451f9697aceb_create_users_and_refresh_tokens.py`. Create a new migration file with a new revision ID (generate an 8-character hex ID, e.g., `a1b2c3d4e5f6`) and name it `{revision_id}_create_genres_and_books.py`.

Create `alembic/versions/{revision_id}_create_genres_and_books.py`:

```python
"""create_genres_and_books

Revision ID: {revision_id}
Revises: 451f9697aceb
Create Date: 2026-02-25 00:00:00.000000

"""
from typing import Union

import sqlalchemy as sa
from alembic import op

# revision identifiers, used by Alembic
revision: str = "{revision_id}"
down_revision: Union[str, None] = "451f9697aceb"
branch_labels: Union[str, None] = None
depends_on: Union[str, None] = None


def upgrade() -> None:
    # Create genres first (books references genres via FK)
    op.create_table(
        "genres",
        sa.Column("id", sa.Integer(), nullable=False),
        sa.Column("name", sa.String(100), nullable=False),
        sa.Column(
            "created_at",
            sa.DateTime(timezone=True),
            server_default=sa.text("now()"),
            nullable=False,
        ),
        sa.PrimaryKeyConstraint("id"),
    )
    op.create_index("ix_genres_name", "genres", ["name"], unique=True)

    # Create books (FK to genres)
    op.create_table(
        "books",
        sa.Column("id", sa.Integer(), nullable=False),
        sa.Column("title", sa.String(500), nullable=False),
        sa.Column("author", sa.String(255), nullable=False),
        sa.Column("price", sa.Numeric(10, 2), nullable=False),
        sa.Column("isbn", sa.String(17), nullable=True),
        sa.Column("description", sa.Text(), nullable=True),
        sa.Column("cover_image_url", sa.String(2048), nullable=True),
        sa.Column("publish_date", sa.Date(), nullable=True),
        sa.Column(
            "stock_quantity",
            sa.Integer(),
            nullable=False,
            server_default="0",
        ),
        sa.Column("genre_id", sa.Integer(), nullable=True),
        sa.Column(
            "created_at",
            sa.DateTime(timezone=True),
            server_default=sa.text("now()"),
            nullable=False,
        ),
        sa.Column(
            "updated_at",
            sa.DateTime(timezone=True),
            server_default=sa.text("now()"),
            nullable=False,
        ),
        sa.CheckConstraint("stock_quantity >= 0", name="ck_books_stock_non_negative"),
        sa.CheckConstraint("price > 0", name="ck_books_price_positive"),
        sa.ForeignKeyConstraint(["genre_id"], ["genres.id"]),
        sa.PrimaryKeyConstraint("id"),
    )
    op.create_index("ix_books_title", "books", ["title"])
    op.create_index("ix_books_author", "books", ["author"])
    op.create_index("ix_books_isbn", "books", ["isbn"], unique=True)
    op.create_index("ix_books_genre_id", "books", ["genre_id"])


def downgrade() -> None:
    op.drop_table("books")
    op.drop_table("genres")
```

Replace `{revision_id}` with the actual hex string chosen (e.g., `a1b2c3d4e5f6`). The actual filename must use the same revision ID.

Run `ruff check app/books/models.py alembic/env.py alembic/versions/*.py` and fix any violations.

Verify imports work:
```bash
cd D:/Python/claude-test && poetry run python -c "from app.books.models import Book, Genre; print('Genre:', Genre.__tablename__, '| Book:', Book.__tablename__)"
```
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && poetry run python -c "
from app.books.models import Book, Genre
# Verify model table names
assert Book.__tablename__ == 'books'
assert Genre.__tablename__ == 'genres'
# Verify CHECK CONSTRAINT names are registered
constraints = {c.name for c in Book.__table__.constraints}
assert 'ck_books_stock_non_negative' in constraints, f'Missing stock constraint, got: {constraints}'
assert 'ck_books_price_positive' in constraints, f'Missing price constraint, got: {constraints}'
# Verify isbn is nullable and unique
isbn_col = Book.__table__.c['isbn']
assert isbn_col.nullable is True
# Verify genre FK
genre_id_col = Book.__table__.c['genre_id']
assert genre_id_col.nullable is True
print('All model assertions passed')
"</automated>
    <manual>Check that alembic/env.py has the books models import line after the users import line</manual>
  </verify>
  <done>
    - app/books/__init__.py exists (empty)
    - app/books/models.py defines Genre and Book with Mapped/mapped_column API
    - Book has: id, title, author, price (Numeric 10,2), isbn (nullable+unique), description, cover_image_url, publish_date, stock_quantity (default 0), genre_id (nullable FK), created_at, updated_at
    - Book __table_args__ includes ck_books_stock_non_negative and ck_books_price_positive CHECK CONSTRAINTs
    - Genre has: id, name (unique), created_at
    - alembic/env.py imports Book and Genre (noqa: F401) for autogenerate discovery
    - Migration file creates genres then books in correct FK dependency order, with all indexes
    - ruff check passes with zero violations
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Pydantic schemas, repositories, and BookService</name>
  <files>app/books/schemas.py, app/books/repository.py, app/books/service.py</files>
  <action>
Create `app/books/schemas.py` with ISBN-10/13 checksum validation and all request/response schemas:

```python
"""Pydantic schemas for book catalog CRUD."""
import re
from datetime import date
from decimal import Decimal
from typing import Annotated

from pydantic import BaseModel, Field, field_validator, model_config


def _validate_isbn(isbn: str) -> str:
    """Validate ISBN-10 or ISBN-13 with checksum. Raise ValueError on failure.

    Strips hyphens and spaces before checking. Returns the cleaned (stripped)
    ISBN string on success.
    """
    cleaned = re.sub(r"[-\s]", "", isbn).upper()

    if len(cleaned) == 10:
        # ISBN-10: 9 digits + check digit (0-9 or X)
        if not re.match(r"^\d{9}[\dX]$", cleaned):
            raise ValueError("ISBN-10 must be 9 digits followed by a digit or X")
        total = sum((10 - i) * (int(c) if c != "X" else 10) for i, c in enumerate(cleaned))
        if total % 11 != 0:
            raise ValueError("ISBN-10 checksum invalid")
    elif len(cleaned) == 13:
        # ISBN-13: 13 digits with alternating 1/3 weights
        if not re.match(r"^\d{13}$", cleaned):
            raise ValueError("ISBN-13 must be exactly 13 digits")
        total = sum(int(c) * (1 if i % 2 == 0 else 3) for i, c in enumerate(cleaned))
        if total % 10 != 0:
            raise ValueError("ISBN-13 checksum invalid")
    else:
        raise ValueError("ISBN must be 10 or 13 digits (hyphens ignored)")

    return cleaned


class BookCreate(BaseModel):
    """Request body for POST /books. title, author, price are required."""

    title: str = Field(min_length=1, max_length=500)
    author: str = Field(min_length=1, max_length=255)
    price: Decimal = Field(gt=0, decimal_places=2)
    isbn: str | None = None
    genre_id: int | None = None
    description: str | None = None
    cover_image_url: Annotated[str | None, Field(None, max_length=2048)] = None
    publish_date: date | None = None

    @field_validator("isbn", mode="before")
    @classmethod
    def validate_isbn(cls, v: str | None) -> str | None:
        if v is None or (isinstance(v, str) and v.strip() == ""):
            return None
        return _validate_isbn(str(v))

    model_config = model_config(from_attributes=True)


class BookUpdate(BaseModel):
    """Request body for PUT /books/{id}. All fields optional."""

    title: str | None = Field(None, min_length=1, max_length=500)
    author: str | None = Field(None, min_length=1, max_length=255)
    price: Decimal | None = Field(None, gt=0, decimal_places=2)
    isbn: str | None = None
    genre_id: int | None = None
    description: str | None = None
    cover_image_url: Annotated[str | None, Field(None, max_length=2048)] = None
    publish_date: date | None = None

    @field_validator("isbn", mode="before")
    @classmethod
    def validate_isbn(cls, v: str | None) -> str | None:
        if v is None or (isinstance(v, str) and v.strip() == ""):
            return None
        return _validate_isbn(str(v))


class StockUpdate(BaseModel):
    """Request body for PATCH /books/{id}/stock."""

    quantity: int = Field(ge=0, description="Absolute stock quantity to set")


class BookResponse(BaseModel):
    """Response schema for book records."""

    id: int
    title: str
    author: str
    price: Decimal
    isbn: str | None
    genre_id: int | None
    description: str | None
    cover_image_url: str | None
    publish_date: date | None
    stock_quantity: int

    model_config = model_config(from_attributes=True)


class GenreCreate(BaseModel):
    """Request body for POST /genres."""

    name: str = Field(min_length=1, max_length=100)


class GenreResponse(BaseModel):
    """Response schema for genre records."""

    id: int
    name: str

    model_config = model_config(from_attributes=True)
```

Note on `cover_image_url`: Using `max_length=2048` via Field annotation (not HttpUrl) because HttpUrl changes the serialized type and may cause test friction. Consistent with research recommendation to keep response simple.

Create `app/books/repository.py` following the same async select() pattern as UserRepository:

```python
"""Repository layer for Genre and Book database access."""

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.books.models import Book, Genre


class GenreRepository:
    def __init__(self, session: AsyncSession) -> None:
        self.session = session

    async def get_all(self) -> list[Genre]:
        result = await self.session.execute(select(Genre).order_by(Genre.name))
        return list(result.scalars().all())

    async def get_by_name(self, name: str) -> Genre | None:
        result = await self.session.execute(select(Genre).where(Genre.name == name))
        return result.scalar_one_or_none()

    async def get_by_id(self, genre_id: int) -> Genre | None:
        result = await self.session.execute(select(Genre).where(Genre.id == genre_id))
        return result.scalar_one_or_none()

    async def create(self, name: str) -> Genre:
        genre = Genre(name=name)
        self.session.add(genre)
        await self.session.flush()
        return genre


class BookRepository:
    def __init__(self, session: AsyncSession) -> None:
        self.session = session

    async def get_by_id(self, book_id: int) -> Book | None:
        result = await self.session.execute(select(Book).where(Book.id == book_id))
        return result.scalar_one_or_none()

    async def get_by_isbn(self, isbn: str) -> Book | None:
        result = await self.session.execute(select(Book).where(Book.isbn == isbn))
        return result.scalar_one_or_none()

    async def create(self, **kwargs: object) -> Book:
        book = Book(**kwargs)
        self.session.add(book)
        await self.session.flush()
        return book

    async def update(self, book: Book, **kwargs: object) -> Book:
        for field, value in kwargs.items():
            setattr(book, field, value)
        await self.session.flush()
        return book

    async def delete(self, book: Book) -> None:
        await self.session.delete(book)
        await self.session.flush()

    async def set_stock(self, book: Book, quantity: int) -> Book:
        book.stock_quantity = quantity
        await self.session.flush()
        return book
```

Create `app/books/service.py` with 404/409 error handling matching the existing AppError pattern:

```python
"""BookService: business rules for book and genre management."""

from sqlalchemy.exc import IntegrityError

from app.books.models import Book, Genre
from app.books.repository import BookRepository, GenreRepository
from app.books.schemas import BookCreate, BookUpdate
from app.core.exceptions import AppError


class BookService:
    def __init__(self, book_repo: BookRepository, genre_repo: GenreRepository) -> None:
        self.book_repo = book_repo
        self.genre_repo = genre_repo

    async def _get_book_or_404(self, book_id: int) -> Book:
        book = await self.book_repo.get_by_id(book_id)
        if not book:
            raise AppError(
                status_code=404,
                detail="Book not found",
                code="BOOK_NOT_FOUND",
                field="book_id",
            )
        return book

    async def create_book(self, data: BookCreate) -> Book:
        try:
            return await self.book_repo.create(**data.model_dump())
        except IntegrityError as e:
            if "isbn" in str(e.orig).lower():
                raise AppError(
                    status_code=409,
                    detail="A book with this ISBN already exists",
                    code="BOOK_ISBN_CONFLICT",
                    field="isbn",
                ) from e
            raise

    async def update_book(self, book_id: int, data: BookUpdate) -> Book:
        book = await self._get_book_or_404(book_id)
        updates = {k: v for k, v in data.model_dump(exclude_unset=True).items()}
        try:
            return await self.book_repo.update(book, **updates)
        except IntegrityError as e:
            if "isbn" in str(e.orig).lower():
                raise AppError(
                    status_code=409,
                    detail="A book with this ISBN already exists",
                    code="BOOK_ISBN_CONFLICT",
                    field="isbn",
                ) from e
            raise

    async def delete_book(self, book_id: int) -> None:
        book = await self._get_book_or_404(book_id)
        await self.book_repo.delete(book)

    async def set_stock(self, book_id: int, quantity: int) -> Book:
        book = await self._get_book_or_404(book_id)
        return await self.book_repo.set_stock(book, quantity)

    async def create_genre(self, name: str) -> Genre:
        existing = await self.genre_repo.get_by_name(name)
        if existing:
            raise AppError(
                status_code=409,
                detail="Genre already exists",
                code="GENRE_CONFLICT",
                field="name",
            )
        return await self.genre_repo.create(name)

    async def list_genres(self) -> list[Genre]:
        return await self.genre_repo.get_all()
```

Run `ruff check app/books/schemas.py app/books/repository.py app/books/service.py` and fix any violations.

Verify all imports work:
```bash
cd D:/Python/claude-test && poetry run python -c "
from app.books.schemas import BookCreate, BookUpdate, BookResponse, GenreCreate, GenreResponse, StockUpdate
from app.books.repository import BookRepository, GenreRepository
from app.books.service import BookService
print('All books module imports OK')
"
```

Verify ISBN validation is correct:
```bash
cd D:/Python/claude-test && poetry run python -c "
from app.books.schemas import _validate_isbn
# Valid ISBN-13
assert _validate_isbn('9780306406157') == '9780306406157'
# Valid ISBN-10
assert _validate_isbn('0306406152') == '0306406152'
# Invalid checksum
try:
    _validate_isbn('9780306406158')
    assert False, 'Should have failed'
except ValueError as e:
    assert 'checksum' in str(e).lower()
# Hyphens stripped
assert _validate_isbn('978-0-306-40615-7') == '9780306406157'
print('ISBN validation correct')
"
```
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && poetry run python -c "
from app.books.schemas import BookCreate, _validate_isbn
from app.books.repository import BookRepository, GenreRepository
from app.books.service import BookService
# Test ISBN-13 valid
assert _validate_isbn('9780306406157') == '9780306406157'
# Test ISBN-10 valid
assert _validate_isbn('0306406152') == '0306406152'
# Test invalid checksum raises ValueError
try:
    _validate_isbn('9780306406158')
    raise AssertionError('Should have raised ValueError')
except ValueError:
    pass
# Test hyphen stripping
assert _validate_isbn('978-0-306-40615-7') == '9780306406157'
# Test BookCreate requires title/author/price
import pydantic
try:
    BookCreate(title='', author='test', price=10)
    raise AssertionError('Should have raised')
except Exception:
    pass
print('All schema and import assertions passed')
"</automated>
  </verify>
  <done>
    - app/books/schemas.py defines BookCreate, BookUpdate, StockUpdate, BookResponse, GenreCreate, GenreResponse
    - _validate_isbn() correctly validates ISBN-10 (mod 11) and ISBN-13 (mod 10) checksums; strips hyphens/spaces
    - BookCreate requires title (min_length=1), author (min_length=1), price (gt=0, decimal_places=2)
    - BookCreate and BookUpdate have @field_validator for isbn that returns None for empty/None, runs _validate_isbn for non-empty
    - app/books/repository.py defines GenreRepository and BookRepository with async select() methods
    - All repository methods use flush() after add/delete/setattr (not commit — session is managed by get_db dep)
    - app/books/service.py defines BookService with _get_book_or_404, create_book, update_book, delete_book, set_stock, create_genre, list_genres
    - create_book and update_book catch IntegrityError and raise 409 AppError when isbn is mentioned in the error
    - ruff check passes with zero violations
  </done>
</task>

</tasks>

<verification>
Run all existing tests to confirm nothing was broken by adding the books module:

```bash
cd D:/Python/claude-test && poetry run pytest tests/ -v
```

Run ruff on all new files:

```bash
cd D:/Python/claude-test && poetry run ruff check app/books/ alembic/env.py && poetry run ruff format --check app/books/ alembic/env.py
```

Verify models import correctly and constraints are present:

```bash
cd D:/Python/claude-test && poetry run python -c "
from app.books.models import Book, Genre
constraints = {c.name for c in Book.__table__.constraints}
print('Book constraints:', constraints)
assert 'ck_books_stock_non_negative' in constraints
assert 'ck_books_price_positive' in constraints
print('PASS: All model checks OK')
"
```
</verification>

<success_criteria>
- app/books/ module exists with __init__.py, models.py, schemas.py, repository.py, service.py
- Genre and Book models inherit from Base with correct field types (Numeric(10,2) for price, etc.)
- Alembic migration file exists, creates genres before books (FK order), includes CHECK CONSTRAINTs and all indexes
- alembic/env.py imports Book and Genre for autogenerate discovery
- ISBN validation correctly implements ISBN-10 (mod 11) and ISBN-13 (mod 10) checksum algorithms
- BookService raises 404 AppError for missing books and 409 AppError for ISBN conflicts
- All existing tests still pass
- ruff check passes with zero violations
</success_criteria>

<output>
After completion, create `.planning/phases/04-catalog/04-01-SUMMARY.md`
</output>
