---
phase: 04-catalog
plan: "03"
type: tdd
wave: 3
depends_on:
  - "04-02"
files_modified:
  - tests/test_catalog.py
autonomous: true
requirements:
  - CATL-01
  - CATL-02
  - CATL-03
  - CATL-04
  - CATL-05

must_haves:
  truths:
    - "POST /books creates a book and returns 201 with the book record including all provided fields"
    - "POST /books with invalid ISBN checksum returns 422"
    - "POST /books with duplicate ISBN returns 409"
    - "PUT /books/{id} updates book fields and returns 200 with updated data"
    - "DELETE /books/{id} removes the book and GET /books/{id} returns 404 afterwards"
    - "PATCH /books/{id}/stock sets stock_quantity and the value is reflected in subsequent GET"
    - "POST /genres creates a genre returning 201; GET /genres lists it"
    - "Non-admin requests to write endpoints return 403"
    - "Requests to missing books return 404"
  artifacts:
    - path: "tests/test_catalog.py"
      provides: "Integration tests for all catalog endpoints"
      contains: "test_create_book"
  key_links:
    - from: "tests/test_catalog.py"
      to: "app/books/router.py"
      via: "AsyncClient requests to /books and /genres endpoints"
      pattern: "await client.post.*books"
    - from: "tests/test_catalog.py"
      to: "tests/conftest.py"
      via: "client and db_session fixtures; admin_headers fixture creates admin user and logs in"
      pattern: "admin_headers"
---

<objective>
Implement integration tests for all catalog endpoints using TDD. Tests cover the full happy-path and error-path behavior for CATL-01 through CATL-05 via HTTP requests against the FastAPI app.

Purpose: TDD provides design benefit by verifying HTTP contracts before considering the phase complete. Tests also serve as the authoritative success gate for all 5 catalog requirements.
Output: tests/test_catalog.py with 15+ test cases covering all endpoints.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-catalog/04-CONTEXT.md
@.planning/phases/04-catalog/04-RESEARCH.md
@.planning/phases/04-catalog/04-02-SUMMARY.md
@tests/conftest.py
@tests/test_auth.py
</context>

<feature>
  <name>Catalog endpoint integration tests</name>
  <files>tests/test_catalog.py, tests/conftest.py</files>
  <behavior>
All catalog endpoints tested via HTTP against the FastAPI ASGI app with test DB override.

Admin fixture: admin_headers creates an admin user (via UserRepository directly, not HTTP) and logs in to get a valid Authorization: Bearer token. Mirrors the pattern from test_auth.py.

Happy path cases:
- POST /books with title+author+price only → 201, stock_quantity=0, isbn=null
- POST /books with all fields including valid ISBN-13 → 201, all fields preserved
- POST /books with genre_id linking to existing genre → 201, genre_id reflected
- GET /books/{id} for existing book → 200, correct fields
- PUT /books/{id} updating title and price → 200, updated values reflected
- DELETE /books/{id} → 204; subsequent GET → 404
- PATCH /books/{id}/stock → 200, stock_quantity updated to requested value
- POST /genres → 201; GET /genres → list includes new genre

Error path cases:
- POST /books with invalid ISBN checksum → 422
- POST /books with duplicate ISBN → 409 with code BOOK_ISBN_CONFLICT
- PUT /books/{id} for non-existent book → 404 with code BOOK_NOT_FOUND
- DELETE /books/{id} for non-existent book → 404
- PATCH /books/{id}/stock for non-existent book → 404
- POST /genres with duplicate name → 409 with code GENRE_CONFLICT
- POST /books without admin token → 403
- PUT /books/{id} without admin token → 403
- DELETE /books/{id} without admin token → 403
- PATCH /books/{id}/stock without admin token → 403
- POST /genres without admin token → 403
  </behavior>
  <implementation>
Follow RED → GREEN → REFACTOR cycle:

RED: Write test file with all test cases → run pytest tests/test_catalog.py → all tests MUST fail (endpoints not yet tested) or pass immediately if endpoints are correct (GREEN is valid since endpoints exist from Plan 02).

Since the endpoints ARE implemented (Plan 02 is complete), tests should go GREEN after initial run. TDD here validates the implementation matches the contract spec.

Use pytest_asyncio.fixture for admin_headers and book_headers (user fixture, for 403 testing).

For 403 tests: create a regular user (not admin) and use their token. Alternatively, use no token at all and check for 401/403 (unauthenticated returns 401 via OAuth2PasswordBearer, not 403).

Note on auth behavior: Unauthenticated requests to AdminUser-guarded endpoints return 401 (OAuth2 scheme rejects missing token before reaching require_admin). Only authenticated non-admin users get 403. Test accordingly.
  </implementation>
</feature>

<tasks>

<task type="auto">
  <name>Task 1: Write catalog integration tests</name>
  <files>tests/test_catalog.py</files>
  <action>
Create `tests/test_catalog.py`. Use `pytest_asyncio.fixture` for setup (matching the conftest.py and test_auth.py patterns).

```python
"""Integration tests for catalog endpoints (Phase 4).

Tests cover:
  - CATL-01: POST /books (create with all metadata)
  - CATL-02: PUT /books/{id} (edit book details)
  - CATL-03: DELETE /books/{id} (delete book)
  - CATL-04: PATCH /books/{id}/stock (update stock quantity)
  - CATL-05: POST /genres, GET /genres (genre taxonomy)
"""
import pytest
import pytest_asyncio
from httpx import AsyncClient
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.security import hash_password
from app.users.repository import UserRepository


@pytest_asyncio.fixture
async def admin_headers(client: AsyncClient, db_session: AsyncSession) -> dict:
    """Create an admin user and return Authorization headers with valid bearer token."""
    repo = UserRepository(db_session)
    hashed = await hash_password("adminpass123")
    user = await repo.create(email="catalog_admin@example.com", hashed_password=hashed)
    await repo.set_role_admin(user.id)
    await db_session.flush()

    resp = await client.post(
        "/auth/login",
        json={"email": "catalog_admin@example.com", "password": "adminpass123"},
    )
    assert resp.status_code == 200, f"Admin login failed: {resp.json()}"
    return {"Authorization": f"Bearer {resp.json()['access_token']}"}


@pytest_asyncio.fixture
async def user_headers(client: AsyncClient, db_session: AsyncSession) -> dict:
    """Create a regular user and return Authorization headers (non-admin)."""
    repo = UserRepository(db_session)
    hashed = await hash_password("userpass123")
    await repo.create(email="catalog_user@example.com", hashed_password=hashed)
    await db_session.flush()

    resp = await client.post(
        "/auth/login",
        json={"email": "catalog_user@example.com", "password": "userpass123"},
    )
    assert resp.status_code == 200
    return {"Authorization": f"Bearer {resp.json()['access_token']}"}


# ---------------------------------------------------------------------------
# CATL-05: Genre taxonomy
# ---------------------------------------------------------------------------

@pytest.mark.asyncio
async def test_create_genre(client: AsyncClient, admin_headers: dict) -> None:
    """Admin can create a genre; it returns 201 with id and name."""
    resp = await client.post("/genres", json={"name": "Fantasy"}, headers=admin_headers)
    assert resp.status_code == 201
    data = resp.json()
    assert data["name"] == "Fantasy"
    assert "id" in data


@pytest.mark.asyncio
async def test_list_genres_public(client: AsyncClient, admin_headers: dict) -> None:
    """GET /genres is public; returns list including created genre."""
    await client.post("/genres", json={"name": "Science Fiction"}, headers=admin_headers)
    resp = await client.get("/genres")
    assert resp.status_code == 200
    names = [g["name"] for g in resp.json()]
    assert "Science Fiction" in names


@pytest.mark.asyncio
async def test_create_genre_duplicate_returns_409(
    client: AsyncClient, admin_headers: dict
) -> None:
    """Duplicate genre name returns 409 with GENRE_CONFLICT code."""
    await client.post("/genres", json={"name": "Mystery"}, headers=admin_headers)
    resp = await client.post("/genres", json={"name": "Mystery"}, headers=admin_headers)
    assert resp.status_code == 409
    assert resp.json()["code"] == "GENRE_CONFLICT"


@pytest.mark.asyncio
async def test_create_genre_requires_admin(client: AsyncClient, user_headers: dict) -> None:
    """Non-admin users cannot create genres (403)."""
    resp = await client.post("/genres", json={"name": "Thriller"}, headers=user_headers)
    assert resp.status_code == 403


# ---------------------------------------------------------------------------
# CATL-01: Create book
# ---------------------------------------------------------------------------

@pytest.mark.asyncio
async def test_create_book_minimal(client: AsyncClient, admin_headers: dict) -> None:
    """Admin can create a book with only required fields; stock defaults to 0."""
    resp = await client.post(
        "/books",
        json={"title": "Dune", "author": "Frank Herbert", "price": "15.99"},
        headers=admin_headers,
    )
    assert resp.status_code == 201
    data = resp.json()
    assert data["title"] == "Dune"
    assert data["author"] == "Frank Herbert"
    assert float(data["price"]) == 15.99
    assert data["stock_quantity"] == 0
    assert data["isbn"] is None
    assert data["genre_id"] is None
    assert "id" in data


@pytest.mark.asyncio
async def test_create_book_all_fields(client: AsyncClient, admin_headers: dict) -> None:
    """Admin can create a book with all optional fields including valid ISBN-13."""
    # First create a genre
    genre_resp = await client.post(
        "/genres", json={"name": "Classic"}, headers=admin_headers
    )
    genre_id = genre_resp.json()["id"]

    resp = await client.post(
        "/books",
        json={
            "title": "The Great Gatsby",
            "author": "F. Scott Fitzgerald",
            "price": "12.50",
            "isbn": "9780743273565",
            "genre_id": genre_id,
            "description": "A novel set in the Jazz Age.",
            "cover_image_url": "https://example.com/gatsby.jpg",
            "publish_date": "1925-04-10",
        },
        headers=admin_headers,
    )
    assert resp.status_code == 201
    data = resp.json()
    assert data["isbn"] == "9780743273565"
    assert data["genre_id"] == genre_id
    assert data["description"] == "A novel set in the Jazz Age."
    assert data["cover_image_url"] == "https://example.com/gatsby.jpg"
    assert data["publish_date"] == "1925-04-10"


@pytest.mark.asyncio
async def test_create_book_invalid_isbn_checksum_returns_422(
    client: AsyncClient, admin_headers: dict
) -> None:
    """Invalid ISBN checksum returns 422 (validation error)."""
    resp = await client.post(
        "/books",
        json={"title": "Bad ISBN Book", "author": "Author", "price": "9.99", "isbn": "9780306406158"},
        headers=admin_headers,
    )
    assert resp.status_code == 422


@pytest.mark.asyncio
async def test_create_book_duplicate_isbn_returns_409(
    client: AsyncClient, admin_headers: dict
) -> None:
    """Duplicate ISBN returns 409 with BOOK_ISBN_CONFLICT code."""
    payload = {"title": "Book A", "author": "Author", "price": "10.00", "isbn": "9780743273565"}
    await client.post("/books", json=payload, headers=admin_headers)
    resp = await client.post(
        "/books",
        json={"title": "Book B", "author": "Author", "price": "12.00", "isbn": "9780743273565"},
        headers=admin_headers,
    )
    assert resp.status_code == 409
    assert resp.json()["code"] == "BOOK_ISBN_CONFLICT"


@pytest.mark.asyncio
async def test_create_book_requires_admin(client: AsyncClient, user_headers: dict) -> None:
    """Non-admin users cannot create books (403)."""
    resp = await client.post(
        "/books",
        json={"title": "No Permission", "author": "Author", "price": "9.99"},
        headers=user_headers,
    )
    assert resp.status_code == 403


# ---------------------------------------------------------------------------
# GET /books/{id} (public read)
# ---------------------------------------------------------------------------

@pytest.mark.asyncio
async def test_get_book(client: AsyncClient, admin_headers: dict) -> None:
    """GET /books/{id} is public and returns the created book."""
    create_resp = await client.post(
        "/books",
        json={"title": "To Kill a Mockingbird", "author": "Harper Lee", "price": "11.99"},
        headers=admin_headers,
    )
    book_id = create_resp.json()["id"]
    resp = await client.get(f"/books/{book_id}")
    assert resp.status_code == 200
    assert resp.json()["title"] == "To Kill a Mockingbird"


@pytest.mark.asyncio
async def test_get_book_not_found(client: AsyncClient) -> None:
    """GET /books/{id} for non-existent book returns 404 with BOOK_NOT_FOUND code."""
    resp = await client.get("/books/999999")
    assert resp.status_code == 404
    assert resp.json()["code"] == "BOOK_NOT_FOUND"


# ---------------------------------------------------------------------------
# CATL-02: Edit book
# ---------------------------------------------------------------------------

@pytest.mark.asyncio
async def test_update_book(client: AsyncClient, admin_headers: dict) -> None:
    """Admin can update book title and price; GET confirms the changes."""
    create_resp = await client.post(
        "/books",
        json={"title": "Original Title", "author": "Author", "price": "10.00"},
        headers=admin_headers,
    )
    book_id = create_resp.json()["id"]

    resp = await client.put(
        f"/books/{book_id}",
        json={"title": "Updated Title", "price": "14.99"},
        headers=admin_headers,
    )
    assert resp.status_code == 200
    data = resp.json()
    assert data["title"] == "Updated Title"
    assert float(data["price"]) == 14.99
    # Author unchanged
    assert data["author"] == "Author"


@pytest.mark.asyncio
async def test_update_book_not_found(client: AsyncClient, admin_headers: dict) -> None:
    """PUT /books/{id} for non-existent book returns 404."""
    resp = await client.put(
        "/books/999999",
        json={"title": "Ghost Book"},
        headers=admin_headers,
    )
    assert resp.status_code == 404
    assert resp.json()["code"] == "BOOK_NOT_FOUND"


@pytest.mark.asyncio
async def test_update_book_requires_admin(
    client: AsyncClient, admin_headers: dict, user_headers: dict
) -> None:
    """Non-admin users cannot update books (403)."""
    create_resp = await client.post(
        "/books",
        json={"title": "Protected Book", "author": "Author", "price": "10.00"},
        headers=admin_headers,
    )
    book_id = create_resp.json()["id"]
    resp = await client.put(
        f"/books/{book_id}", json={"title": "Hacked"}, headers=user_headers
    )
    assert resp.status_code == 403


# ---------------------------------------------------------------------------
# CATL-03: Delete book
# ---------------------------------------------------------------------------

@pytest.mark.asyncio
async def test_delete_book(client: AsyncClient, admin_headers: dict) -> None:
    """Admin can delete a book; subsequent GET returns 404."""
    create_resp = await client.post(
        "/books",
        json={"title": "Doomed Book", "author": "Author", "price": "9.99"},
        headers=admin_headers,
    )
    book_id = create_resp.json()["id"]

    del_resp = await client.delete(f"/books/{book_id}", headers=admin_headers)
    assert del_resp.status_code == 204

    get_resp = await client.get(f"/books/{book_id}")
    assert get_resp.status_code == 404


@pytest.mark.asyncio
async def test_delete_book_not_found(client: AsyncClient, admin_headers: dict) -> None:
    """DELETE /books/{id} for non-existent book returns 404."""
    resp = await client.delete("/books/999999", headers=admin_headers)
    assert resp.status_code == 404


@pytest.mark.asyncio
async def test_delete_book_requires_admin(
    client: AsyncClient, admin_headers: dict, user_headers: dict
) -> None:
    """Non-admin users cannot delete books (403)."""
    create_resp = await client.post(
        "/books",
        json={"title": "Undeleteable Book", "author": "Author", "price": "9.99"},
        headers=admin_headers,
    )
    book_id = create_resp.json()["id"]
    resp = await client.delete(f"/books/{book_id}", headers=user_headers)
    assert resp.status_code == 403


# ---------------------------------------------------------------------------
# CATL-04: Stock management
# ---------------------------------------------------------------------------

@pytest.mark.asyncio
async def test_update_stock(client: AsyncClient, admin_headers: dict) -> None:
    """Admin can set stock quantity; GET reflects the updated value."""
    create_resp = await client.post(
        "/books",
        json={"title": "Stocked Book", "author": "Author", "price": "20.00"},
        headers=admin_headers,
    )
    book_id = create_resp.json()["id"]
    assert create_resp.json()["stock_quantity"] == 0

    stock_resp = await client.patch(
        f"/books/{book_id}/stock", json={"quantity": 50}, headers=admin_headers
    )
    assert stock_resp.status_code == 200
    assert stock_resp.json()["stock_quantity"] == 50

    # Verify GET reflects the change
    get_resp = await client.get(f"/books/{book_id}")
    assert get_resp.json()["stock_quantity"] == 50


@pytest.mark.asyncio
async def test_update_stock_to_zero(client: AsyncClient, admin_headers: dict) -> None:
    """Admin can set stock to 0 (boundary value)."""
    create_resp = await client.post(
        "/books",
        json={"title": "Zero Stock Book", "author": "Author", "price": "8.99"},
        headers=admin_headers,
    )
    book_id = create_resp.json()["id"]
    await client.patch(f"/books/{book_id}/stock", json={"quantity": 10}, headers=admin_headers)

    resp = await client.patch(
        f"/books/{book_id}/stock", json={"quantity": 0}, headers=admin_headers
    )
    assert resp.status_code == 200
    assert resp.json()["stock_quantity"] == 0


@pytest.mark.asyncio
async def test_update_stock_requires_admin(
    client: AsyncClient, admin_headers: dict, user_headers: dict
) -> None:
    """Non-admin users cannot update stock (403)."""
    create_resp = await client.post(
        "/books",
        json={"title": "Stock Protected", "author": "Author", "price": "9.99"},
        headers=admin_headers,
    )
    book_id = create_resp.json()["id"]
    resp = await client.patch(
        f"/books/{book_id}/stock", json={"quantity": 100}, headers=user_headers
    )
    assert resp.status_code == 403


@pytest.mark.asyncio
async def test_update_stock_not_found(client: AsyncClient, admin_headers: dict) -> None:
    """PATCH /books/{id}/stock for non-existent book returns 404."""
    resp = await client.patch(
        "/books/999999/stock", json={"quantity": 5}, headers=admin_headers
    )
    assert resp.status_code == 404
```

Run the tests immediately after creation:
```bash
cd D:/Python/claude-test && poetry run pytest tests/test_catalog.py -v
```

If any test fails due to implementation issues (not test logic), inspect the failure message and fix the root cause in the implementation file (app/books/router.py or app/books/service.py). Do NOT modify the test assertions to make tests pass — fix the implementation.

Common fixes to check if tests fail:
- If 403 tests return 401 instead: OAuth2PasswordBearer returns 401 for missing token, 403 for wrong role. Adjust test to check for 401 when no token is provided, or provide a user token for 403 cases. The tests above use `user_headers` (authenticated non-admin) which should return 403.
- If price returns as string "15.99" instead of float: Pydantic v2 serializes Decimal as number when using model_validate(); verify with `float(data["price"])` in assertions (already done above).
- If duplicate ISBN test fails with 500: Check IntegrityError handling in BookService.create_book() — ensure `"isbn" in str(e.orig).lower()` matches the actual PostgreSQL error message.
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && poetry run pytest tests/test_catalog.py -v --tb=short</automated>
    <manual>Confirm all 22+ test cases pass. Review any failures for implementation issues vs test logic issues.</manual>
  </verify>
  <done>
    - tests/test_catalog.py exists with tests covering CATL-01 through CATL-05
    - admin_headers and user_headers fixtures create test users with appropriate roles
    - All happy-path tests: create book, get book, update book, delete book, update stock, create genre, list genres
    - All error-path tests: invalid ISBN (422), duplicate ISBN (409), duplicate genre (409), not found (404), non-admin (403)
    - All tests pass: poetry run pytest tests/test_catalog.py reports 0 failures
    - Full test suite passes: poetry run pytest tests/ reports 0 failures
  </done>
</task>

</tasks>

<verification>
Run the full test suite to confirm all catalog tests pass and no regressions in prior phases:

```bash
cd D:/Python/claude-test && poetry run pytest tests/ -v
```

Run ruff on the test file:

```bash
cd D:/Python/claude-test && poetry run ruff check tests/test_catalog.py && poetry run ruff format --check tests/test_catalog.py
```

Check test count is reasonable:

```bash
cd D:/Python/claude-test && poetry run pytest tests/test_catalog.py --collect-only -q
```
</verification>

<success_criteria>
- tests/test_catalog.py exists with 20+ test cases
- All 5 requirement groups covered: book creation (CATL-01), book edit (CATL-02), book delete (CATL-03), stock update (CATL-04), genre management (CATL-05)
- Admin-only enforcement verified: non-admin gets 403 for all write operations
- Error paths verified: 422 for invalid ISBN, 409 for conflicts, 404 for missing resources
- All tests pass: pytest tests/test_catalog.py exits 0
- Full test suite passes: pytest tests/ exits 0 (no regressions in auth/OAuth tests)
- ruff check passes with zero violations
</success_criteria>

<output>
After completion, create `.planning/phases/04-catalog/04-03-SUMMARY.md`
</output>
