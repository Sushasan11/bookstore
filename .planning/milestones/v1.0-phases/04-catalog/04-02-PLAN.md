---
phase: 04-catalog
plan: "02"
type: execute
wave: 2
depends_on:
  - "04-01"
files_modified:
  - app/books/router.py
  - app/main.py
autonomous: true
requirements:
  - CATL-01
  - CATL-02
  - CATL-03
  - CATL-04
  - CATL-05

must_haves:
  truths:
    - "Admin can POST /books with title, author, price (required) and optional ISBN, genre, description, cover image URL, publish date — returns 201 with book record"
    - "Admin can PUT /books/{id} to update any book field — returns 200 with updated book"
    - "Admin can DELETE /books/{id} — returns 204 No Content"
    - "GET /books/{id} returns book details (public, no auth required)"
    - "Admin can PATCH /books/{id}/stock with absolute quantity — returns 200 with updated book"
    - "Admin can POST /genres to add a genre — returns 201 with genre record"
    - "GET /genres returns all genres as a list (public, no auth required)"
    - "Non-admin requests to write endpoints return 403"
  artifacts:
    - path: "app/books/router.py"
      provides: "All catalog HTTP endpoints"
      contains: "router = APIRouter"
    - path: "app/main.py"
      provides: "Books router registered in FastAPI app"
      contains: "books_router"
  key_links:
    - from: "app/books/router.py"
      to: "app/books/service.py"
      via: "BookService instantiated via _make_service(db) in each route"
      pattern: "_make_service"
    - from: "app/books/router.py"
      to: "app/core.deps"
      via: "AdminUser dependency guards all write endpoints"
      pattern: "AdminUser"
    - from: "app/main.py"
      to: "app/books/router.py"
      via: "application.include_router(books_router)"
      pattern: "include_router"
---

<objective>
Wire all catalog HTTP endpoints into the FastAPI app: POST/PUT/DELETE /books, GET /books/{id}, PATCH /books/{id}/stock, POST/GET /genres.

Purpose: This is the HTTP surface that makes all catalog CRUD available. The domain layer from Plan 01 is complete; this plan connects it to HTTP routes using the same AdminUser guard and DbSession patterns as the auth router.
Output: app/books/router.py with all 7 endpoints; app/main.py updated to include the books router.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-catalog/04-CONTEXT.md
@.planning/phases/04-catalog/04-RESEARCH.md
@.planning/phases/04-catalog/04-01-SUMMARY.md
@app/core/deps.py
@app/main.py
@app/users/router.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create catalog router with all 7 endpoints</name>
  <files>app/books/router.py</files>
  <action>
Create `app/books/router.py`. All write endpoints require `AdminUser` (imported from `app.core.deps`). GET endpoints are public (no auth).

```python
"""Catalog HTTP endpoints: book CRUD, stock management, genre taxonomy."""

from fastapi import APIRouter, status

from app.books.repository import BookRepository, GenreRepository
from app.books.schemas import (
    BookCreate,
    BookResponse,
    BookUpdate,
    GenreCreate,
    GenreResponse,
    StockUpdate,
)
from app.books.service import BookService
from app.core.deps import AdminUser, DbSession

router = APIRouter(tags=["catalog"])


def _make_service(db: DbSession) -> BookService:
    """Instantiate BookService with repositories bound to the current DB session."""
    return BookService(
        book_repo=BookRepository(db),
        genre_repo=GenreRepository(db),
    )


@router.post("/books", response_model=BookResponse, status_code=status.HTTP_201_CREATED)
async def create_book(body: BookCreate, db: DbSession, admin: AdminUser) -> BookResponse:
    """Create a new book. Admin only.

    Required: title, author, price.
    Optional: isbn (validated checksum), genre_id, description, cover_image_url, publish_date.
    409 if ISBN already exists.
    """
    service = _make_service(db)
    book = await service.create_book(body)
    return BookResponse.model_validate(book)


@router.get("/books/{book_id}", response_model=BookResponse)
async def get_book(book_id: int, db: DbSession) -> BookResponse:
    """Get book by ID. Public — no auth required.

    404 if book not found.
    Used by tests and downstream features to verify book state.
    """
    service = _make_service(db)
    book = await service._get_book_or_404(book_id)
    return BookResponse.model_validate(book)


@router.put("/books/{book_id}", response_model=BookResponse)
async def update_book(
    book_id: int, body: BookUpdate, db: DbSession, admin: AdminUser
) -> BookResponse:
    """Update book fields. Admin only.

    All fields optional — only provided fields are updated.
    404 if book not found. 409 if ISBN conflicts with existing book.
    """
    service = _make_service(db)
    book = await service.update_book(book_id, body)
    return BookResponse.model_validate(book)


@router.delete("/books/{book_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_book(book_id: int, db: DbSession, admin: AdminUser) -> None:
    """Delete a book permanently. Admin only.

    Hard delete — Phase 4 has no FK references to books from other tables yet.
    404 if book not found.
    """
    service = _make_service(db)
    await service.delete_book(book_id)


@router.patch("/books/{book_id}/stock", response_model=BookResponse)
async def update_stock(
    book_id: int, body: StockUpdate, db: DbSession, admin: AdminUser
) -> BookResponse:
    """Set absolute stock quantity. Admin only.

    quantity >= 0 enforced by Pydantic (ge=0) and DB CHECK CONSTRAINT.
    Absolute set (not increment/decrement) — Phase 7 handles stock decrement via SELECT FOR UPDATE.
    404 if book not found.
    """
    service = _make_service(db)
    book = await service.set_stock(book_id, body.quantity)
    return BookResponse.model_validate(book)


@router.post("/genres", response_model=GenreResponse, status_code=status.HTTP_201_CREATED)
async def create_genre(body: GenreCreate, db: DbSession, admin: AdminUser) -> GenreResponse:
    """Create a new genre. Admin only.

    409 if genre name already exists (case-sensitive).
    """
    service = _make_service(db)
    genre = await service.create_genre(body.name)
    return GenreResponse.model_validate(genre)


@router.get("/genres", response_model=list[GenreResponse])
async def list_genres(db: DbSession) -> list[GenreResponse]:
    """List all genres alphabetically. Public — no auth required.

    Genres are reference data. Empty list if no genres yet.
    """
    service = _make_service(db)
    genres = await service.list_genres()
    return [GenreResponse.model_validate(g) for g in genres]
```

Run `ruff check app/books/router.py` and fix any violations.

Verify endpoints are correctly defined:
```bash
cd D:/Python/claude-test && poetry run python -c "
from app.books.router import router
routes = {r.path: list(r.methods) for r in router.routes}
print('Catalog routes:', routes)
assert '/books' in routes
assert '/books/{book_id}' in routes
assert '/books/{book_id}/stock' in routes
assert '/genres' in routes
print('All catalog routes registered')
"
```
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && poetry run python -c "
from app.books.router import router
routes = {r.path: set(r.methods) for r in router.routes}
print('Routes:', {k: list(v) for k, v in routes.items()})
assert '/books' in routes, 'POST /books not found'
assert 'POST' in routes['/books']
assert '/books/{book_id}' in routes
assert 'GET' in routes['/books/{book_id}']
assert 'PUT' in routes['/books/{book_id}']
assert 'DELETE' in routes['/books/{book_id}']
assert '/books/{book_id}/stock' in routes
assert 'PATCH' in routes['/books/{book_id}/stock']
assert '/genres' in routes
assert 'POST' in routes['/genres']
assert 'GET' in routes['/genres']
print('All 7 catalog routes registered correctly')
"</automated>
  </verify>
  <done>
    - app/books/router.py defines all 7 routes:
      - POST /books (201, AdminUser required)
      - GET /books/{book_id} (200, public)
      - PUT /books/{book_id} (200, AdminUser required)
      - DELETE /books/{book_id} (204, AdminUser required)
      - PATCH /books/{book_id}/stock (200, AdminUser required)
      - POST /genres (201, AdminUser required)
      - GET /genres (200, public)
    - _make_service(db) factory instantiates BookService with both repositories
    - All write routes include AdminUser as a parameter (enforcing admin-only access)
    - ruff check passes with zero violations
  </done>
</task>

<task type="auto">
  <name>Task 2: Register books router in main.py</name>
  <files>app/main.py</files>
  <action>
READ `app/main.py` to see its current content (it currently registers health_router and auth_router).

Add the books router import and include it in `create_app()`. The existing file imports from app.users.router and app.core.health — add books router alongside them:

```python
# Add to imports (after existing router imports):
from app.books.router import router as books_router

# Add inside create_app() function, after existing include_router calls:
application.include_router(books_router)
```

The final include_router section should look like:
```python
# Include routers
application.include_router(health_router)
application.include_router(auth_router)
application.include_router(books_router)
```

Run `ruff check app/main.py` and fix any violations.

Verify all catalog routes are visible in the app:
```bash
cd D:/Python/claude-test && poetry run python -c "
from app.main import app
routes = [r.path for r in app.routes]
print('All routes:', routes)
catalog_routes = [r for r in routes if r.startswith('/books') or r.startswith('/genres')]
print('Catalog routes:', catalog_routes)
assert '/books' in routes, 'POST /books missing'
assert '/books/{book_id}' in routes
assert '/books/{book_id}/stock' in routes
assert '/genres' in routes
print('All catalog routes visible in app')
"
```
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && poetry run python -c "
from app.main import app
routes = [r.path for r in app.routes]
assert '/books' in routes, f'POST /books not in {routes}'
assert '/books/{book_id}' in routes
assert '/books/{book_id}/stock' in routes
assert '/genres' in routes
# Verify existing routes still present
assert '/health' in routes
assert '/auth/register' in routes
print('Catalog and existing routes all registered:', [r for r in routes if r not in ['/openapi.json', '/docs', '/redoc', '/docs/oauth2-redirect']])
"</automated>
  </verify>
  <done>
    - app/main.py imports books_router from app.books.router
    - books_router is included via application.include_router(books_router) in create_app()
    - All 7 catalog routes are visible in the FastAPI app (books and genres)
    - Existing routes (/health, /auth/*) are unchanged and still registered
    - ruff check passes with zero violations
  </done>
</task>

</tasks>

<verification>
Run the full test suite to confirm no regressions:

```bash
cd D:/Python/claude-test && poetry run pytest tests/ -v
```

Verify all catalog routes appear in the OpenAPI schema:

```bash
cd D:/Python/claude-test && poetry run python -c "
from app.main import app
schema = app.openapi()
paths = list(schema['paths'].keys())
catalog_paths = [p for p in paths if p.startswith('/books') or p.startswith('/genres')]
print('Catalog paths in OpenAPI schema:', catalog_paths)
assert '/books' in catalog_paths
assert '/books/{book_id}' in catalog_paths
assert '/books/{book_id}/stock' in catalog_paths
assert '/genres' in catalog_paths
print('All catalog endpoints in OpenAPI schema')
"
```

Run ruff on all modified files:

```bash
cd D:/Python/claude-test && poetry run ruff check app/books/router.py app/main.py && poetry run ruff format --check app/books/router.py app/main.py
```
</verification>

<success_criteria>
- POST /books: accepts {title, author, price, isbn?, genre_id?, description?, cover_image_url?, publish_date?}, requires admin, returns 201 + BookResponse
- GET /books/{id}: public, returns 200 + BookResponse or 404
- PUT /books/{id}: accepts partial BookUpdate fields, requires admin, returns 200 + BookResponse
- DELETE /books/{id}: requires admin, returns 204
- PATCH /books/{id}/stock: accepts {quantity: int >= 0}, requires admin, returns 200 + BookResponse
- POST /genres: accepts {name}, requires admin, returns 201 + GenreResponse
- GET /genres: public, returns 200 + list[GenreResponse]
- All existing auth and health routes still pass their tests
- ruff check passes with zero violations
</success_criteria>

<output>
After completion, create `.planning/phases/04-catalog/04-02-SUMMARY.md`
</output>
