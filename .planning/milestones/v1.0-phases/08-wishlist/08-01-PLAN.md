---
phase: 08-wishlist
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/wishlist/models.py
  - app/wishlist/schemas.py
  - app/wishlist/repository.py
  - app/wishlist/service.py
  - app/wishlist/router.py
  - alembic/versions/e5f6a7b8c9d0_create_wishlist_items.py
  - alembic/env.py
  - app/main.py
autonomous: true
requirements:
  - ENGM-01
  - ENGM-02

must_haves:
  truths:
    - "An authenticated user can POST /wishlist with a book_id and get 201 with the wishlist item including book details"
    - "An authenticated user can GET /wishlist and see all their saved books with current price and stock_quantity"
    - "An authenticated user can DELETE /wishlist/{book_id} and the book is removed (204)"
    - "Adding a book already on the wishlist returns 409 with WISHLIST_ITEM_DUPLICATE code"
    - "Adding a nonexistent book returns 404 with BOOK_NOT_FOUND code"
  artifacts:
    - path: "app/wishlist/models.py"
      provides: "WishlistItem SQLAlchemy model"
      contains: "class WishlistItem"
    - path: "app/wishlist/repository.py"
      provides: "WishlistRepository with add, get_all_for_user, get_by_user_and_book, delete"
      contains: "class WishlistRepository"
    - path: "app/wishlist/service.py"
      provides: "WishlistService with add, list, remove"
      contains: "class WishlistService"
    - path: "app/wishlist/router.py"
      provides: "POST /wishlist, GET /wishlist, DELETE /wishlist/{book_id}"
      exports: ["router"]
    - path: "alembic/versions/e5f6a7b8c9d0_create_wishlist_items.py"
      provides: "wishlist_items table migration"
      contains: "wishlist_items"
  key_links:
    - from: "app/wishlist/router.py"
      to: "app/wishlist/service.py"
      via: "_make_service(db) factory"
      pattern: "_make_service"
    - from: "app/wishlist/service.py"
      to: "app/wishlist/repository.py"
      via: "WishlistRepository dependency"
      pattern: "self\\.wishlist_repo"
    - from: "app/wishlist/service.py"
      to: "app/books/repository.py"
      via: "BookRepository.get_by_id for existence check"
      pattern: "self\\.book_repo\\.get_by_id"
    - from: "app/main.py"
      to: "app/wishlist/router.py"
      via: "include_router registration"
      pattern: "include_router.*wishlist"
    - from: "alembic/env.py"
      to: "app/wishlist/models.py"
      via: "model import for metadata discovery"
      pattern: "from app\\.wishlist\\.models import"
---

<objective>
Complete wishlist vertical slice — WishlistItem model, migration, repository, service, schemas, and 3 REST endpoints (POST /wishlist, GET /wishlist, DELETE /wishlist/{book_id}).

Purpose: Deliver the full wishlist feature so authenticated users can save books they are interested in but not ready to purchase, with current price and stock visibility.
Output: Working wishlist domain with all endpoints returning correct responses, migration applied, router registered in main.py.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-wishlist/08-RESEARCH.md
@.planning/phases/06-cart/06-01-SUMMARY.md

# Source patterns to follow
@app/cart/models.py
@app/cart/schemas.py
@app/cart/repository.py
@app/cart/service.py
@app/cart/router.py
@alembic/env.py
@app/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: WishlistItem model and Alembic migration</name>
  <files>
    app/wishlist/models.py
    alembic/versions/e5f6a7b8c9d0_create_wishlist_items.py
    alembic/env.py
  </files>
  <action>
**app/wishlist/models.py** — Create WishlistItem SQLAlchemy model:
- `from __future__ import annotations` at top
- `if TYPE_CHECKING: from app.books.models import Book` guard (same pattern as cart/models.py)
- Class `WishlistItem(Base)` with `__tablename__ = "wishlist_items"`
- `__table_args__` with `UniqueConstraint("user_id", "book_id", name="uq_wishlist_items_user_book")`
- Columns: `id` (Integer PK), `user_id` (Integer FK "users.id" ondelete="CASCADE", nullable=False, index=True), `book_id` (Integer FK "books.id" ondelete="CASCADE", nullable=False, index=True), `added_at` (DateTime(timezone=True), server_default=func.now(), nullable=False)
- Relationship: `book: Mapped[Book] = relationship()`
- No quantity column — a book is either on the wishlist or not.
- Use `ondelete="CASCADE"` on book_id (not SET NULL like orders) — wishlist item is meaningless without its book.

**alembic/versions/e5f6a7b8c9d0_create_wishlist_items.py** — Hand-written migration:
- `revision = "e5f6a7b8c9d0"`, `down_revision = "d4e5f6a7b8c9"` (orders migration is current head)
- `upgrade()`: create_table "wishlist_items" with id, user_id, book_id, added_at columns, FK constraints (CASCADE on both), PK, UniqueConstraint "uq_wishlist_items_user_book", then create_index on user_id and book_id
- `downgrade()`: drop indexes then drop_table
- Follow the exact migration format from research (sa.Column, sa.ForeignKeyConstraint, sa.PrimaryKeyConstraint, sa.UniqueConstraint)

**alembic/env.py** — Add model import:
- Add `from app.wishlist.models import WishlistItem  # noqa: F401` after the orders model import line
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && poetry run ruff check app/wishlist/models.py alembic/versions/e5f6a7b8c9d0_create_wishlist_items.py alembic/env.py</automated>
    <manual>Verify migration down_revision chains correctly from d4e5f6a7b8c9</manual>
  </verify>
  <done>WishlistItem model exists with UNIQUE(user_id, book_id), CASCADE on both FKs, migration file chains off orders head, alembic/env.py imports the model</done>
</task>

<task type="auto">
  <name>Task 2: Schemas, repository, service, router, and main.py registration</name>
  <files>
    app/wishlist/schemas.py
    app/wishlist/repository.py
    app/wishlist/service.py
    app/wishlist/router.py
    app/main.py
  </files>
  <action>
**app/wishlist/schemas.py** — Pydantic schemas:
- `WishlistAdd(BaseModel)`: field `book_id: int`
- `BookSummary(BaseModel)`: fields `id: int`, `title: str`, `author: str`, `price: Decimal`, `stock_quantity: int`, `cover_image_url: str | None`; `model_config = {"from_attributes": True}`. Include `stock_quantity` because success criteria require showing "current price and stock status."
- `WishlistItemResponse(BaseModel)`: fields `id: int`, `book_id: int`, `added_at: datetime`, `book: BookSummary`; `model_config = {"from_attributes": True}`
- `WishlistResponse(BaseModel)`: field `items: list[WishlistItemResponse]`

**app/wishlist/repository.py** — WishlistRepository:
- `__init__(self, session: AsyncSession)` storing `self.session`
- `add(self, user_id: int, book_id: int) -> WishlistItem`: create WishlistItem, session.add + flush, catch IntegrityError → rollback → check for "uq_wishlist_items" or "wishlist_items" in str(e.orig).lower() → raise AppError(409, "This book is already on your wishlist", "WISHLIST_ITEM_DUPLICATE", "book_id"). After flush, `await self.session.refresh(item, ["book"])` to load book relationship.
- `get_all_for_user(self, user_id: int) -> list[WishlistItem]`: SELECT with `.where(WishlistItem.user_id == user_id)`, `.options(selectinload(WishlistItem.book))`, `.order_by(WishlistItem.added_at.desc())`, return `list(result.scalars().all())`
- `get_by_user_and_book(self, user_id: int, book_id: int) -> WishlistItem | None`: SELECT with both WHERE clauses, return `result.scalar_one_or_none()`
- `delete(self, item: WishlistItem) -> None`: `await self.session.delete(item)` then `await self.session.flush()`

**app/wishlist/service.py** — WishlistService:
- `__init__(self, wishlist_repo: WishlistRepository, book_repo: BookRepository)`
- `add(self, user_id: int, book_id: int) -> WishlistItem`: First call `self.book_repo.get_by_id(book_id)`, if None raise AppError(404, "Book not found", "BOOK_NOT_FOUND", "book_id"). Then call `self.wishlist_repo.add(user_id, book_id)` and return the item.
- `list(self, user_id: int) -> list[WishlistItem]`: return `self.wishlist_repo.get_all_for_user(user_id)`
- `remove(self, user_id: int, book_id: int) -> None`: call `self.wishlist_repo.get_by_user_and_book(user_id, book_id)`, if None raise AppError(404, "Wishlist item not found", "WISHLIST_ITEM_NOT_FOUND", "book_id"). Then call `self.wishlist_repo.delete(item)`.

**app/wishlist/router.py** — APIRouter:
- `router = APIRouter(prefix="/wishlist", tags=["wishlist"])`
- `_make_service(db: DbSession) -> WishlistService`: instantiate with WishlistRepository(db) and BookRepository(db)
- `POST ""` (status 201, response_model=WishlistItemResponse): extract `user_id = int(current_user["sub"])`, call `service.add(user_id, body.book_id)`, return `WishlistItemResponse.model_validate(item)`
- `GET ""` (response_model=WishlistResponse): extract user_id, call `service.list(user_id)`, return `WishlistResponse(items=[WishlistItemResponse.model_validate(i) for i in items])`
- `DELETE "/{book_id}"` (status 204): extract user_id, call `service.remove(user_id, book_id)`, return None
- All three endpoints require `current_user: CurrentUser` and `db: DbSession` parameters
- Import CurrentUser and DbSession from app.core.deps

**app/main.py** — Register wishlist router:
- Add import: `from app.wishlist.router import router as wishlist_router`
- Add `application.include_router(wishlist_router)` after the orders_admin_router include_router call
- Maintain alphabetical import ordering (books -> cart -> core -> orders -> users -> wishlist) to satisfy ruff I001
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && poetry run ruff check app/wishlist/ app/main.py && poetry run pytest tests/ -x --timeout=30 -q 2>&1 | tail -5</automated>
    <manual>Verify all 3 endpoints appear in route list and existing tests still pass</manual>
  </verify>
  <done>All wishlist endpoints (POST /wishlist 201, GET /wishlist 200, DELETE /wishlist/{book_id} 204) are registered and responding. Existing test suite passes with no regressions. ruff check clean on all modified files.</done>
</task>

</tasks>

<verification>
1. `poetry run ruff check app/wishlist/ alembic/ app/main.py` — zero lint violations
2. `poetry run ruff format --check app/wishlist/ app/main.py` — formatting correct
3. `poetry run pytest tests/ -x -q` — all existing tests pass (108+), no regressions
4. Route inspection: POST /wishlist, GET /wishlist, DELETE /wishlist/{book_id} all registered
</verification>

<success_criteria>
- WishlistItem model with UNIQUE(user_id, book_id) and CASCADE on both FKs
- Migration e5f6a7b8c9d0 chains off d4e5f6a7b8c9 (orders head)
- Repository handles IntegrityError → 409 for duplicate adds
- Service validates book existence (404) before adding to wishlist
- GET /wishlist returns items with current book price and stock_quantity
- DELETE /wishlist/{book_id} uses book_id as path param (natural key, not item_id)
- All 108+ existing tests pass
- ruff check and ruff format clean
</success_criteria>

<output>
After completion, create `.planning/phases/08-wishlist/08-01-SUMMARY.md`
</output>
