---
phase: 02-core-auth
plan: 02
type: execute
wave: 2
depends_on:
  - 02-01
files_modified:
  - app/core/security.py
  - app/core/config.py
  - app/users/schemas.py
autonomous: true
requirements:
  - AUTH-01
  - AUTH-02
  - AUTH-03
  - AUTH-04

must_haves:
  truths:
    - "A plain password can be hashed asynchronously without blocking the event loop"
    - "A hashed password can be verified asynchronously with timing-safe comparison"
    - "A JWT access token can be created with sub, role, jti, iat, exp claims and decoded back correctly"
    - "An opaque refresh token is a cryptographically secure random string (not a JWT)"
    - "Decoding an expired or malformed JWT raises AppError(401) with appropriate error code"
    - "Pydantic schemas reject emails with invalid format and passwords shorter than 8 characters"
  artifacts:
    - path: "app/core/security.py"
      provides: "hash_password, verify_password, create_access_token, decode_access_token, generate_refresh_token"
      contains: "asyncio.to_thread"
    - path: "app/core/config.py"
      provides: "SECRET_KEY, ACCESS_TOKEN_EXPIRE_MINUTES, REFRESH_TOKEN_EXPIRE_DAYS settings"
      contains: "SECRET_KEY"
    - path: "app/users/schemas.py"
      provides: "UserCreate, LoginRequest, RefreshRequest, TokenResponse, UserResponse Pydantic models"
      contains: "class TokenResponse"
  key_links:
    - from: "app/core/security.py"
      to: "app/core/config.py"
      via: "get_settings() call for SECRET_KEY and token TTL values"
      pattern: "get_settings"
    - from: "app/core/security.py"
      to: "app/core/exceptions.py"
      via: "AppError raised on JWT decode failure"
      pattern: "AppError"
---

<objective>
Implement the JWT security module (password hashing, access token encode/decode, refresh token generation) and all Pydantic request/response schemas for the auth endpoints.

Purpose: Plan 03 (repository + service) and Plan 04 (endpoints) both depend on security.py and schemas.py. Building them in Wave 2 alongside each other (no file conflicts) keeps the dependency chain tight.
Output: app/core/security.py with 5 async/sync functions, app/users/schemas.py with 5 Pydantic models, app/core/config.py extended with token config fields.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-auth/02-CONTEXT.md
@.planning/phases/02-core-auth/02-RESEARCH.md
@.planning/phases/02-core-auth/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement JWT security module and extend config</name>
  <files>app/core/security.py, app/core/config.py</files>
  <action>
First, check what currently exists in `app/core/security.py` (it was scaffolded as a placeholder in Phase 1) and `app/core/config.py` (has DATABASE_URL, ENVIRONMENT, APP_NAME at minimum). Read both files before modifying.

Extend `app/core/config.py` — add these three fields to the Settings class (with sensible defaults):

```python
SECRET_KEY: str = "change-me-in-production-at-least-32-chars"
ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
REFRESH_TOKEN_EXPIRE_DAYS: int = 7
```

SECRET_KEY MUST be loaded from the .env file in production. Add a validator or note that this default must be overridden. If there is already a SECRET_KEY in config, do not duplicate it.

Replace `app/core/security.py` with the full implementation:

```python
import asyncio
import secrets
import uuid
from datetime import UTC, datetime, timedelta

import jwt
from jwt.exceptions import ExpiredSignatureError, InvalidTokenError
from pwdlib import PasswordHash

from app.core.config import get_settings

ALGORITHM = "HS256"

# Initialize once at module level — not per-request (Argon2id with secure defaults)
_password_hash = PasswordHash.recommended()


async def hash_password(plain: str) -> str:
    """Hash a plain password in a thread pool.

    Argon2 is CPU-intensive (~50-200ms). Running in asyncio.to_thread()
    prevents blocking the event loop during registration/login.
    """
    return await asyncio.to_thread(_password_hash.hash, plain)


async def verify_password(plain: str, hashed: str) -> bool:
    """Verify a plain password against a hash in a thread pool."""
    return await asyncio.to_thread(_password_hash.verify, plain, hashed)


def create_access_token(user_id: int, role: str) -> str:
    """Create a short-lived JWT access token (HS256).

    Claims: sub (str user_id), role, jti (UUID), iat, exp (15-min TTL).
    Role is embedded in claims — no DB lookup needed for authorization.
    HS256 is correct for single-service API; RS256 only needed for
    multi-service token verification without shared secret.
    """
    settings = get_settings()
    now = datetime.now(UTC)
    payload = {
        "sub": str(user_id),
        "role": role,
        "jti": str(uuid.uuid4()),
        "iat": now,
        "exp": now + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES),
    }
    return jwt.encode(payload, settings.SECRET_KEY, algorithm=ALGORITHM)


def decode_access_token(token: str) -> dict:
    """Decode and verify a JWT access token.

    Returns the full payload dict on success.
    Raises AppError(401) on expired or invalid token.
    MUST pass algorithms=["HS256"] to prevent algorithm confusion attack
    (jwt.decode without algorithms list accepts alg:none tokens).
    """
    from app.core.exceptions import AppError  # local import avoids circular

    settings = get_settings()
    try:
        return jwt.decode(token, settings.SECRET_KEY, algorithms=[ALGORITHM])
    except ExpiredSignatureError:
        raise AppError(
            status_code=401,
            detail="Access token has expired",
            code="AUTH_TOKEN_EXPIRED",
        )
    except InvalidTokenError:
        raise AppError(
            status_code=401,
            detail="Invalid access token",
            code="AUTH_TOKEN_INVALID",
        )


def generate_refresh_token() -> str:
    """Generate a cryptographically secure opaque refresh token.

    Returns a random URL-safe string (512 bits of entropy).
    Refresh tokens are NOT JWTs — they are opaque strings stored in the DB.
    Opaque tokens are simpler to revoke: just look up and mark revoked.
    """
    return secrets.token_urlsafe(64)
```

Run `ruff check app/core/security.py app/core/config.py` and fix any violations.

Key security properties to verify in the code:
- `asyncio.to_thread()` used for BOTH hash() and verify() — never call synchronously in async routes
- `algorithms=["HS256"]` passed to jwt.decode() — explicit list prevents algorithm confusion
- `generate_refresh_token()` uses `secrets.token_urlsafe(64)` — NOT uuid4() (lower entropy) and NOT random.token_hex (not cryptographically secure in older Python)
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && poetry run python -c "
import asyncio
from app.core.security import hash_password, verify_password, create_access_token, decode_access_token, generate_refresh_token

async def test():
    hashed = await hash_password('testpass123')
    assert await verify_password('testpass123', hashed), 'verify failed'
    assert not await verify_password('wrongpass', hashed), 'wrong pass accepted'
    token = create_access_token(42, 'user')
    payload = decode_access_token(token)
    assert payload['sub'] == '42', f'sub wrong: {payload}'
    assert payload['role'] == 'user', f'role wrong: {payload}'
    rt = generate_refresh_token()
    assert len(rt) > 80, f'refresh token too short: {len(rt)}'
    print('All security functions verified OK')

asyncio.run(test())
"</automated>
  </verify>
  <done>
    - app/core/config.py has SECRET_KEY, ACCESS_TOKEN_EXPIRE_MINUTES (15), REFRESH_TOKEN_EXPIRE_DAYS (7)
    - app/core/security.py has hash_password (async, asyncio.to_thread), verify_password (async, asyncio.to_thread), create_access_token (HS256, 5 claims), decode_access_token (raises AppError 401 on failure, algorithms=["HS256"]), generate_refresh_token (secrets.token_urlsafe)
    - All 5 functions verified by automated test
    - ruff check passes with zero violations
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Pydantic schemas for auth endpoints</name>
  <files>app/users/schemas.py</files>
  <action>
Create `app/users/schemas.py` with all request/response schemas for the 4 auth endpoints:

```python
from pydantic import BaseModel, EmailStr, Field


class UserCreate(BaseModel):
    """POST /auth/register request body.

    NOTE: No 'role' field — registration always creates user role.
    Adding a role field here would enable role elevation via API.
    Password min_length=8 enforced by Pydantic (422 on violation).
    """
    email: EmailStr
    password: str = Field(min_length=8)


class LoginRequest(BaseModel):
    """POST /auth/login request body.

    No min_length on password — login attempts with any password
    should go through the full verify path for timing safety.
    """
    email: EmailStr
    password: str


class RefreshRequest(BaseModel):
    """POST /auth/refresh and POST /auth/logout request body."""
    refresh_token: str


class TokenResponse(BaseModel):
    """Response for register, login, and refresh endpoints."""
    access_token: str
    refresh_token: str
    token_type: str = "bearer"


class UserResponse(BaseModel):
    """Embedded in register response alongside tokens (optional, for user info)."""
    id: int
    email: str
    role: str

    model_config = {"from_attributes": True}
```

Security note on UserCreate: The schema MUST NOT have a `role` field. If a `role` field were present and passed to User creation, a malicious user could register as admin by sending `{"email": "x@x.com", "password": "pass1234", "role": "admin"}`. The locked decision (CONTEXT.md) states: "Registration always defaults to `user` role — no request payload can set or elevate the role."

Run `ruff check app/users/schemas.py` and fix any violations.
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && poetry run python -c "
from app.users.schemas import UserCreate, LoginRequest, RefreshRequest, TokenResponse, UserResponse
from pydantic import ValidationError

# Test email validation
try:
    UserCreate(email='not-an-email', password='password123')
    assert False, 'Should have raised'
except ValidationError:
    pass

# Test password min length
try:
    UserCreate(email='test@test.com', password='short')
    assert False, 'Should have raised'
except ValidationError:
    pass

# Test valid create
uc = UserCreate(email='test@test.com', password='password123')
assert uc.email == 'test@test.com'

# Test no role field on UserCreate
assert not hasattr(uc, 'role'), 'UserCreate must not have role field'

# Test TokenResponse
tr = TokenResponse(access_token='abc', refresh_token='def')
assert tr.token_type == 'bearer'

print('All schema validations passed')
"</automated>
  </verify>
  <done>
    - app/users/schemas.py has UserCreate (email + password min_length=8, NO role field), LoginRequest (email + password), RefreshRequest (refresh_token), TokenResponse (access_token + refresh_token + token_type default bearer), UserResponse (id + email + role, from_attributes=True)
    - UserCreate rejects emails with invalid format (422)
    - UserCreate rejects passwords shorter than 8 chars (422)
    - UserCreate has NO role field (cannot elevate role via registration)
    - ruff check passes with zero violations
  </done>
</task>

</tasks>

<verification>
Run the full test suite — Phase 1 smoke tests must still pass, nothing in this plan modifies test infrastructure:

```bash
cd D:/Python/claude-test && poetry run pytest tests/ -v
```

Run ruff on all modified files:

```bash
cd D:/Python/claude-test && poetry run ruff check app/core/security.py app/core/config.py app/users/schemas.py && poetry run ruff format --check app/core/security.py app/core/config.py app/users/schemas.py
```
</verification>

<success_criteria>
- hash_password and verify_password use asyncio.to_thread (never blocking the event loop)
- create_access_token produces JWTs with sub/role/jti/iat/exp claims
- decode_access_token passes algorithms=["HS256"] to jwt.decode (prevents algorithm confusion)
- decode_access_token raises AppError(401) on expired or invalid tokens
- generate_refresh_token returns a string with >80 chars (512-bit entropy URL-safe)
- UserCreate schema rejects invalid email (422) and passwords shorter than 8 chars (422)
- UserCreate schema has NO role field
- All Phase 1 tests still pass
- ruff check passes with zero violations
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-auth/02-02-SUMMARY.md`
</output>
