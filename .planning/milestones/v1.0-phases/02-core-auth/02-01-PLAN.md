---
phase: 02-core-auth
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/users/__init__.py
  - app/users/models.py
  - app/db/base.py
  - alembic/versions/XXXX_create_users_and_refresh_tokens.py
autonomous: true
requirements:
  - AUTH-01
  - AUTH-02
  - AUTH-04

must_haves:
  truths:
    - "A users table exists in the database with id, email, hashed_password, role, is_active, created_at columns"
    - "A refresh_tokens table exists with id, token, token_family, user_id, expires_at, revoked_at, created_at columns"
    - "The UserRole enum has exactly two values: user and admin"
    - "Alembic autogenerate detects no pending migrations after running the new migration"
  artifacts:
    - path: "app/users/models.py"
      provides: "User and RefreshToken SQLAlchemy models + UserRole enum"
      contains: "class User(Base)"
    - path: "app/db/base.py"
      provides: "Model aggregator for Alembic — imports User and RefreshToken"
      contains: "from app.users.models import User, RefreshToken"
    - path: "alembic/versions"
      provides: "Non-empty migration creating users and refresh_tokens tables"
  key_links:
    - from: "app/users/models.py"
      to: "app/db/base.py"
      via: "from app.users.models import User, RefreshToken  # noqa: F401"
      pattern: "from app.users.models import"
    - from: "app/db/base.py"
      to: "alembic/env.py"
      via: "Base.metadata used by autogenerate"
      pattern: "target_metadata"
---

<objective>
Create the User and RefreshToken SQLAlchemy models, register them with the Alembic model aggregator, and generate + apply the database migration that creates the users and refresh_tokens tables.

Purpose: All Phase 2 auth features depend on these two tables. The User model provides email/password/role storage; the RefreshToken model provides session management with token_family for theft detection.
Output: Two database tables, two ORM models, one Alembic migration applied cleanly.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-auth/02-CONTEXT.md
@.planning/phases/02-core-auth/02-RESEARCH.md
@.planning/phases/01-infrastructure/01-02-SUMMARY.md
@.planning/phases/01-infrastructure/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create User and RefreshToken SQLAlchemy models</name>
  <files>app/users/__init__.py, app/users/models.py, app/db/base.py</files>
  <action>
Create `app/users/__init__.py` as an empty file (package marker).

Create `app/users/models.py` with exactly these two models:

```python
import enum
import uuid
from datetime import datetime

from sqlalchemy import Boolean, DateTime, Enum as SAEnum, ForeignKey, String, func
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.db.base import Base


class UserRole(str, enum.Enum):
    USER = "user"
    ADMIN = "admin"


class User(Base):
    __tablename__ = "users"

    id: Mapped[int] = mapped_column(primary_key=True)
    email: Mapped[str] = mapped_column(String(255), unique=True, index=True, nullable=False)
    hashed_password: Mapped[str] = mapped_column(String(255), nullable=False)
    role: Mapped[UserRole] = mapped_column(
        SAEnum(UserRole, name="userrole"), default=UserRole.USER, nullable=False
    )
    is_active: Mapped[bool] = mapped_column(Boolean, default=True, nullable=False)
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), nullable=False
    )

    refresh_tokens: Mapped[list["RefreshToken"]] = relationship(
        back_populates="user", cascade="all, delete-orphan"
    )


class RefreshToken(Base):
    __tablename__ = "refresh_tokens"

    id: Mapped[int] = mapped_column(primary_key=True)
    token: Mapped[str] = mapped_column(String(512), unique=True, index=True, nullable=False)
    token_family: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), default=uuid.uuid4, nullable=False, index=True
    )
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"), nullable=False)
    expires_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False)
    revoked_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=True), nullable=True)
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), nullable=False
    )

    user: Mapped["User"] = relationship(back_populates="refresh_tokens")

    @property
    def is_revoked(self) -> bool:
        return self.revoked_at is not None

    @property
    def is_expired(self) -> bool:
        from datetime import timezone
        return self.expires_at < datetime.now(tz=timezone.utc)
```

Then update `app/db/base.py` — add the following import line immediately after the DeclarativeBase definition (before any other code):

```python
from app.users.models import User, RefreshToken  # noqa: F401
```

This import is REQUIRED for Alembic autogenerate to discover both tables. Without it, the generated migration will be empty.

Security notes per CONTEXT.md locked decisions:
- UserRole has only `user` and `admin` — no other roles, no roles table
- `is_active` flag enables future deactivation without deletion
- `token_family` UUID enables family-level revocation for theft detection (CONTEXT.md: "if a revoked token is reused, revoke the entire family")
- No `username` field — email is the only identifier per CONTEXT.md

After writing both files, run `ruff check app/users/models.py app/db/base.py` and fix any violations before proceeding.
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && poetry run python -c "from app.users.models import User, RefreshToken, UserRole; from app.db.base import Base; print('Models imported OK'); print('Tables:', list(Base.metadata.tables.keys()))"</automated>
    <manual>Output should show both "users" and "refresh_tokens" in the tables list</manual>
  </verify>
  <done>
    - `app/users/__init__.py` exists (empty)
    - `app/users/models.py` defines User, RefreshToken, UserRole
    - `app/db/base.py` imports User and RefreshToken with noqa: F401
    - Python import of both models succeeds without errors
    - Base.metadata.tables contains both "users" and "refresh_tokens"
    - ruff check passes on both files
  </done>
</task>

<task type="auto">
  <name>Task 2: Generate and apply Alembic migration for users and refresh_tokens tables</name>
  <files>alembic/versions/XXXX_create_users_and_refresh_tokens.py</files>
  <action>
Generate the Alembic migration using autogenerate:

```bash
poetry run alembic revision --autogenerate -m "create_users_and_refresh_tokens"
```

CRITICAL: Before applying, open the generated migration file and verify it is NOT empty. The `upgrade()` function must contain `op.create_table("users", ...)` and `op.create_table("refresh_tokens", ...)`. If the upgrade function is empty, the User/RefreshToken import in app/db/base.py is missing — fix that first.

Also verify the migration includes:
- `userrole` PostgreSQL ENUM type creation in upgrade() and drop in downgrade()
- `expires_at` index on refresh_tokens (added manually if autogenerate missed it)
- `token_family` index on refresh_tokens

Apply the migration:
```bash
poetry run alembic upgrade head
```

Verify no pending migrations remain:
```bash
poetry run alembic check
```

Run ruff check on the generated migration file and fix any violations (common: unused imports, line length).
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && poetry run alembic check && echo "No pending migrations"</automated>
    <automated>cd D:/Python/claude-test && poetry run python -c "from app.db.session import AsyncSessionLocal; import asyncio; async def check(): async with AsyncSessionLocal() as s: result = await s.execute(__import__('sqlalchemy').text('SELECT table_name FROM information_schema.tables WHERE table_schema=\'public\' ORDER BY table_name')); print([r[0] for r in result]); asyncio.run(check())"</automated>
    <manual>Output should list both "refresh_tokens" and "users" tables in the database</manual>
  </verify>
  <done>
    - Migration file exists in alembic/versions/ with non-empty upgrade() function
    - `poetry run alembic upgrade head` exits 0
    - `poetry run alembic check` reports "No new upgrade operations detected"
    - users table exists in PostgreSQL with correct columns
    - refresh_tokens table exists with token_family UUID column and expires_at column
    - ruff check passes on migration file
  </done>
</task>

</tasks>

<verification>
Run the full test suite to confirm Phase 1 smoke tests still pass after model additions:

```bash
cd D:/Python/claude-test && poetry run pytest tests/ -v
```

All 3 smoke tests from Phase 1 (test_health_returns_200, test_404_returns_structured_error, test_db_session_connects) must still pass. The conftest.py uses `Base.metadata.create_all` — it will now create users and refresh_tokens in the test database automatically.

Run ruff on all modified files:
```bash
poetry run ruff check app/users/ app/db/base.py && poetry run ruff format --check app/users/ app/db/base.py
```
</verification>

<success_criteria>
- users table: id (serial PK), email (varchar 255, unique, indexed), hashed_password (varchar 255), role (userrole enum, default user), is_active (boolean, default true), created_at (timestamptz, server default now())
- refresh_tokens table: id (serial PK), token (varchar 512, unique, indexed), token_family (uuid, indexed), user_id (FK users.id), expires_at (timestamptz), revoked_at (timestamptz nullable), created_at (timestamptz, server default now())
- `poetry run alembic check` exits 0 with "No new upgrade operations detected"
- `poetry run pytest tests/` passes (all 3 Phase 1 smoke tests still green)
- `poetry run ruff check .` passes with zero violations
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-auth/02-01-SUMMARY.md`
</output>
