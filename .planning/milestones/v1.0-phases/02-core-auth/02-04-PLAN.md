---
phase: 02-core-auth
plan: 04
type: execute
wave: 4
depends_on:
  - 02-03
files_modified:
  - app/users/router.py
  - app/main.py
  - scripts/seed_admin.py
autonomous: true
requirements:
  - AUTH-01
  - AUTH-02
  - AUTH-03
  - AUTH-04
  - AUTH-05

must_haves:
  truths:
    - "POST /auth/register with valid email + password returns 201 with access_token and refresh_token"
    - "POST /auth/login with correct credentials returns 200 with access_token and refresh_token"
    - "POST /auth/refresh with a valid refresh token returns 200 with a new token pair"
    - "POST /auth/logout with a valid refresh token returns 204 and subsequent refresh with that token returns 401"
    - "An unauthenticated request to a protected endpoint returns 401"
    - "A user-role token request to an admin-guarded endpoint returns 403"
    - "The seed_admin.py script creates an admin user in the database"
  artifacts:
    - path: "app/users/router.py"
      provides: "POST /auth/register, /auth/login, /auth/refresh, /auth/logout endpoints"
      contains: "router = APIRouter"
    - path: "app/main.py"
      provides: "Auth router registered on the FastAPI app"
      contains: "include_router"
    - path: "scripts/seed_admin.py"
      provides: "CLI script to create first admin user"
      contains: "asyncio.run"
  key_links:
    - from: "app/users/router.py"
      to: "app/users/service.py"
      via: "AuthService instantiated with UserRepository and RefreshTokenRepository from db session"
      pattern: "AuthService"
    - from: "app/users/router.py"
      to: "app/users/schemas.py"
      via: "UserCreate, LoginRequest, RefreshRequest as request bodies; TokenResponse as response_model"
      pattern: "response_model=TokenResponse"
    - from: "app/main.py"
      to: "app/users/router.py"
      via: "application.include_router(auth_router)"
      pattern: "include_router"
---

<objective>
Wire the auth endpoints into the FastAPI app via a router, and create the admin seed script so the first admin user can be bootstrapped.

Purpose: This is the final layer — the HTTP interface that users and clients actually call. All business logic is already in the service/repository from Plan 03.
Output: 4 auth endpoints live on the FastAPI app, admin seed script runnable via `poetry run python scripts/seed_admin.py`.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-auth/02-CONTEXT.md
@.planning/phases/02-core-auth/02-RESEARCH.md
@.planning/phases/02-core-auth/02-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth router and register it in main.py</name>
  <files>app/users/router.py, app/main.py</files>
  <action>
Create `app/users/router.py`:

```python
from fastapi import APIRouter, status

from app.core.deps import DbSession
from app.users.repository import RefreshTokenRepository, UserRepository
from app.users.schemas import LoginRequest, RefreshRequest, TokenResponse, UserCreate
from app.users.service import AuthService

router = APIRouter(prefix="/auth", tags=["auth"])


def _make_service(db: DbSession) -> AuthService:
    """Instantiate AuthService with repositories bound to the current DB session."""
    return AuthService(
        user_repo=UserRepository(db),
        rt_repo=RefreshTokenRepository(db),
    )


@router.post(
    "/register",
    response_model=TokenResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Register a new user",
)
async def register(body: UserCreate, db: DbSession) -> TokenResponse:
    """Register with email + password. Returns access and refresh tokens immediately.

    No email verification required (per CONTEXT.md).
    409 if email already registered.
    422 if email invalid or password < 8 characters.
    """
    service = _make_service(db)
    access_token, refresh_token = await service.register(body.email, body.password)
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)


@router.post(
    "/login",
    response_model=TokenResponse,
    summary="Log in with email and password",
)
async def login(body: LoginRequest, db: DbSession) -> TokenResponse:
    """Authenticate and receive token pair.

    Always returns generic "Invalid email or password" on failure (no email enumeration).
    Each login creates a new independent refresh token family (multiple sessions supported).
    """
    service = _make_service(db)
    access_token, refresh_token = await service.login(body.email, body.password)
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)


@router.post(
    "/refresh",
    response_model=TokenResponse,
    summary="Refresh an expired access token",
)
async def refresh(body: RefreshRequest, db: DbSession) -> TokenResponse:
    """Exchange a valid refresh token for a new access + refresh token pair.

    Rotation: old refresh token is revoked, new one issued in same family.
    Reuse detection: if a revoked token is submitted, entire family is revoked.
    """
    service = _make_service(db)
    access_token, refresh_token = await service.refresh(body.refresh_token)
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)


@router.post(
    "/logout",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Log out (revoke current session's refresh token)",
)
async def logout(body: RefreshRequest, db: DbSession) -> None:
    """Revoke the provided refresh token.

    Only revokes the current session's token — other sessions remain active.
    Idempotent: submitting an already-revoked token returns 204 (no error).
    """
    service = _make_service(db)
    await service.logout(body.refresh_token)
```

Now READ `app/main.py` to see its current content (from Phase 1 — has the FastAPI app factory). Add the router include WITHOUT removing the existing health endpoint or exception handlers:

```python
# Add this import near the top with other imports:
from app.users.router import router as auth_router

# Add this line in the create_app() function (or wherever routers are included),
# after the app object is created:
app.include_router(auth_router)
```

The exact placement depends on app/main.py structure — read it first. The auth router must be included before the app is returned from the factory function (or at module level if app is not in a factory).

Run `ruff check app/users/router.py app/main.py` and fix any violations.

Verify endpoints are registered:
```bash
poetry run python -c "
from app.main import app
routes = [r.path for r in app.routes]
print('Routes:', routes)
assert '/auth/register' in routes, 'register not found'
assert '/auth/login' in routes, 'login not found'
assert '/auth/refresh' in routes, 'refresh not found'
assert '/auth/logout' in routes, 'logout not found'
print('All auth routes registered')
"
```
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && poetry run python -c "
from app.main import app
routes = [r.path for r in app.routes]
assert '/auth/register' in routes
assert '/auth/login' in routes
assert '/auth/refresh' in routes
assert '/auth/logout' in routes
print('All 4 auth routes registered:', [r for r in routes if r.startswith('/auth')])
"</automated>
  </verify>
  <done>
    - app/users/router.py defines 4 routes: POST /auth/register (201), POST /auth/login (200), POST /auth/refresh (200), POST /auth/logout (204)
    - All routes use DbSession for dependency injection and instantiate AuthService via _make_service()
    - app/main.py imports and includes auth_router
    - All 4 /auth/* routes visible in app.routes
    - ruff check passes with zero violations
  </done>
</task>

<task type="auto">
  <name>Task 2: Create admin seed script</name>
  <files>scripts/__init__.py, scripts/seed_admin.py</files>
  <action>
Check if `scripts/` directory exists. If not, create it. Create `scripts/__init__.py` as an empty file if it does not exist.

Create `scripts/seed_admin.py` — a standalone async script to create the first admin user:

```python
"""Admin seed script.

Creates the first admin user in the database. Run with:
    poetry run python scripts/seed_admin.py

Required env vars (loaded from .env):
    DATABASE_URL — PostgreSQL connection string
    SECRET_KEY — used by the app config

Usage:
    $ poetry run python scripts/seed_admin.py
    Admin email: admin@example.com
    Admin password: (hidden)
    Admin created: admin@example.com (id=1)
"""
import asyncio
import sys

from sqlalchemy.exc import IntegrityError


async def create_admin(email: str, password: str) -> None:
    """Create a user with admin role. Errors if email already exists."""
    from app.core.security import hash_password
    from app.db.session import AsyncSessionLocal
    from app.users.repository import UserRepository

    hashed = await hash_password(password)

    async with AsyncSessionLocal() as session:
        repo = UserRepository(session)

        existing = await repo.get_by_email(email)
        if existing:
            print(f"Error: user with email '{email}' already exists (id={existing.id}, role={existing.role.value})")
            sys.exit(1)

        try:
            user = await repo.create(email=email, hashed_password=hashed)
            await repo.set_role_admin(user.id)
            await session.commit()
            print(f"Admin created: {email} (id={user.id})")
        except IntegrityError:
            await session.rollback()
            print(f"Error: email '{email}' is already taken")
            sys.exit(1)


def main() -> None:
    import getpass

    print("=== Bookstore Admin Seed ===")
    email = input("Admin email: ").strip()
    if not email:
        print("Error: email is required")
        sys.exit(1)

    password = getpass.getpass("Admin password: ")
    if len(password) < 8:
        print("Error: password must be at least 8 characters")
        sys.exit(1)

    asyncio.run(create_admin(email, password))


if __name__ == "__main__":
    main()
```

Note on Click (Claude's discretion): The CONTEXT.md leaves seed command approach to Claude's discretion. A direct asyncio.run() script is chosen over Click because: (1) Click is not in pyproject.toml and would require a new dependency, (2) the script is a one-time operation with minimal UX needs, (3) stdlib getpass is sufficient for the password prompt. If Click is already installed, it can be used instead — check `poetry show click` first.

Run `ruff check scripts/seed_admin.py` and fix any violations.
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && poetry run python -c "
import ast, sys
with open('scripts/seed_admin.py') as f:
    tree = ast.parse(f.read())
func_names = [node.name for node in ast.walk(tree) if isinstance(node, ast.AsyncFunctionDef)]
assert 'create_admin' in func_names, 'create_admin not found'
print('seed_admin.py parses correctly, functions:', func_names)
"</automated>
  </verify>
  <done>
    - scripts/seed_admin.py exists and parses without syntax errors
    - Script handles duplicate email check before creation
    - Script uses getpass for password input (hidden input)
    - Script validates password length >= 8
    - Script calls repo.set_role_admin() after creation and commits
    - ruff check passes with zero violations
  </done>
</task>

</tasks>

<verification>
Run the Phase 1 smoke tests to confirm nothing broke:

```bash
cd D:/Python/claude-test && poetry run pytest tests/ -v
```

Manually verify the OpenAPI schema includes all 4 auth endpoints:

```bash
cd D:/Python/claude-test && poetry run python -c "
from app.main import app
import json
schema = app.openapi()
paths = list(schema['paths'].keys())
print('All paths:', paths)
auth_paths = [p for p in paths if p.startswith('/auth')]
assert len(auth_paths) == 4, f'Expected 4 auth paths, got: {auth_paths}'
print('Auth endpoints in OpenAPI schema:', auth_paths)
"
```

Run ruff on all modified files:

```bash
cd D:/Python/claude-test && poetry run ruff check app/users/router.py app/main.py scripts/seed_admin.py && poetry run ruff format --check app/users/router.py app/main.py scripts/seed_admin.py
```
</verification>

<success_criteria>
- POST /auth/register: accepts {email, password}, returns 201 + {access_token, refresh_token, token_type}
- POST /auth/login: accepts {email, password}, returns 200 + {access_token, refresh_token, token_type}
- POST /auth/refresh: accepts {refresh_token}, returns 200 + new {access_token, refresh_token, token_type}
- POST /auth/logout: accepts {refresh_token}, returns 204 No Content
- All 4 endpoints visible in OpenAPI schema
- scripts/seed_admin.py runnable via `poetry run python scripts/seed_admin.py`
- All Phase 1 tests still pass
- ruff check passes with zero violations
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-auth/02-04-SUMMARY.md`
</output>
