---
phase: 02-core-auth
plan: 05
type: tdd
wave: 5
depends_on:
  - 02-04
files_modified:
  - tests/test_auth.py
autonomous: true
requirements:
  - AUTH-01
  - AUTH-02
  - AUTH-03
  - AUTH-04
  - AUTH-05

must_haves:
  truths:
    - "A new user can POST /auth/register and receive 201 with access_token and refresh_token"
    - "Registering with a duplicate email returns 409"
    - "Registering with a password shorter than 8 chars returns 422"
    - "A registered user can POST /auth/login and receive 200 with token pair"
    - "Logging in with wrong password returns 401 with generic error message"
    - "A valid refresh token can be exchanged at POST /auth/refresh for a new token pair"
    - "A used refresh token (rotated) cannot be used again — returns 401"
    - "POST /auth/logout with valid refresh token returns 204"
    - "A refresh token used after logout returns 401"
    - "An unauthenticated request to a protected endpoint returns 401"
    - "A user-role token used on an admin-guarded endpoint returns 403"
  artifacts:
    - path: "tests/test_auth.py"
      provides: "Integration tests for all 4 auth endpoints and RBAC"
      contains: "test_register_success"
  key_links:
    - from: "tests/test_auth.py"
      to: "tests/conftest.py"
      via: "client fixture from Phase 1 conftest used for HTTP calls"
      pattern: "async def test_.*client"
    - from: "tests/test_auth.py"
      to: "/auth/register, /auth/login, /auth/refresh, /auth/logout"
      via: "httpx AsyncClient HTTP calls via ASGITransport"
      pattern: "client.post"
---

<objective>
Create comprehensive integration tests for all 4 auth endpoints following TDD: write tests first (RED), verify they fail on missing implementation, then confirm they pass against the complete implementation from Plans 01-04.

Purpose: Auth has clear I/O contracts (input → HTTP status + response shape) making it a perfect TDD target. Tests define and verify the security properties: timing-safe login, token rotation, family revocation, RBAC.
Output: tests/test_auth.py with 12+ test cases covering all success and error paths.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-auth/02-CONTEXT.md
@.planning/phases/02-core-auth/02-04-SUMMARY.md
@tests/conftest.py
</context>

<feature>
  <name>Auth Endpoint Integration Tests</name>
  <files>tests/test_auth.py</files>
  <behavior>
All tests use the `client` fixture from conftest.py (httpx AsyncClient with in-process FastAPI + isolated DB session with rollback).

### Registration (POST /auth/register)
- Valid {email, password(>=8)} → 201 + {access_token, refresh_token, token_type: "bearer"}
- Duplicate email → 409 + error body with code "AUTH_EMAIL_CONFLICT"
- Password < 8 chars → 422 (Pydantic validation error)
- Invalid email format → 422 (Pydantic validation error)
- No role field in response body (not a security test, schema test)

### Login (POST /auth/login)
- Correct credentials → 200 + {access_token, refresh_token, token_type: "bearer"}
- Wrong password → 401 + detail "Invalid email or password"
- Non-existent email → 401 + detail "Invalid email or password" (same message — no enumeration)
- Registered then login → access_token is a valid JWT with correct sub and role claims

### Refresh (POST /auth/refresh)
- Valid refresh token → 200 + new {access_token, refresh_token}
- Old refresh token after rotation → 401 (revoked token rejected)
- Non-existent token string → 401
- Token reuse detection: submitting old token after rotation → 401 + entire family revoked

### Logout (POST /auth/logout)
- Valid refresh token → 204 No Content
- Refresh attempt after logout → 401 (token revoked)
- Logout with already-revoked token → 204 (idempotent — no error)

### RBAC (AUTH-05)
- Request to protected route without Authorization header → 401
- Request with valid user-role token to admin-only route → 403
- Request with valid admin-role token to admin-only route → 200 (use /health or any protected endpoint as proxy)

Note on RBAC test setup: To test admin-guarded endpoints, either (a) use the seed script pattern to create an admin user directly via repository in the test, or (b) create a minimal test-only protected route in the test itself using `require_admin`. Use approach (a) — create admin directly via UserRepository + set_role_admin in a test fixture, then issue login token.
  </behavior>
  <implementation>
Create `tests/test_auth.py`. Use the conftest.py `client` fixture (AsyncClient) and `db_session` fixture (AsyncSession) already established in Phase 1.

Key patterns:
- Use `@pytest_asyncio.fixture` for async test fixtures (not `@pytest.fixture`)
- Each test is fully isolated — the db_session fixture rolls back after each test
- Registration helper fixture registers a user and returns their credentials + token pair
- Admin fixture creates user via UserRepository + set_role_admin directly (bypasses API — needed to test admin endpoints before admin API exists)

Structure:
```
class TestRegister:   # AUTH-01
class TestLogin:      # AUTH-02
class TestRefresh:    # AUTH-03
class TestLogout:     # AUTH-04
class TestRBAC:       # AUTH-05
```

After writing tests, run RED phase:
```bash
poetry run pytest tests/test_auth.py -v 2>&1 | head -50
```
Tests should FAIL with either import errors (if implementation is missing) or assertion errors (if endpoints not returning expected values). If all tests pass immediately without any failures, the tests are not actually testing anything useful — add stricter assertions.

Then run GREEN phase to confirm all pass:
```bash
poetry run pytest tests/test_auth.py -v
```

Finally run the full suite to confirm no regressions:
```bash
poetry run pytest tests/ -v
```
  </implementation>
</feature>

<verification>
```bash
cd D:/Python/claude-test && poetry run pytest tests/test_auth.py -v --tb=short
```

Expected: All test cases pass. Zero failures. Zero errors.

Count: Minimum 12 tests across 5 test classes (AUTH-01 through AUTH-05).

Run ruff:
```bash
cd D:/Python/claude-test && poetry run ruff check tests/test_auth.py && poetry run ruff format --check tests/test_auth.py
```

Run full suite:
```bash
cd D:/Python/claude-test && poetry run pytest tests/ -v
```
All Phase 1 smoke tests (test_health.py) AND all Phase 2 auth tests (test_auth.py) must pass.
</verification>

<success_criteria>
- tests/test_auth.py has at minimum 12 test cases covering: register success, register duplicate, register invalid email, register short password, login success, login wrong password, login nonexistent email, refresh success, refresh revoked token, logout success, logout then refresh fails, RBAC unauthorized, RBAC forbidden
- All 12+ tests PASS with `poetry run pytest tests/test_auth.py -v`
- Full suite passes: `poetry run pytest tests/ -v` (Phase 1 + Phase 2 tests)
- ruff check passes with zero violations
- Tests verify both HTTP status codes AND response body shape (not just status codes)
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-auth/02-05-SUMMARY.md`
</output>
