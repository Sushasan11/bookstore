---
phase: 02-core-auth
plan: 03
type: execute
wave: 3
depends_on:
  - 02-01
  - 02-02
files_modified:
  - app/users/repository.py
  - app/users/service.py
  - app/core/deps.py
autonomous: true
requirements:
  - AUTH-01
  - AUTH-02
  - AUTH-03
  - AUTH-04
  - AUTH-05

must_haves:
  truths:
    - "UserRepository can create a user, look up by email, look up by ID, and promote to admin"
    - "RefreshTokenRepository can create, look up by token string, revoke single token, and revoke entire family"
    - "AuthService.register() creates user and returns access + refresh tokens"
    - "AuthService.login() is timing-safe — always runs verify_password even when user not found"
    - "AuthService.refresh() rotates the token and revokes the entire family on reuse detection"
    - "AuthService.logout() revokes only the current session's refresh token (idempotent)"
    - "get_current_user dependency decodes the Bearer token from Authorization header without DB lookup"
    - "require_admin dependency returns 403 when role is not admin"
  artifacts:
    - path: "app/users/repository.py"
      provides: "UserRepository, RefreshTokenRepository"
      contains: "class UserRepository"
    - path: "app/users/service.py"
      provides: "AuthService with register/login/refresh/logout"
      contains: "DUMMY_HASH"
    - path: "app/core/deps.py"
      provides: "get_current_user, require_admin, CurrentUser, AdminUser type aliases"
      contains: "oauth2_scheme"
  key_links:
    - from: "app/users/service.py"
      to: "app/core/security.py"
      via: "hash_password, verify_password, create_access_token, generate_refresh_token"
      pattern: "from app.core.security import"
    - from: "app/users/service.py"
      to: "app/users/repository.py"
      via: "UserRepository and RefreshTokenRepository injected into AuthService.__init__"
      pattern: "self.user_repo"
    - from: "app/core/deps.py"
      to: "app/core/security.py"
      via: "decode_access_token called inside get_current_user"
      pattern: "decode_access_token"
---

<objective>
Implement the repository layer (UserRepository + RefreshTokenRepository) and service layer (AuthService), plus add get_current_user and require_admin FastAPI dependencies to app/core/deps.py.

Purpose: This is the business logic heart of Phase 2. All auth security properties — timing-safe login, refresh token rotation, family revocation, RBAC — live in this layer.
Output: Three files containing the complete auth domain logic, ready for the endpoint router to wire in Plan 04.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-auth/02-CONTEXT.md
@.planning/phases/02-core-auth/02-RESEARCH.md
@.planning/phases/02-core-auth/02-01-SUMMARY.md
@.planning/phases/02-core-auth/02-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create UserRepository and RefreshTokenRepository</name>
  <files>app/users/repository.py</files>
  <action>
Create `app/users/repository.py`:

```python
import uuid
from datetime import UTC, datetime, timedelta

from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession

from app.users.models import RefreshToken, User, UserRole


class UserRepository:
    def __init__(self, session: AsyncSession) -> None:
        self.session = session

    async def get_by_email(self, email: str) -> User | None:
        result = await self.session.execute(
            select(User).where(User.email == email)
        )
        return result.scalar_one_or_none()

    async def get_by_id(self, user_id: int) -> User | None:
        result = await self.session.execute(
            select(User).where(User.id == user_id)
        )
        return result.scalar_one_or_none()

    async def create(self, email: str, hashed_password: str) -> User:
        """Create a new user with default role=USER.

        Does NOT accept a role parameter — role elevation is impossible via this method.
        Uses session.flush() (not commit) so the caller controls transaction boundaries.
        """
        user = User(email=email, hashed_password=hashed_password)
        self.session.add(user)
        await self.session.flush()  # get the auto-generated id
        return user

    async def set_role_admin(self, user_id: int) -> None:
        """Promote a user to admin. Used only by the seed script — not exposed via API."""
        await self.session.execute(
            update(User).where(User.id == user_id).values(role=UserRole.ADMIN)
        )


class RefreshTokenRepository:
    def __init__(self, session: AsyncSession) -> None:
        self.session = session

    async def create(
        self,
        token: str,
        user_id: int,
        expires_in_days: int = 7,
        token_family: uuid.UUID | None = None,
    ) -> RefreshToken:
        """Create a new refresh token.

        token_family: If provided, this token is part of an existing rotation chain.
        If None, a new family UUID is generated (new login session).
        """
        rt = RefreshToken(
            token=token,
            user_id=user_id,
            token_family=token_family or uuid.uuid4(),
            expires_at=datetime.now(UTC) + timedelta(days=expires_in_days),
        )
        self.session.add(rt)
        await self.session.flush()
        return rt

    async def get_by_token(self, token: str) -> RefreshToken | None:
        result = await self.session.execute(
            select(RefreshToken).where(RefreshToken.token == token)
        )
        return result.scalar_one_or_none()

    async def revoke(self, token: str) -> None:
        """Revoke a single refresh token (used on logout)."""
        await self.session.execute(
            update(RefreshToken)
            .where(RefreshToken.token == token)
            .values(revoked_at=datetime.now(UTC))
        )

    async def revoke_family(self, token_family: uuid.UUID) -> None:
        """Revoke all non-revoked tokens in a family.

        Called on token reuse detection (theft). Revokes only the compromised
        family — other login sessions (different families) remain active.
        Per CONTEXT.md: "if a revoked token is reused, revoke the entire family"
        """
        await self.session.execute(
            update(RefreshToken)
            .where(
                RefreshToken.token_family == token_family,
                RefreshToken.revoked_at.is_(None),
            )
            .values(revoked_at=datetime.now(UTC))
        )
```

Run `ruff check app/users/repository.py` and fix any violations.
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && poetry run python -c "from app.users.repository import UserRepository, RefreshTokenRepository; print('Repositories imported OK')"</automated>
  </verify>
  <done>
    - app/users/repository.py defines UserRepository (get_by_email, get_by_id, create, set_role_admin) and RefreshTokenRepository (create, get_by_token, revoke, revoke_family)
    - UserRepository.create() takes only email + hashed_password — no role parameter
    - RefreshTokenRepository.revoke_family() targets token_family column, not user_id
    - ruff check passes with zero violations
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AuthService and add RBAC dependencies to deps.py</name>
  <files>app/users/service.py, app/core/deps.py</files>
  <action>
Create `app/users/service.py`:

```python
from pwdlib import PasswordHash

from app.core.exceptions import AppError
from app.core.security import (
    create_access_token,
    generate_refresh_token,
    hash_password,
    verify_password,
)
from app.users.repository import RefreshTokenRepository, UserRepository

# Pre-compute at module load — NEVER per-request.
# Timing-safe login: even when user not found, we run verify_password
# against DUMMY_HASH so the response time is constant regardless of
# whether the email exists. Without this, timing reveals email existence.
_ph = PasswordHash.recommended()
DUMMY_HASH = _ph.hash("dummy_password_for_timing_safety_do_not_use")


class AuthService:
    def __init__(
        self,
        user_repo: UserRepository,
        rt_repo: RefreshTokenRepository,
    ) -> None:
        self.user_repo = user_repo
        self.rt_repo = rt_repo

    async def register(self, email: str, password: str) -> tuple[str, str]:
        """Register a new user. Returns (access_token, refresh_token).

        Duplicate email → AppError(409). Weak password → AppError(422).
        Per CONTEXT.md: no email verification, immediate token issuance.
        """
        existing = await self.user_repo.get_by_email(email)
        if existing:
            raise AppError(
                status_code=409,
                detail="Email already registered",
                code="AUTH_EMAIL_CONFLICT",
                field="email",
            )

        hashed = await hash_password(password)
        user = await self.user_repo.create(email=email, hashed_password=hashed)

        access_token = create_access_token(user.id, user.role.value)
        raw_rt = generate_refresh_token()
        await self.rt_repo.create(raw_rt, user.id)

        return access_token, raw_rt

    async def login(self, email: str, password: str) -> tuple[str, str]:
        """Authenticate user. Returns (access_token, refresh_token).

        Always uses constant-time comparison to prevent email enumeration via timing.
        Per CONTEXT.md: generic "Invalid email or password" on any failure.
        """
        user = await self.user_repo.get_by_email(email)
        if user is None:
            # Timing-safe path: run verify against dummy hash even when user not found
            await verify_password(password, DUMMY_HASH)
            raise AppError(
                status_code=401,
                detail="Invalid email or password",
                code="AUTH_INVALID_CREDENTIALS",
            )

        if not await verify_password(password, user.hashed_password):
            raise AppError(
                status_code=401,
                detail="Invalid email or password",
                code="AUTH_INVALID_CREDENTIALS",
            )

        access_token = create_access_token(user.id, user.role.value)
        raw_rt = generate_refresh_token()
        await self.rt_repo.create(raw_rt, user.id)

        return access_token, raw_rt

    async def refresh(self, refresh_token: str) -> tuple[str, str]:
        """Rotate a refresh token. Returns new (access_token, refresh_token).

        Theft detection: if a revoked token is reused, the entire family is revoked.
        New token inherits the same token_family (maintains the rotation chain).
        Per CONTEXT.md: "if a revoked token is reused, revoke the entire family"
        """
        rt = await self.rt_repo.get_by_token(refresh_token)

        if rt is None or rt.is_expired:
            raise AppError(
                status_code=401,
                detail="Invalid or expired refresh token",
                code="AUTH_REFRESH_INVALID",
            )

        if rt.is_revoked:
            # Token reuse detected — revoke entire family (theft response)
            await self.rt_repo.revoke_family(rt.token_family)
            raise AppError(
                status_code=401,
                detail="Refresh token reuse detected — all sessions revoked",
                code="AUTH_TOKEN_REUSE",
            )

        # Revoke current token, issue new pair
        await self.rt_repo.revoke(refresh_token)
        user = await self.user_repo.get_by_id(rt.user_id)
        if user is None or not user.is_active:
            raise AppError(
                status_code=401,
                detail="User not found or inactive",
                code="AUTH_USER_INACTIVE",
            )

        access_token = create_access_token(user.id, user.role.value)
        new_rt = generate_refresh_token()
        # Inherit same family — maintains the rotation chain for theft detection
        await self.rt_repo.create(new_rt, user.id, token_family=rt.token_family)

        return access_token, new_rt

    async def logout(self, refresh_token: str) -> None:
        """Revoke the current session's refresh token only.

        Per CONTEXT.md: "Logout revokes only the current session's refresh token;
        other sessions remain active." Idempotent — already-revoked tokens are ignored.
        """
        rt = await self.rt_repo.get_by_token(refresh_token)
        if rt is None or rt.is_revoked:
            return  # Already revoked or doesn't exist — idempotent
        await self.rt_repo.revoke(refresh_token)
```

Now update `app/core/deps.py` — READ the file first to see its current content (get_db and DbSession from Phase 1), then ADD the following without removing anything:

```python
# Add these imports at the top with existing imports:
from typing import Annotated
from fastapi import Depends
from fastapi.security import OAuth2PasswordBearer
from app.core.security import decode_access_token
from app.core.exceptions import AppError

# Add this constant (outside any function, at module level):
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/auth/login")


def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]) -> dict:
    """Decode the JWT access token. Returns payload dict with sub and role.

    Per CONTEXT.md locked decision: role comes from JWT claims, NOT from DB lookup.
    This means role changes take effect at next token issuance (next login).
    FastAPI's OAuth2PasswordBearer automatically returns 401 if Authorization header missing.
    """
    return decode_access_token(token)


def require_admin(current_user: Annotated[dict, Depends(get_current_user)]) -> dict:
    """Require admin role. Raises AppError(403) if role is not admin.

    Per CONTEXT.md: 403 Forbidden for insufficient role (not 401).
    """
    if current_user.get("role") != "admin":
        raise AppError(
            status_code=403,
            detail="Admin access required",
            code="AUTH_FORBIDDEN",
        )
    return current_user


# Type aliases for clean route parameter declarations (Phase 4+ will use these)
CurrentUser = Annotated[dict, Depends(get_current_user)]
AdminUser = Annotated[dict, Depends(require_admin)]
```

Run `ruff check app/users/service.py app/core/deps.py` and fix any violations.

Critical checks:
- DUMMY_HASH is computed at module load (top-level), NOT inside the login function
- verify_password is awaited in the user-not-found branch (not skipped)
- revoke_family targets token_family (UUID), not user_id
- get_current_user does NO database lookup (role from JWT claims only)
- require_admin checks role != "admin" exactly (not "ADMIN" — UserRole.USER = "user", UserRole.ADMIN = "admin")
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && poetry run python -c "
from app.users.service import AuthService, DUMMY_HASH
from app.core.deps import get_current_user, require_admin, CurrentUser, AdminUser
print('DUMMY_HASH computed:', DUMMY_HASH[:20], '...')
print('AuthService methods:', [m for m in dir(AuthService) if not m.startswith('_')])
print('CurrentUser type alias exists:', CurrentUser is not None)
print('All imports OK')
"</automated>
  </verify>
  <done>
    - app/users/service.py has AuthService with register, login, refresh, logout methods
    - DUMMY_HASH is a module-level constant (not computed per-request)
    - login() calls verify_password even when user is None (timing-safe)
    - refresh() calls revoke_family on rt.is_revoked (token reuse detection)
    - logout() is idempotent — returns None if already revoked
    - app/core/deps.py has oauth2_scheme, get_current_user, require_admin, CurrentUser, AdminUser
    - get_current_user makes no DB lookup (calls decode_access_token only)
    - require_admin checks role == "admin" (lowercase string, matching UserRole.ADMIN.value)
    - ruff check passes with zero violations on both files
  </done>
</task>

</tasks>

<verification>
Run the full test suite to confirm Phase 1 smoke tests still pass:

```bash
cd D:/Python/claude-test && poetry run pytest tests/ -v
```

Run ruff on all modified files:

```bash
cd D:/Python/claude-test && poetry run ruff check app/users/repository.py app/users/service.py app/core/deps.py && poetry run ruff format --check app/users/repository.py app/users/service.py app/core/deps.py
```

Verify imports chain correctly:

```bash
cd D:/Python/claude-test && poetry run python -c "
from app.users.service import AuthService
from app.users.repository import UserRepository, RefreshTokenRepository
from app.core.deps import get_current_user, require_admin, CurrentUser, AdminUser
print('Full import chain verified')
"
```
</verification>

<success_criteria>
- AuthService.register() returns (access_token, refresh_token) tuple for new user; raises AppError(409) for duplicate email
- AuthService.login() always calls verify_password regardless of whether email exists (timing-safe)
- AuthService.refresh() revokes old token and creates new one in same family; revokes entire family on reuse
- AuthService.logout() is idempotent — no error if token already revoked
- get_current_user decodes JWT from Authorization: Bearer header with no DB lookup
- require_admin raises AppError(403) for non-admin role
- All Phase 1 tests still pass
- ruff check passes with zero violations
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-auth/02-03-SUMMARY.md`
</output>
