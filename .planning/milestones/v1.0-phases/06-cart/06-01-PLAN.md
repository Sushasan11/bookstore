---
phase: 06-cart
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/cart/models.py
  - app/cart/schemas.py
  - app/cart/repository.py
  - app/cart/service.py
  - app/cart/router.py
  - alembic/versions/b2c3d4e5f6a7_create_carts_and_cart_items.py
  - alembic/env.py
  - app/main.py
autonomous: true
requirements:
  - COMM-01
  - COMM-02

must_haves:
  truths:
    - "Authenticated user can POST /cart/items with book_id and quantity and see the item via GET /cart"
    - "User can PUT /cart/items/{item_id} to change quantity and GET /cart reflects updated quantity"
    - "User can DELETE /cart/items/{item_id} and the item is removed from GET /cart response"
    - "Adding an out-of-stock book (stock_quantity == 0) returns 409 with CART_BOOK_OUT_OF_STOCK"
    - "Adding a duplicate book already in cart returns 409 with CART_ITEM_DUPLICATE"
    - "GET /cart for user with no cart returns empty items list (not 404)"
    - "User A cannot modify User B's cart items (403 CART_ITEM_FORBIDDEN)"
  artifacts:
    - path: "app/cart/models.py"
      provides: "Cart and CartItem SQLAlchemy models"
      contains: "class Cart"
    - path: "app/cart/schemas.py"
      provides: "CartItemAdd, CartItemUpdate, CartItemResponse, CartResponse schemas"
      contains: "class CartResponse"
    - path: "app/cart/repository.py"
      provides: "CartRepository with get_or_create and get_with_items; CartItemRepository with add/get_by_id/update/delete"
      contains: "class CartRepository"
    - path: "app/cart/service.py"
      provides: "CartService with add_item, update_item, remove_item, get_cart"
      contains: "class CartService"
    - path: "app/cart/router.py"
      provides: "GET /cart, POST /cart/items, PUT /cart/items/{item_id}, DELETE /cart/items/{item_id}"
      contains: "router = APIRouter"
    - path: "alembic/versions/b2c3d4e5f6a7_create_carts_and_cart_items.py"
      provides: "Migration creating carts and cart_items tables"
      contains: "uq_carts_user_id"
    - path: "app/main.py"
      provides: "cart_router registered in app"
      contains: "cart_router"
  key_links:
    - from: "app/cart/router.py"
      to: "app/cart/service.py"
      via: "_make_service(db) factory"
      pattern: "_make_service"
    - from: "app/cart/service.py"
      to: "app/books/repository.py"
      via: "BookRepository.get_by_id for stock check"
      pattern: "book_repo\\.get_by_id"
    - from: "app/cart/repository.py"
      to: "app/cart/models.py"
      via: "selectinload for eager loading Cart.items and CartItem.book"
      pattern: "selectinload"
    - from: "app/main.py"
      to: "app/cart/router.py"
      via: "include_router(cart_router)"
      pattern: "include_router.*cart_router"
---

<objective>
Build the complete cart feature: Cart and CartItem SQLAlchemy models, Alembic migration, Pydantic schemas, repository layer with get-or-create and eager loading, service layer with stock validation and ownership checks, and FastAPI router with 4 endpoints.

Purpose: Deliver COMM-01 (add books to cart) and COMM-02 (update/remove cart items) as a single vertical slice — models through HTTP surface — so the entire cart feature is functional after this plan.

Output: 8 files (6 new in app/cart/, 1 new migration, 2 modified) providing a fully wired cart API.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-cart/06-RESEARCH.md
@.planning/phases/04-catalog/04-01-SUMMARY.md
@.planning/phases/04-catalog/04-02-SUMMARY.md
@app/books/models.py
@app/books/repository.py
@app/books/service.py
@app/books/router.py
@app/books/schemas.py
@app/core/deps.py
@app/core/exceptions.py
@app/main.py
@alembic/env.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Cart and CartItem models + Alembic migration + alembic/env.py import</name>
  <files>
    app/cart/models.py
    alembic/versions/b2c3d4e5f6a7_create_carts_and_cart_items.py
    alembic/env.py
  </files>
  <action>
Create `app/cart/models.py` with two SQLAlchemy models following the established Phase 4 pattern (Mapped/mapped_column API, from app.db.base import Base):

**Cart model:**
- `__tablename__ = "carts"`
- `__table_args__` with `UniqueConstraint("user_id", name="uq_carts_user_id")` — enforces one cart per user at DB level
- `id: Mapped[int]` primary key
- `user_id: Mapped[int]` with `ForeignKey("users.id", ondelete="CASCADE")`, `nullable=False`, `index=True`
- `created_at: Mapped[datetime]` with `DateTime(timezone=True)`, `server_default=func.now()`, `nullable=False`
- `items: Mapped[list["CartItem"]]` relationship with `back_populates="cart"`, `cascade="all, delete-orphan"`

**CartItem model:**
- `__tablename__ = "cart_items"`
- `__table_args__` with `UniqueConstraint("cart_id", "book_id", name="uq_cart_items_cart_book")` — prevents duplicate book in same cart
- `id: Mapped[int]` primary key
- `cart_id: Mapped[int]` with `ForeignKey("carts.id", ondelete="CASCADE")`, `nullable=False`, `index=True`
- `book_id: Mapped[int]` with `ForeignKey("books.id", ondelete="CASCADE")`, `nullable=False`, `index=True`
- `quantity: Mapped[int]` with `Integer`, `nullable=False`, `default=1`
- `added_at: Mapped[datetime]` with `DateTime(timezone=True)`, `server_default=func.now()`, `nullable=False`
- `cart: Mapped["Cart"]` relationship with `back_populates="items"`
- `book: Mapped["Book"]` relationship (no back_populates — Book does not need to know about CartItem)

Import `Book` with `TYPE_CHECKING` guard to avoid circular imports: `from __future__ import annotations` at the top, and `from typing import TYPE_CHECKING` with `if TYPE_CHECKING: from app.books.models import Book`.

**Alembic migration** `alembic/versions/b2c3d4e5f6a7_create_carts_and_cart_items.py`:
- `revision = "b2c3d4e5f6a7"`
- `down_revision = "a1b2c3d4e5f6"` (chains off search_vector migration — current head)
- Hand-write (do NOT autogenerate) following project convention
- `upgrade()`: create `carts` table first (id, user_id, created_at, FK to users.id with CASCADE, PK, UniqueConstraint uq_carts_user_id), then create index ix_carts_user_id, then create `cart_items` table (id, cart_id, book_id, quantity with server_default="1", added_at, FK to carts.id CASCADE, FK to books.id CASCADE, PK, UniqueConstraint uq_cart_items_cart_book), then create indexes ix_cart_items_cart_id and ix_cart_items_book_id
- `downgrade()`: drop indexes, drop cart_items, drop index, drop carts (reverse order)
- IMPORTANT: In the cart_items ForeignKey for book_id, the column reference must be `["book_id"]` not `["books_id"]` (the research code example has a typo `books_id` — use `book_id`)

**alembic/env.py**: Add `from app.cart.models import Cart, CartItem  # noqa: F401` import alongside existing model imports (after the books import line).
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && poetry run python -c "from app.cart.models import Cart, CartItem; assert Cart.__tablename__ == 'carts'; assert CartItem.__tablename__ == 'cart_items'; constraints = {c.name for c in Cart.__table__.constraints if c.name}; assert 'uq_carts_user_id' in constraints; ci_constraints = {c.name for c in CartItem.__table__.constraints if c.name}; assert 'uq_cart_items_cart_book' in ci_constraints; print('Cart models OK')"</automated>
    <manual>Verify alembic/env.py has Cart and CartItem imports</manual>
  </verify>
  <done>Cart and CartItem models define carts and cart_items tables with all constraints; migration b2c3d4e5f6a7 chains off a1b2c3d4e5f6; alembic/env.py imports Cart and CartItem for autogenerate discovery and test create_all</done>
</task>

<task type="auto">
  <name>Task 2: Cart schemas, repository, service, router, and main.py registration</name>
  <files>
    app/cart/schemas.py
    app/cart/repository.py
    app/cart/service.py
    app/cart/router.py
    app/main.py
  </files>
  <action>
**app/cart/schemas.py** — Pydantic schemas following Phase 4 pattern (from_attributes=True):

- `CartItemAdd(BaseModel)`: `book_id: int`, `quantity: int = Field(ge=1, default=1)`
- `CartItemUpdate(BaseModel)`: `quantity: int = Field(ge=1)`
- `BookSummary(BaseModel)`: `id: int`, `title: str`, `author: str`, `price: Decimal`, `cover_image_url: str | None` — with `model_config = {"from_attributes": True}`
- `CartItemResponse(BaseModel)`: `id: int`, `book_id: int`, `quantity: int`, `book: BookSummary` — with `model_config = {"from_attributes": True}`
- `CartResponse(BaseModel)`: `items: list[CartItemResponse]`, with `@computed_field` properties for `total_items` (sum of quantities) and `total_price` (sum of book.price * quantity as Decimal)

**app/cart/repository.py** — CartRepository and CartItemRepository:

`CartRepository(session: AsyncSession)`:
- `get_or_create(user_id: int) -> Cart`: Use `pg_insert(Cart).values(user_id=user_id).on_conflict_do_nothing(index_elements=["user_id"])` then `SELECT Cart WHERE user_id == user_id` — race-condition-safe one-cart-per-user. Import `from sqlalchemy.dialects.postgresql import insert as pg_insert`.
- `get_with_items(user_id: int) -> Cart | None`: SELECT Cart WHERE user_id, with `selectinload(Cart.items).selectinload(CartItem.book)` — avoids N+1 and MissingGreenlet

`CartItemRepository(session: AsyncSession)`:
- `add(cart_id: int, book_id: int, quantity: int) -> CartItem`: Create CartItem, session.add, flush. Catch `IntegrityError` — if "uq_cart_items" or "cart_items" in str(e.orig).lower(), raise `AppError(409, "This book is already in your cart", "CART_ITEM_DUPLICATE", "book_id")`. After flush, use `await self.session.refresh(item, ["book"])` to load the book relationship for the response.
- `get_by_id(item_id: int) -> CartItem | None`: SELECT CartItem WHERE id, with `selectinload(CartItem.cart)` (for ownership check in service) and `selectinload(CartItem.book)` (for response serialization)
- `update_quantity(item: CartItem, quantity: int) -> CartItem`: `item.quantity = quantity`, `await self.session.flush()`, return item
- `delete(item: CartItem) -> None`: `await self.session.delete(item)`, `await self.session.flush()`

**app/cart/service.py** — CartService:

`CartService(cart_repo: CartRepository, cart_item_repo: CartItemRepository, book_repo: BookRepository)`:
- `get_cart(user_id: int) -> CartResponse`: Call `cart_repo.get_with_items(user_id)`. If None, return `CartResponse(items=[])` (virtual empty cart — do NOT create a DB row on GET). Otherwise build CartResponse from cart.items using `CartItemResponse.model_validate(item)` for each item.
- `add_item(user_id: int, book_id: int, quantity: int) -> CartItem`: (1) `book_repo.get_by_id(book_id)` — if None, raise `AppError(404, "Book not found", "BOOK_NOT_FOUND", "book_id")`; (2) if `book.stock_quantity == 0`, raise `AppError(409, "This book is out of stock and cannot be added to cart", "CART_BOOK_OUT_OF_STOCK", "book_id")`; (3) `cart_repo.get_or_create(user_id)`; (4) `cart_item_repo.add(cart.id, book_id, quantity)`
- `update_item(user_id: int, item_id: int, quantity: int) -> CartItem`: Call `_get_item_for_user(item_id, user_id)`, then `cart_item_repo.update_quantity(item, quantity)`
- `remove_item(user_id: int, item_id: int) -> None`: Call `_get_item_for_user(item_id, user_id)`, then `cart_item_repo.delete(item)`
- `_get_item_for_user(item_id: int, user_id: int) -> CartItem` (private helper): Fetch item via `cart_item_repo.get_by_id(item_id)`. If None, raise `AppError(404, "Cart item not found", "CART_ITEM_NOT_FOUND", "item_id")`. If `item.cart.user_id != user_id`, raise `AppError(403, "Not authorized to modify this cart item", "CART_ITEM_FORBIDDEN")`. Return item.

**app/cart/router.py** — APIRouter with prefix="/cart", tags=["cart"]:

- `_make_service(db)` factory: `CartService(CartRepository(db), CartItemRepository(db), BookRepository(db))`
- `GET ""` (maps to `/cart`): `response_model=CartResponse`, requires `CurrentUser`. Cast `user_id = int(current_user["sub"])`. Call `service.get_cart(user_id)`, return result directly (service returns CartResponse).
- `POST "/items"`: `response_model=CartItemResponse`, `status_code=201`, requires `CurrentUser`, body `CartItemAdd`. Call `service.add_item(user_id, body.book_id, body.quantity)`, return `CartItemResponse.model_validate(item)`.
- `PUT "/items/{item_id}"`: `response_model=CartItemResponse`, requires `CurrentUser`, body `CartItemUpdate`. Call `service.update_item(user_id, item_id, body.quantity)`, return `CartItemResponse.model_validate(item)`.
- `DELETE "/items/{item_id}"`: `status_code=204`, requires `CurrentUser`. Call `service.remove_item(user_id, item_id)`. Return None.

**app/main.py**: Add `from app.cart.router import router as cart_router` import and `application.include_router(cart_router)` after books_router registration.

IMPORTANT: `int(current_user["sub"])` — JWT sub is always a string, must cast to int. This applies to all 4 route handlers.
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && poetry run python -c "from app.cart.router import router; routes = {r.path: list(r.methods) for r in router.routes if hasattr(r, 'methods')}; print(routes); assert '/cart' in routes or '' in routes; assert '/cart/items' in routes or '/items' in routes; print('Cart routes OK')" && poetry run python -c "from app.main import app; paths = [r.path for r in app.routes]; assert '/cart' in paths; assert '/cart/items' in paths; assert '/cart/items/{item_id}' in paths; print('Cart routes in app OK')" && poetry run ruff check app/cart/ app/main.py alembic/env.py && poetry run ruff format --check app/cart/ app/main.py alembic/env.py</automated>
    <manual>Verify all 4 cart endpoints appear in the app routes</manual>
  </verify>
  <done>Schemas validate input (ge=1 on quantity), repository handles ON CONFLICT and selectinload, service enforces stock check and ownership, router exposes all 4 cart endpoints, main.py registers cart_router, ruff passes</done>
</task>

</tasks>

<verification>
1. `poetry run python -c "from app.cart.models import Cart, CartItem; print('Models import OK')"` — models importable
2. `poetry run python -c "from app.main import app; paths = [r.path for r in app.routes]; assert '/cart' in paths and '/cart/items' in paths and '/cart/items/{item_id}' in paths; print('All cart routes registered')"` — routes wired
3. `poetry run ruff check app/cart/ alembic/ app/main.py` — no lint errors
4. `poetry run ruff format --check app/cart/ alembic/ app/main.py` — formatting clean
5. `poetry run pytest tests/ -x` — existing tests still pass (no regressions)
</verification>

<success_criteria>
- Cart and CartItem models with UNIQUE constraints exist and import cleanly
- Migration b2c3d4e5f6a7 chains off a1b2c3d4e5f6 (search_vector head)
- alembic/env.py imports Cart and CartItem for model discovery
- GET /cart, POST /cart/items, PUT /cart/items/{item_id}, DELETE /cart/items/{item_id} all registered in app
- CartService enforces stock > 0 on add, ownership on update/delete, empty cart on GET for new user
- ruff check and ruff format pass on all modified files
- Existing test suite passes without regression
</success_criteria>

<output>
After completion, create `.planning/phases/06-cart/06-01-SUMMARY.md`
</output>
