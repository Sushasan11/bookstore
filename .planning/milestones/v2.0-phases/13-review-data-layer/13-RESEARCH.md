# Phase 13: Review Data Layer - Research

**Researched:** 2026-02-26
**Domain:** SQLAlchemy models, Alembic migrations, async repository pattern (PostgreSQL)
**Confidence:** HIGH

---

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

#### Review model fields
- Single `text` body field — no separate title/headline column
- Review text is optional (nullable) — users can submit rating-only reviews
- Max 2000 characters on review text (use `String(2000)` or `VARCHAR(2000)`)
- Soft-delete via `deleted_at` timestamp column — deleted reviews are filtered out by default but preserved for auditing
- Standard timestamps: `created_at`, `updated_at`

### Claude's Discretion
- Rating column type and constraints (integer 1-5 per roadmap success criteria)
- Repository interface design: pagination style, filter parameters, aggregate method signature
- Purchase verification logic: what order statuses qualify as "purchased"
- Default sort ordering for review list queries
- Whether aggregate computation is live query or cached

### Deferred Ideas (OUT OF SCOPE)
None — discussion stayed within phase scope
</user_constraints>

---

<phase_requirements>
## Phase Requirements

| ID | Description | Research Support |
|----|-------------|-----------------|
| REVW-05 | One review per user per book (duplicate submission returns 409) | `UniqueConstraint("user_id", "book_id")` on the `reviews` table enforces this at the DB level; repository `create()` catches `IntegrityError` and raises `AppError(409, ..., "REVIEW_DUPLICATE")` — identical pattern to `WishlistRepository.add()` |
| VPRC-01 | Only users with a completed order containing the book can submit a review | `OrderRepository.has_user_purchased_book(user_id, book_id)` queries `order_items JOIN orders WHERE status='confirmed'`; only `CONFIRMED` orders qualify (not `PAYMENT_FAILED`) |
</phase_requirements>

---

## Summary

Phase 13 is a pure data layer phase: one new SQLAlchemy model (`Review`), one Alembic migration, additions to two repositories (`ReviewRepository` new, `OrderRepository` extended), and one model registration in `alembic/env.py`. No API endpoints, no service logic, no schemas.

The codebase already has a well-established pattern for everything this phase needs. Models use `DeclarativeBase` with `Mapped`/`mapped_column` typed columns. Migrations are handwritten (not autogenerated), using `op.create_table()` with explicit constraint naming. Repositories are plain async classes injected with `AsyncSession`, flushing with `await self.session.flush()` and catching `IntegrityError` for duplicates. The `Review` model follows the exact structural pattern of `WishlistItem` (same FK pattern, same `UniqueConstraint` style) but adds `CheckConstraint` for rating (same pattern as `Book.price` and `Book.stock_quantity`), a nullable text field, and soft-delete via `deleted_at`.

The most important decision for Claude's Discretion areas is: use `Integer` for rating with a named `CheckConstraint("rating >= 1 AND rating <= 5", name="ck_reviews_rating_range")`; use `CONFIRMED`-only status check for purchase verification; sort reviews by `created_at DESC` with `id DESC` tiebreaker; compute aggregates live (consistent with STATE.md decision). The `test_health.py` success criterion requires the `Review` model to be imported in `alembic/env.py` (the project's model registry for Alembic discovery), NOT in `app/db/base.py` (which is just a thin `DeclarativeBase` with no imports).

**Primary recommendation:** Model `Review` on `WishlistItem` (same FK style, same `UniqueConstraint`), add `CheckConstraint` for rating following the `Book` pattern, and extend `OrderRepository` with a EXISTS-based purchase check joining `order_items` to `orders WHERE status = 'confirmed'`.

---

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| SQLAlchemy | ^2.0.47 | ORM, async session, `Mapped`/`mapped_column` API | Project baseline — all models use this |
| asyncpg | ^0.31.0 | PostgreSQL async driver | Project baseline driver |
| alembic | ^1.18.4 | Schema migrations | Project baseline — all migrations handwritten |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| `sqlalchemy.exc.IntegrityError` | (bundled) | Catch DB constraint violations in repository | Used in `WishlistRepository.add()` and `PreBookRepository.add()` for 409 responses |
| `sqlalchemy.UniqueConstraint` | (bundled) | One review per user/book | Used in `WishlistItem`, `CartItem`, `OAuthAccount` |
| `sqlalchemy.CheckConstraint` | (bundled) | Enforce rating 1–5 | Used in `Book` for price and stock |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| `Integer` rating with `CheckConstraint` | `SmallInteger` | `SmallInteger` maps to `SMALLINT` in PostgreSQL; `Integer` maps to `INT`. Either works; `Integer` matches existing codebase convention (all other int columns use `Integer`) |
| Live aggregate query | Stored `avg_rating`/`review_count` on `books` table | STATE.md explicitly decided live query — do not denormalize |
| `EXISTS` subquery for purchase check | JOIN query | Both work; EXISTS is slightly more efficient for boolean result |

**Installation:** No new packages required. All tools are in the existing stack.

---

## Architecture Patterns

### Recommended Project Structure

```
app/
└── reviews/
    ├── __init__.py
    ├── models.py          # Review model
    └── repository.py      # ReviewRepository

app/orders/
└── repository.py          # Add has_user_purchased_book() here

alembic/
└── versions/
    └── {rev}_create_reviews.py    # New migration

alembic/env.py             # Add Review import for Alembic discovery
```

**Note:** The `Review` model does NOT go in a `reviews/` router/schema/service — those are Phase 14. Phase 13 creates the directory with only `__init__.py`, `models.py`, `repository.py`.

### Pattern 1: SQLAlchemy Model with UniqueConstraint + CheckConstraint

**What:** Declare `Review` using the same `Mapped`/`mapped_column` style as all other models, with `__table_args__` containing both constraints.

**When to use:** Any model that needs both uniqueness and value-range enforcement.

**Example (derived from `WishlistItem` and `Book` patterns in codebase):**
```python
# app/reviews/models.py
from __future__ import annotations

from datetime import datetime
from typing import TYPE_CHECKING

from sqlalchemy import CheckConstraint, DateTime, ForeignKey, Integer, String, UniqueConstraint, func
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.db.base import Base

if TYPE_CHECKING:
    from app.books.models import Book
    from app.users.models import User


class Review(Base):
    __tablename__ = "reviews"

    __table_args__ = (
        UniqueConstraint("user_id", "book_id", name="uq_reviews_user_book"),
        CheckConstraint("rating >= 1 AND rating <= 5", name="ck_reviews_rating_range"),
    )

    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(
        ForeignKey("users.id", ondelete="CASCADE"), nullable=False, index=True
    )
    book_id: Mapped[int] = mapped_column(
        ForeignKey("books.id", ondelete="CASCADE"), nullable=False, index=True
    )
    rating: Mapped[int] = mapped_column(Integer, nullable=False)
    text: Mapped[str | None] = mapped_column(String(2000), nullable=True)
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), nullable=False
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False
    )
    deleted_at: Mapped[datetime | None] = mapped_column(
        DateTime(timezone=True), nullable=True
    )

    book: Mapped[Book] = relationship()
    user: Mapped[User] = relationship()
```

**Confidence:** HIGH — derived directly from `WishlistItem`, `Book`, `PreBooking`, and `OAuthAccount` patterns in the codebase.

### Pattern 2: Alembic Handwritten Migration

**What:** Create migration manually using `op.create_table()` with explicit constraint objects. Project does NOT use `--autogenerate`.

**Example (following `e5f6a7b8c9d0_create_wishlist_items.py` pattern):**
```python
# alembic/versions/{rev}_create_reviews.py
import sqlalchemy as sa
from alembic import op

revision: str = "{new_rev}"
down_revision: str | None = "f1a2b3c4d5e6"  # pre_bookings is current HEAD

def upgrade() -> None:
    op.create_table(
        "reviews",
        sa.Column("id", sa.Integer(), nullable=False),
        sa.Column("user_id", sa.Integer(), nullable=False),
        sa.Column("book_id", sa.Integer(), nullable=False),
        sa.Column("rating", sa.Integer(), nullable=False),
        sa.Column("text", sa.String(2000), nullable=True),
        sa.Column("created_at", sa.DateTime(timezone=True),
                  server_default=sa.text("now()"), nullable=False),
        sa.Column("updated_at", sa.DateTime(timezone=True),
                  server_default=sa.text("now()"), nullable=False),
        sa.Column("deleted_at", sa.DateTime(timezone=True), nullable=True),
        sa.ForeignKeyConstraint(["user_id"], ["users.id"], ondelete="CASCADE"),
        sa.ForeignKeyConstraint(["book_id"], ["books.id"], ondelete="CASCADE"),
        sa.PrimaryKeyConstraint("id"),
        sa.UniqueConstraint("user_id", "book_id", name="uq_reviews_user_book"),
        sa.CheckConstraint("rating >= 1 AND rating <= 5", name="ck_reviews_rating_range"),
    )
    op.create_index("ix_reviews_user_id", "reviews", ["user_id"])
    op.create_index("ix_reviews_book_id", "reviews", ["book_id"])

def downgrade() -> None:
    op.drop_index("ix_reviews_book_id", table_name="reviews")
    op.drop_index("ix_reviews_user_id", table_name="reviews")
    op.drop_table("reviews")
```

**Confidence:** HIGH — mirrors exact structure of all existing migrations.

### Pattern 3: Repository with IntegrityError Handling for 409

**What:** `ReviewRepository.create()` catches `IntegrityError`, checks constraint name in the error string, and raises `AppError(409)`. Same pattern as `WishlistRepository.add()` and `PreBookRepository.add()`.

**Example (derived from WishlistRepository and PreBookRepository):**
```python
# app/reviews/repository.py
from sqlalchemy.exc import IntegrityError
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.exceptions import AppError
from app.reviews.models import Review

class ReviewRepository:
    def __init__(self, session: AsyncSession) -> None:
        self.session = session

    async def create(self, user_id: int, book_id: int, rating: int, text: str | None) -> Review:
        review = Review(user_id=user_id, book_id=book_id, rating=rating, text=text)
        self.session.add(review)
        try:
            await self.session.flush()
        except IntegrityError as e:
            await self.session.rollback()
            orig = str(e.orig).lower() if e.orig else ""
            if "uq_reviews_user_book" in orig or "reviews" in orig:
                raise AppError(409, "You have already reviewed this book",
                               "REVIEW_DUPLICATE", "book_id") from e
            raise
        await self.session.refresh(review, ["book", "user"])
        return review
```

**Confidence:** HIGH — exact pattern from existing repositories.

### Pattern 4: Paginated List with Soft-Delete Filter

**What:** All list queries must filter `Review.deleted_at.is_(None)` by default. Pagination follows `BookRepository.search()` pattern: `count_stmt` then `limit/offset`.

**Example:**
```python
async def list_for_book(
    self, book_id: int, *, page: int = 1, size: int = 20
) -> tuple[list[Review], int]:
    stmt = (
        select(Review)
        .where(Review.book_id == book_id, Review.deleted_at.is_(None))
        .order_by(Review.created_at.desc(), Review.id.desc())
        .options(selectinload(Review.user))
    )
    count_stmt = select(func.count()).select_from(stmt.subquery())
    total = await self.session.scalar(count_stmt)
    offset = (page - 1) * size
    result = await self.session.execute(stmt.limit(size).offset(offset))
    return list(result.scalars().all()), total or 0
```

**Confidence:** HIGH — pagination pattern from `BookRepository.search()`, soft-delete filter from CONTEXT.md decisions.

### Pattern 5: Soft Delete

**What:** `delete()` sets `deleted_at = datetime.now(UTC)` and flushes. Does NOT call `session.delete()`. Follows the pre-booking cancel pattern.

**Example:**
```python
async def soft_delete(self, review: Review) -> None:
    review.deleted_at = datetime.now(UTC)
    await self.session.flush()
```

**Confidence:** HIGH — mirrors `PreBookRepository.cancel()` soft-delete pattern.

### Pattern 6: OrderRepository.has_user_purchased_book()

**What:** Return `True` if any `CONFIRMED` order for the user contains the book. `PAYMENT_FAILED` orders do NOT qualify. Use `EXISTS` subquery via `select(exists(...))`.

**Example:**
```python
# app/orders/repository.py (addition)
from sqlalchemy import exists, select
from app.orders.models import Order, OrderItem, OrderStatus

async def has_user_purchased_book(self, user_id: int, book_id: int) -> bool:
    stmt = select(
        exists().where(
            Order.user_id == user_id,
            Order.status == OrderStatus.CONFIRMED,
            OrderItem.order_id == Order.id,
            OrderItem.book_id == book_id,
        )
    )
    result = await self.session.scalar(stmt)
    return bool(result)
```

**Confidence:** HIGH — `OrderStatus.CONFIRMED` is the only status that represents a completed purchase; `PAYMENT_FAILED` explicitly does not qualify.

### Pattern 7: Model Registration in alembic/env.py

**What:** The success criterion says "`pytest tests/test_health.py` passes without `UndefinedTableError`". The `test_health.py` test exercises `Base.metadata.create_all`. For Alembic to detect the model AND for `Base.metadata.create_all` to include the table, the model must be imported in `alembic/env.py` (the actual model registry, per `STATE.md` accumulated context: "app/db/base.py is the model registry — all new models must be imported here immediately on creation"). However, `app/db/base.py` contains only `DeclarativeBase` with NO model imports. The actual imports live in `alembic/env.py` and the `conftest.py` references `Base.metadata` which is populated by whatever has been imported into `Base`'s registry at that point.

**Key insight from STATE.md and alembic/env.py inspection:** `alembic/env.py` imports all models explicitly. The `conftest.py` imports `from app.db.base import Base` and runs `Base.metadata.create_all`. For the `Review` table to be included in `create_all`, the `Review` model must be imported somewhere that runs before the test session starts — specifically, it must be imported in `alembic/env.py` AND in `app/main.py` import chain OR directly in `conftest.py`. Looking at the pattern: the existing `conftest.py` does NOT import models directly — instead `app.main` imports routers which import models. Since Phase 13 creates no router, the `Review` import must be added to `alembic/env.py`.

**Add to alembic/env.py:**
```python
from app.reviews.models import Review  # noqa: F401
```

**Confidence:** HIGH — confirmed by reading `alembic/env.py` directly and observing the existing import pattern for all other models.

### Anti-Patterns to Avoid

- **Using `app/db/base.py` as a model import registry:** `app/db/base.py` is ONLY the `DeclarativeBase` definition — it has no model imports. All model imports for Alembic live in `alembic/env.py`. The STATE.md note about "model registry" refers to this file.
- **Autogenerating the migration:** Do not use `alembic revision --autogenerate`. Handwrite the migration following the existing file pattern.
- **Hard-deleting reviews:** CONTEXT.md locked soft-delete via `deleted_at`. `session.delete()` is never called on a `Review`.
- **Including PAYMENT_FAILED orders in purchase check:** Only `CONFIRMED` orders qualify. This is explicitly decided in Claude's Discretion.
- **Forgetting to filter `deleted_at IS NULL`:** Every list query must include `Review.deleted_at.is_(None)` to exclude soft-deleted reviews.
- **Using `onupdate=func.now()` for `updated_at` in migration:** Alembic migrations use raw SQL DDL — `onupdate` is a SQLAlchemy ORM-only feature. Set only `server_default=sa.text("now()")` in the migration; the `onupdate` lives in the ORM model definition only.
- **Missing `from __future__ import annotations`:** All models that use `TYPE_CHECKING` imports use this future import. Follow the same convention.

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Unique-per-user-book enforcement | Application-level check before insert | `UniqueConstraint` + catch `IntegrityError` | Races between concurrent requests make app-level checks unreliable |
| Rating range enforcement | Application validation only | `CheckConstraint("rating >= 1 AND rating <= 5")` | DB constraint survives bypassing the API layer |
| Purchase verification | Reimplementing order join logic | Extend existing `OrderRepository` | Order data is already modeled — add method there, not a separate class |
| Aggregate computation | Store on books table | Live `func.avg()` / `func.count()` query | STATE.md explicitly decided live query |

**Key insight:** The DB constraint is the authoritative source of truth. Application validation (Pydantic) is a UX convenience — the DB constraint is the real guard.

---

## Common Pitfalls

### Pitfall 1: Missing Review Import Causes `UndefinedTableError` in test_health.py

**What goes wrong:** `Base.metadata.create_all` skips the `reviews` table because `Review` was never imported into the Python process. `test_health.py` fails with `UndefinedTableError` on any route that touches the DB.

**Why it happens:** SQLAlchemy registers models into `Base.metadata` when the class body is executed (i.e., when the module is imported). If `reviews/models.py` is never imported, the table does not appear in metadata.

**How to avoid:** Add `from app.reviews.models import Review  # noqa: F401` to `alembic/env.py` — the same file where all other models are imported.

**Warning signs:** `test_health.py` passes in isolation but fails after adding a new model.

### Pitfall 2: `updated_at` Not Updating on ORM Mutations

**What goes wrong:** `updated_at` stays at its initial value after `review.text = new_text; await session.flush()`.

**Why it happens:** `server_default=func.now()` only sets the value at INSERT time. `onupdate=func.now()` is the ORM-level trigger for UPDATE statements — it must be set on the ORM column.

**How to avoid:** Set `onupdate=func.now()` on the `updated_at` `mapped_column()` in `models.py` (same as `Book.updated_at`). The migration only needs `server_default`.

**Warning signs:** Test asserts `review.updated_at > review.created_at` after an update, but they are equal.

### Pitfall 3: Soft-Delete Filter Forgotten in get_by_id

**What goes wrong:** `get_by_id()` returns a soft-deleted review, allowing update/re-delete on a "deleted" review.

**Why it happens:** `get_by_id()` only filters on `id`, forgetting `deleted_at IS NULL`.

**How to avoid:** Every `get_*` method that the service layer uses for modification must include `.where(Review.deleted_at.is_(None))`. A separate `get_by_id_including_deleted()` can exist for admin audit purposes.

**Warning signs:** A deleted review can be fetched and updated.

### Pitfall 4: `has_user_purchased_book()` Counting PAYMENT_FAILED Orders

**What goes wrong:** A user whose order failed payment can still submit a review.

**Why it happens:** Querying `order_items` without filtering by `Order.status`.

**How to avoid:** The JOIN must include `Order.status == OrderStatus.CONFIRMED`. See Pattern 6 above.

**Warning signs:** Integration test creates a PAYMENT_FAILED order and the purchase check returns True.

### Pitfall 5: `IntegrityError` String Matching Too Broad

**What goes wrong:** A FK violation (non-existent `book_id`) is caught as a duplicate review error, returning a misleading 409 instead of a proper 404/422.

**Why it happens:** `"reviews" in orig` matches any integrity error on the reviews table, including FK violations.

**How to avoid:** Check for the specific constraint name first: `"uq_reviews_user_book" in orig`. Only fall back to `"reviews" in orig` for the duplicate case if the constraint name check fails. Actually, the best approach is to validate that `book_id` exists before insert (which is the service layer's responsibility in Phase 14). The repository should re-raise unknown `IntegrityError`s.

**Warning signs:** `AppError(409, "REVIEW_DUPLICATE")` appears on a request with a non-existent `book_id`.

### Pitfall 6: Missing `__init__.py` in `app/reviews/`

**What goes wrong:** Python cannot import from `app.reviews.models`, raising `ModuleNotFoundError`.

**How to avoid:** Create `app/reviews/__init__.py` as an empty file when creating the directory.

---

## Code Examples

Verified patterns from existing codebase:

### Full Review model (complete, ready-to-use)
```python
# app/reviews/models.py
# Source: derived from app/wishlist/models.py + app/books/models.py
from __future__ import annotations

from datetime import datetime
from typing import TYPE_CHECKING

from sqlalchemy import CheckConstraint, DateTime, ForeignKey, Integer, String, UniqueConstraint, func
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.db.base import Base

if TYPE_CHECKING:
    from app.books.models import Book
    from app.users.models import User


class Review(Base):
    __tablename__ = "reviews"

    __table_args__ = (
        UniqueConstraint("user_id", "book_id", name="uq_reviews_user_book"),
        CheckConstraint("rating >= 1 AND rating <= 5", name="ck_reviews_rating_range"),
    )

    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(
        ForeignKey("users.id", ondelete="CASCADE"), nullable=False, index=True
    )
    book_id: Mapped[int] = mapped_column(
        ForeignKey("books.id", ondelete="CASCADE"), nullable=False, index=True
    )
    rating: Mapped[int] = mapped_column(Integer, nullable=False)
    text: Mapped[str | None] = mapped_column(String(2000), nullable=True)
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), nullable=False
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now(),
        nullable=False,
    )
    deleted_at: Mapped[datetime | None] = mapped_column(
        DateTime(timezone=True), nullable=True
    )

    book: Mapped[Book] = relationship()
    user: Mapped[User] = relationship()
```

### ReviewRepository — paginated list with soft-delete filter
```python
# Source: BookRepository.search() pagination pattern + CONTEXT.md soft-delete decision
from sqlalchemy import func, select
from sqlalchemy.orm import selectinload
from app.reviews.models import Review

async def list_for_book(
    self, book_id: int, *, page: int = 1, size: int = 20
) -> tuple[list[Review], int]:
    stmt = (
        select(Review)
        .where(Review.book_id == book_id, Review.deleted_at.is_(None))
        .order_by(Review.created_at.desc(), Review.id.desc())
        .options(selectinload(Review.user))
    )
    count_stmt = select(func.count()).select_from(stmt.subquery())
    total = await self.session.scalar(count_stmt)
    offset = (page - 1) * size
    result = await self.session.execute(stmt.limit(size).offset(offset))
    return list(result.scalars().all()), total or 0
```

### ReviewRepository — aggregate (live query)
```python
# Source: STATE.md decision — live query not cached
from sqlalchemy import func, select
from app.reviews.models import Review

async def get_aggregates(self, book_id: int) -> dict:
    """Return avg_rating and review_count for a book (excluding soft-deleted)."""
    stmt = select(
        func.avg(Review.rating).label("avg_rating"),
        func.count(Review.id).label("review_count"),
    ).where(Review.book_id == book_id, Review.deleted_at.is_(None))
    result = await self.session.execute(stmt)
    row = result.one()
    return {
        "avg_rating": float(round(row.avg_rating, 1)) if row.avg_rating else None,
        "review_count": row.review_count or 0,
    }
```

**Note:** Full ROUND-to-decimal precision (for Phase 15 AGGR-01) requires `func.round(func.avg(Review.rating).cast(Numeric), 1)` — STATE.md notes that `func.avg()` returns `DOUBLE PRECISION` which is incompatible with the two-argument `ROUND` in PostgreSQL. For Phase 13 this method is informational — Phase 15 will own the aggregate API. Keep it simple here.

### OrderRepository — has_user_purchased_book (addition to existing class)
```python
# Source: app/orders/repository.py (addition) — uses existing Order/OrderItem/OrderStatus
from sqlalchemy import exists, select
from app.orders.models import Order, OrderItem, OrderStatus

async def has_user_purchased_book(self, user_id: int, book_id: int) -> bool:
    """Return True if user has a CONFIRMED order containing this book."""
    stmt = select(
        exists().where(
            Order.user_id == user_id,
            Order.status == OrderStatus.CONFIRMED,
            OrderItem.order_id == Order.id,
            OrderItem.book_id == book_id,
        )
    )
    result = await self.session.scalar(stmt)
    return bool(result)
```

---

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| `Column()` style (SQLAlchemy 1.x) | `Mapped`/`mapped_column()` (SQLAlchemy 2.0) | SQLAlchemy 2.0 release | All models in this project use the new style; do NOT use `Column()` |
| `Base = declarative_base()` | `class Base(DeclarativeBase): pass` | SQLAlchemy 2.0 | Project uses `DeclarativeBase` subclass pattern |
| Synchronous sessions | `AsyncSession` with `asyncpg` | Project design | ALL database access is async; never use synchronous session methods |

**Deprecated/outdated:**
- `Column()`: Do not use. All new columns use `mapped_column()` with `Mapped[type]` type annotation.
- `@declared_attr`: Not needed for this simple model.
- `autoflush=True` (default): Project explicitly disables autoflush — all flushes are explicit `await session.flush()`.

---

## Open Questions

1. **Revision ID for the new migration**
   - What we know: Current HEAD is `f1a2b3c4d5e6` (pre_bookings migration)
   - What's unclear: The actual random hex revision ID — Alembic generates this
   - Recommendation: Planner should specify generating with `alembic revision -m "create_reviews"` and then setting `down_revision = "f1a2b3c4d5e6"`. The task description should note that the ID is autogenerated.

2. **`get_by_user_and_book()` method needed in Phase 13 or 14?**
   - What we know: Phase 14 (CRUD endpoints) needs to fetch a specific review to enforce ownership before update/delete
   - What's unclear: Whether to include this lookup method in Phase 13 repository or defer to Phase 14
   - Recommendation: Include `get_by_user_and_book(user_id, book_id)` and `get_by_id(review_id)` in Phase 13 as they are pure data access with no service logic dependency. Phase 14 will use them.

3. **`updated_at` server-side update in PostgreSQL**
   - What we know: SQLAlchemy's `onupdate=func.now()` works at the ORM level (Python sets the value before the UPDATE statement)
   - What's unclear: Whether a PostgreSQL trigger is needed for correctness when rows are updated outside the ORM
   - Recommendation: `onupdate=func.now()` is sufficient for this project's use case. No trigger needed — all updates go through the ORM.

---

## Sources

### Primary (HIGH confidence)
- Direct codebase inspection — `app/wishlist/models.py`, `app/books/models.py`, `app/orders/models.py`, `app/orders/repository.py`, `app/wishlist/repository.py`, `app/prebooks/models.py`, `app/prebooks/repository.py`
- `alembic/env.py` — confirmed model import pattern and `Base.metadata` usage
- `alembic/versions/e5f6a7b8c9d0_create_wishlist_items.py` — migration structure template
- `alembic/versions/f1a2b3c4d5e6_create_pre_bookings.py` — CheckConstraint and partial index examples in migration
- `tests/conftest.py` — confirmed `Base.metadata.create_all` is the test table creation mechanism
- `.planning/STATE.md` — accumulated decisions: CASCADE FK, live aggregates, func.avg().cast(Numeric) requirement
- `.planning/REQUIREMENTS.md` — REVW-05 and VPRC-01 requirement text
- `.planning/phases/13-review-data-layer/13-CONTEXT.md` — locked decisions and discretion areas

### Secondary (MEDIUM confidence)
- `pyproject.toml` — confirmed SQLAlchemy ^2.0.47, alembic ^1.18.4, asyncpg ^0.31.0 versions

### Tertiary (LOW confidence)
- None — all findings are grounded in direct codebase inspection.

---

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH — verified against `pyproject.toml` and existing usage
- Architecture: HIGH — all patterns derived directly from existing codebase files
- Pitfalls: HIGH — derived from observed patterns and explicit STATE.md decisions

**Research date:** 2026-02-26
**Valid until:** 2026-03-28 (stable stack, 30-day window)
