---
phase: 13-review-data-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/reviews/__init__.py
  - app/reviews/models.py
  - app/reviews/repository.py
  - alembic/versions/a1b2c3d4e5f6_create_reviews.py
  - alembic/env.py
autonomous: true
requirements:
  - REVW-05

must_haves:
  truths:
    - "A migration runs cleanly creating the reviews table with UniqueConstraint(user_id, book_id) and CheckConstraint(rating >= 1 AND rating <= 5)"
    - "Attempting to insert two reviews for the same user/book pair raises a database-level IntegrityError"
    - "ReviewRepository exposes create, get_by_id, get_by_user_and_book, update, soft_delete, list_for_book (paginated), and get_aggregates methods"
    - "All list/get queries filter deleted_at IS NULL by default"
    - "Review model is registered in alembic/env.py and Base.metadata includes the reviews table"
  artifacts:
    - path: "app/reviews/__init__.py"
      provides: "Python package marker for reviews module"
    - path: "app/reviews/models.py"
      provides: "Review SQLAlchemy model with UniqueConstraint and CheckConstraint"
      contains: "class Review(Base)"
    - path: "app/reviews/repository.py"
      provides: "ReviewRepository with full CRUD + aggregate methods"
      exports: ["ReviewRepository"]
    - path: "alembic/versions/a1b2c3d4e5f6_create_reviews.py"
      provides: "Migration creating reviews table"
      contains: "op.create_table"
    - path: "alembic/env.py"
      provides: "Review model registration for Alembic discovery"
      contains: "from app.reviews.models import Review"
  key_links:
    - from: "app/reviews/models.py"
      to: "app/db/base.py"
      via: "class Review(Base)"
      pattern: "from app\\.db\\.base import Base"
    - from: "app/reviews/repository.py"
      to: "app/reviews/models.py"
      via: "import Review model"
      pattern: "from app\\.reviews\\.models import Review"
    - from: "alembic/env.py"
      to: "app/reviews/models.py"
      via: "model registration import"
      pattern: "from app\\.reviews\\.models import Review"
    - from: "app/reviews/repository.py"
      to: "app/core/exceptions.py"
      via: "AppError for 409 duplicate"
      pattern: "from app\\.core\\.exceptions import AppError"
---

<objective>
Create the Review SQLAlchemy model, Alembic migration, and ReviewRepository with all data-access methods needed by Phase 14's service layer.

Purpose: Establish the data foundation for the reviews feature — model, migration, and repository — so that Phase 14 can build CRUD endpoints on top of a fully tested data layer.
Output: `app/reviews/` package with model and repository, migration file creating `reviews` table, model registered in `alembic/env.py`.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-review-data-layer/13-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From app/db/base.py:
```python
from sqlalchemy.orm import DeclarativeBase

class Base(DeclarativeBase):
    pass
```

From app/core/exceptions.py:
```python
class AppError(Exception):
    def __init__(
        self,
        status_code: int,
        detail: str,
        code: str,
        field: str | None = None,
    ) -> None: ...
```

From app/wishlist/repository.py (pattern to follow for IntegrityError handling):
```python
from sqlalchemy.exc import IntegrityError
from app.core.exceptions import AppError

async def add(self, user_id: int, book_id: int) -> WishlistItem:
    item = WishlistItem(user_id=user_id, book_id=book_id)
    self.session.add(item)
    try:
        await self.session.flush()
    except IntegrityError as e:
        await self.session.rollback()
        orig = str(e.orig).lower() if e.orig else ""
        if "uq_wishlist_items" in orig or "wishlist_items" in orig:
            raise AppError(409, "...", "WISHLIST_ITEM_DUPLICATE", "book_id") from e
        raise
```

From alembic/env.py (model registration pattern):
```python
from app.books.models import Book, Genre  # noqa: F401
from app.cart.models import Cart, CartItem  # noqa: F401
from app.orders.models import Order, OrderItem  # noqa: F401
from app.prebooks.models import PreBooking  # noqa: F401
from app.users.models import OAuthAccount, RefreshToken, User  # noqa: F401
from app.wishlist.models import WishlistItem  # noqa: F401
```

From alembic/versions/f1a2b3c4d5e6_create_pre_bookings.py (current HEAD migration):
```python
revision: str = "f1a2b3c4d5e6"
down_revision: str | None = "e5f6a7b8c9d0"
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Review model and Alembic migration</name>
  <files>
    app/reviews/__init__.py
    app/reviews/models.py
    alembic/versions/a1b2c3d4e5f6_create_reviews.py
    alembic/env.py
  </files>
  <action>
1. Create `app/reviews/__init__.py` — empty file (package marker).

2. Create `app/reviews/models.py` following the exact pattern from `app/wishlist/models.py` and `app/books/models.py`:

```python
from __future__ import annotations

from datetime import datetime
from typing import TYPE_CHECKING

from sqlalchemy import CheckConstraint, DateTime, ForeignKey, Integer, String, UniqueConstraint, func
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.db.base import Base

if TYPE_CHECKING:
    from app.books.models import Book
    from app.users.models import User


class Review(Base):
    __tablename__ = "reviews"

    __table_args__ = (
        UniqueConstraint("user_id", "book_id", name="uq_reviews_user_book"),
        CheckConstraint("rating >= 1 AND rating <= 5", name="ck_reviews_rating_range"),
    )

    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(
        ForeignKey("users.id", ondelete="CASCADE"), nullable=False, index=True
    )
    book_id: Mapped[int] = mapped_column(
        ForeignKey("books.id", ondelete="CASCADE"), nullable=False, index=True
    )
    rating: Mapped[int] = mapped_column(Integer, nullable=False)
    text: Mapped[str | None] = mapped_column(String(2000), nullable=True)
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), nullable=False
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now(),
        nullable=False,
    )
    deleted_at: Mapped[datetime | None] = mapped_column(
        DateTime(timezone=True), nullable=True
    )

    book: Mapped[Book] = relationship()
    user: Mapped[User] = relationship()
```

Key decisions per CONTEXT.md locked decisions:
- Single `text` field (no separate title/headline)
- `text` is nullable (rating-only reviews allowed)
- `String(2000)` for max 2000 characters
- `deleted_at` for soft-delete
- `created_at` and `updated_at` standard timestamps
- `onupdate=func.now()` on `updated_at` ORM column (NOT in migration — migration only has `server_default`)
- CASCADE on both FKs per STATE.md v2.0 research decision

3. Create `alembic/versions/a1b2c3d4e5f6_create_reviews.py` — handwritten migration, NOT autogenerated. Use revision ID `a1b2c3d4e5f6` and `down_revision = "f1a2b3c4d5e6"` (pre_bookings HEAD):

```python
"""Create reviews table.

Revision ID: a1b2c3d4e5f6
Revises: f1a2b3c4d5e6
Create Date: 2026-02-26
"""
from collections.abc import Sequence

import sqlalchemy as sa
from alembic import op

revision: str = "a1b2c3d4e5f6"
down_revision: str | None = "f1a2b3c4d5e6"
branch_labels: str | Sequence[str] | None = None
depends_on: str | Sequence[str] | None = None


def upgrade() -> None:
    op.create_table(
        "reviews",
        sa.Column("id", sa.Integer(), nullable=False),
        sa.Column("user_id", sa.Integer(), nullable=False),
        sa.Column("book_id", sa.Integer(), nullable=False),
        sa.Column("rating", sa.Integer(), nullable=False),
        sa.Column("text", sa.String(2000), nullable=True),
        sa.Column("created_at", sa.DateTime(timezone=True),
                  server_default=sa.text("now()"), nullable=False),
        sa.Column("updated_at", sa.DateTime(timezone=True),
                  server_default=sa.text("now()"), nullable=False),
        sa.Column("deleted_at", sa.DateTime(timezone=True), nullable=True),
        sa.ForeignKeyConstraint(["user_id"], ["users.id"], ondelete="CASCADE"),
        sa.ForeignKeyConstraint(["book_id"], ["books.id"], ondelete="CASCADE"),
        sa.PrimaryKeyConstraint("id"),
        sa.UniqueConstraint("user_id", "book_id", name="uq_reviews_user_book"),
        sa.CheckConstraint("rating >= 1 AND rating <= 5", name="ck_reviews_rating_range"),
    )
    op.create_index("ix_reviews_user_id", "reviews", ["user_id"])
    op.create_index("ix_reviews_book_id", "reviews", ["book_id"])


def downgrade() -> None:
    op.drop_index("ix_reviews_book_id", table_name="reviews")
    op.drop_index("ix_reviews_user_id", table_name="reviews")
    op.drop_table("reviews")
```

IMPORTANT anti-patterns to avoid:
- Do NOT use `onupdate` in the migration — that is ORM-only. Migration only has `server_default=sa.text("now()")` for `updated_at`.
- Do NOT use `alembic revision --autogenerate`. Handwrite the migration.

4. Register the Review model in `alembic/env.py` — add the import after the existing model imports, following the same pattern:

```python
from app.reviews.models import Review  # noqa: F401
```

Add this line after `from app.prebooks.models import PreBooking  # noqa: F401` and before `from app.users.models import ...`.
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && python -c "from app.reviews.models import Review; print('Model imported:', Review.__tablename__)" && python -c "from app.db.base import Base; assert 'reviews' in Base.metadata.tables, 'reviews table not in metadata'; print('reviews table registered in Base.metadata')" && pytest tests/test_health.py -x -q 2>&1 | tail -5</automated>
  </verify>
  <done>
    - Review model class exists in `app/reviews/models.py` with UniqueConstraint and CheckConstraint
    - Migration file creates `reviews` table with all columns, constraints, and indexes
    - `from app.reviews.models import Review` works without error
    - `Base.metadata.tables` includes "reviews"
    - `pytest tests/test_health.py` passes without UndefinedTableError
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ReviewRepository with full CRUD and aggregate methods</name>
  <files>
    app/reviews/repository.py
  </files>
  <action>
Create `app/reviews/repository.py` with a `ReviewRepository` class following the exact patterns from `WishlistRepository` and `BookRepository`. The class takes an `AsyncSession` in `__init__`.

Methods to implement:

1. **`create(user_id, book_id, rating, text=None) -> Review`**
   - Creates a Review, flushes, catches `IntegrityError` for duplicate (same pattern as `WishlistRepository.add()`).
   - On `IntegrityError`: rollback, check for `"uq_reviews_user_book"` in orig string, raise `AppError(409, "You have already reviewed this book", "REVIEW_DUPLICATE", "book_id")`.
   - Re-raise unknown IntegrityErrors (do NOT catch FK violations as duplicates — see Pitfall 5 in RESEARCH.md).
   - After successful flush, `await self.session.refresh(review, ["book", "user"])` to eager-load relationships.

2. **`get_by_id(review_id) -> Review | None`**
   - SELECT with `Review.id == review_id` AND `Review.deleted_at.is_(None)`.
   - Uses `selectinload(Review.user)` and `selectinload(Review.book)`.
   - Returns `scalar_one_or_none()`.

3. **`get_by_user_and_book(user_id, book_id) -> Review | None`**
   - SELECT with `Review.user_id == user_id`, `Review.book_id == book_id`, `Review.deleted_at.is_(None)`.
   - Returns `scalar_one_or_none()`.

4. **`update(review, rating=None, text=<sentinel>) -> Review`**
   - Accepts a Review object (already fetched). Updates only provided fields.
   - Use a sentinel (e.g., `_UNSET = object()`) for `text` so `None` can be passed to clear text.
   - If `rating` is not None, set `review.rating = rating`.
   - If `text` is not `_UNSET`, set `review.text = text`.
   - `await self.session.flush()` to trigger `onupdate=func.now()` on `updated_at`.
   - `await self.session.refresh(review)` to get updated timestamps.
   - Return review.

5. **`soft_delete(review) -> None`**
   - Sets `review.deleted_at = datetime.now(UTC)` (import `from datetime import UTC`).
   - `await self.session.flush()`.

6. **`list_for_book(book_id, *, page=1, size=20) -> tuple[list[Review], int]`**
   - Filters: `Review.book_id == book_id`, `Review.deleted_at.is_(None)`.
   - Order: `Review.created_at.desc()`, `Review.id.desc()` (stable tiebreaker).
   - Uses `selectinload(Review.user)` for eager-loading reviewer info.
   - Pagination: count query via `select(func.count()).select_from(stmt.subquery())`, then `limit(size).offset((page-1)*size)`.
   - Returns `(list[Review], total_count)`.

7. **`get_aggregates(book_id) -> dict`**
   - `SELECT func.avg(Review.rating), func.count(Review.id) WHERE book_id=X AND deleted_at IS NULL`.
   - Returns `{"avg_rating": float | None, "review_count": int}`.
   - If `avg_rating` is not None, round to 1 decimal: `float(round(row.avg_rating, 1))`.
   - If no reviews, `avg_rating` is `None` and `review_count` is `0`.

Import requirements:
```python
from datetime import UTC, datetime
from sqlalchemy import func, select
from sqlalchemy.exc import IntegrityError
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload
from app.core.exceptions import AppError
from app.reviews.models import Review
```
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && python -c "
from app.reviews.repository import ReviewRepository
import inspect
methods = [m for m in dir(ReviewRepository) if not m.startswith('_')]
expected = ['create', 'get_aggregates', 'get_by_id', 'get_by_user_and_book', 'list_for_book', 'soft_delete', 'update']
for m in expected:
    assert m in methods, f'Missing method: {m}'
    assert inspect.iscoroutinefunction(getattr(ReviewRepository, m)), f'{m} is not async'
print('All 7 methods present and async')
"</automated>
  </verify>
  <done>
    - ReviewRepository has all 7 async methods: create, get_by_id, get_by_user_and_book, update, soft_delete, list_for_book, get_aggregates
    - create() catches IntegrityError and raises AppError(409, "REVIEW_DUPLICATE") for duplicate user/book
    - All get/list methods filter `deleted_at IS NULL` by default
    - list_for_book returns paginated results with total count
    - get_aggregates returns live avg_rating and review_count
  </done>
</task>

</tasks>

<verification>
1. `python -c "from app.reviews.models import Review; print(Review.__table__.constraints)"` — shows UniqueConstraint and CheckConstraint
2. `python -c "from app.db.base import Base; print(list(Base.metadata.tables.keys()))"` — includes "reviews"
3. `python -c "from app.reviews.repository import ReviewRepository; print('OK')"` — imports without error
4. `pytest tests/test_health.py -x -q` — passes (no UndefinedTableError)
5. `python -c "import alembic.versions.a1b2c3d4e5f6_create_reviews as m; print(m.revision, m.down_revision)"` — shows correct chain
</verification>

<success_criteria>
- Review model exists with UniqueConstraint(user_id, book_id) and CheckConstraint(rating 1-5)
- Migration creates reviews table with all columns, FKs, indexes, and constraints
- ReviewRepository provides 7 async methods covering all data access needs for Phase 14
- Model is registered in alembic/env.py so Base.metadata.create_all includes reviews
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/13-review-data-layer/13-01-SUMMARY.md`
</output>
