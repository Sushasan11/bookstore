---
phase: 13-review-data-layer
plan: 02
type: tdd
wave: 2
depends_on:
  - "13-01"
files_modified:
  - app/orders/repository.py
  - tests/test_reviews_data.py
autonomous: true
requirements:
  - VPRC-01

must_haves:
  truths:
    - "OrderRepository.has_user_purchased_book() returns True only for users with a CONFIRMED order containing that book"
    - "has_user_purchased_book() returns False when the order status is PAYMENT_FAILED"
    - "has_user_purchased_book() returns False when the user has no orders at all"
    - "ReviewRepository.create() raises AppError(409) with code REVIEW_DUPLICATE when inserting a duplicate user/book pair"
    - "ReviewRepository.list_for_book() returns paginated results excluding soft-deleted reviews"
    - "ReviewRepository.soft_delete() sets deleted_at and the review is excluded from subsequent queries"
    - "ReviewRepository.get_aggregates() computes live avg_rating and review_count excluding soft-deleted reviews"
  artifacts:
    - path: "app/orders/repository.py"
      provides: "has_user_purchased_book() method on OrderRepository"
      contains: "has_user_purchased_book"
    - path: "tests/test_reviews_data.py"
      provides: "Integration tests for ReviewRepository and OrderRepository purchase check"
      min_lines: 100
  key_links:
    - from: "app/orders/repository.py"
      to: "app/orders/models.py"
      via: "OrderStatus.CONFIRMED filter in purchase check"
      pattern: "Order\\.status == OrderStatus\\.CONFIRMED"
    - from: "tests/test_reviews_data.py"
      to: "app/reviews/repository.py"
      via: "ReviewRepository instantiation and method calls"
      pattern: "ReviewRepository\\(.*session"
    - from: "tests/test_reviews_data.py"
      to: "app/orders/repository.py"
      via: "OrderRepository.has_user_purchased_book() calls"
      pattern: "has_user_purchased_book"
---

<objective>
Add `has_user_purchased_book()` to OrderRepository and create integration tests for both ReviewRepository and the purchase-check method.

Purpose: Verify that the data layer from Plan 13-01 works correctly with a real database — duplicate detection, soft-delete filtering, aggregates, and purchase verification all function as designed.
Output: Extended `app/orders/repository.py` with purchase-check method, `tests/test_reviews_data.py` with comprehensive integration tests.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-review-data-layer/13-RESEARCH.md
@.planning/phases/13-review-data-layer/13-01-SUMMARY.md

<interfaces>
<!-- Key types and contracts from Plan 13-01 output and existing codebase -->

From app/reviews/models.py (created in 13-01):
```python
class Review(Base):
    __tablename__ = "reviews"
    __table_args__ = (
        UniqueConstraint("user_id", "book_id", name="uq_reviews_user_book"),
        CheckConstraint("rating >= 1 AND rating <= 5", name="ck_reviews_rating_range"),
    )
    id: Mapped[int]
    user_id: Mapped[int]  # FK users.id CASCADE
    book_id: Mapped[int]  # FK books.id CASCADE
    rating: Mapped[int]
    text: Mapped[str | None]  # String(2000), nullable
    created_at: Mapped[datetime]
    updated_at: Mapped[datetime]
    deleted_at: Mapped[datetime | None]
    book: Mapped[Book] = relationship()
    user: Mapped[User] = relationship()
```

From app/reviews/repository.py (created in 13-01):
```python
class ReviewRepository:
    def __init__(self, session: AsyncSession) -> None: ...
    async def create(self, user_id: int, book_id: int, rating: int, text: str | None = None) -> Review: ...
    async def get_by_id(self, review_id: int) -> Review | None: ...
    async def get_by_user_and_book(self, user_id: int, book_id: int) -> Review | None: ...
    async def update(self, review: Review, rating: int | None = None, text: ...) -> Review: ...
    async def soft_delete(self, review: Review) -> None: ...
    async def list_for_book(self, book_id: int, *, page: int = 1, size: int = 20) -> tuple[list[Review], int]: ...
    async def get_aggregates(self, book_id: int) -> dict: ...
```

From app/orders/models.py:
```python
class OrderStatus(enum.StrEnum):
    CONFIRMED = "confirmed"
    PAYMENT_FAILED = "payment_failed"

class Order(Base):
    __tablename__ = "orders"
    id: Mapped[int]
    user_id: Mapped[int]  # FK users.id CASCADE
    status: Mapped[OrderStatus]
    created_at: Mapped[datetime]
    items: Mapped[list[OrderItem]] = relationship(...)

class OrderItem(Base):
    __tablename__ = "order_items"
    id: Mapped[int]
    order_id: Mapped[int]  # FK orders.id CASCADE
    book_id: Mapped[int | None]  # FK books.id SET NULL
    quantity: Mapped[int]
    unit_price: Mapped[Decimal]
```

From app/orders/repository.py (existing class to extend):
```python
class OrderRepository:
    def __init__(self, session: AsyncSession) -> None:
        self.session = session
    # Existing methods: lock_books, create_order, get_by_id_for_user, list_for_user, list_all
```

From tests/conftest.py (test infrastructure):
```python
# Fixtures available: test_engine (session-scoped), db_session (function-scoped, rollback), client (httpx AsyncClient)
# Test DB: postgresql+asyncpg://postgres:postgres@127.0.0.1:5433/bookstore_test
# Base.metadata.create_all runs at session start
```

From app/core/security.py:
```python
async def hash_password(password: str) -> str: ...
```

From app/users/repository.py:
```python
class UserRepository:
    async def create(self, email: str, hashed_password: str) -> User: ...
```

From app/books/models.py:
```python
class Book(Base):
    __tablename__ = "books"
    id: Mapped[int]
    title: Mapped[str]
    # ... other fields
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add has_user_purchased_book() to OrderRepository</name>
  <files>
    app/orders/repository.py
  </files>
  <action>
Add an async method `has_user_purchased_book(self, user_id: int, book_id: int) -> bool` to the existing `OrderRepository` class in `app/orders/repository.py`.

Implementation:
```python
async def has_user_purchased_book(self, user_id: int, book_id: int) -> bool:
    """Return True if user has a CONFIRMED order containing this book."""
    from sqlalchemy import exists
    stmt = select(
        exists().where(
            Order.user_id == user_id,
            Order.status == OrderStatus.CONFIRMED,
            OrderItem.order_id == Order.id,
            OrderItem.book_id == book_id,
        )
    )
    result = await self.session.scalar(stmt)
    return bool(result)
```

Key decisions:
- Only `CONFIRMED` orders qualify — `PAYMENT_FAILED` does NOT count as a purchase (per RESEARCH.md Pattern 6 and Pitfall 4).
- Uses `exists()` subquery for efficiency (boolean result, no row fetch).
- `select` is already imported at the top of the file; add `exists` to that import.
- `OrderStatus` is already imported at the top of the file.

Add `exists` to the existing import: change `from sqlalchemy import select` to `from sqlalchemy import exists, select`.
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && python -c "
from app.orders.repository import OrderRepository
import inspect
assert hasattr(OrderRepository, 'has_user_purchased_book'), 'Method missing'
assert inspect.iscoroutinefunction(OrderRepository.has_user_purchased_book), 'Not async'
print('has_user_purchased_book exists and is async')
"</automated>
  </verify>
  <done>
    - `OrderRepository.has_user_purchased_book(user_id, book_id)` method exists
    - Method uses EXISTS subquery filtering by `OrderStatus.CONFIRMED`
    - Returns `bool`
  </done>
</task>

<task type="auto">
  <name>Task 2: Create integration tests for ReviewRepository and purchase check</name>
  <files>
    tests/test_reviews_data.py
  </files>
  <action>
Create `tests/test_reviews_data.py` with integration tests covering:

**Test fixtures** (module-specific email prefixes to avoid collisions, following existing test module patterns):
- `review_user(db_session)` — create a user via `UserRepository` with email `revdata_user@example.com`
- `review_user2(db_session)` — second user `revdata_user2@example.com`
- `sample_book(db_session)` — create a Book directly via ORM (no HTTP needed — this is a data-layer test)
- `sample_book2(db_session)` — second book for multi-book tests

**Test classes and cases:**

### `TestReviewCreate`
1. **test_create_review_success** — create a review with rating=4 and text, verify returned Review has correct fields, user and book relationships loaded
2. **test_create_review_rating_only** — create with text=None (rating-only), verify text is None
3. **test_create_duplicate_raises_409** — create review, then create another for same user+book, assert raises `AppError` with status_code=409 and code="REVIEW_DUPLICATE"

### `TestReviewGet`
4. **test_get_by_id_returns_review** — create review, get_by_id, verify returned
5. **test_get_by_id_returns_none_for_deleted** — create review, soft_delete it, get_by_id returns None
6. **test_get_by_id_returns_none_for_nonexistent** — get_by_id with invalid ID returns None
7. **test_get_by_user_and_book** — create review, get_by_user_and_book returns it
8. **test_get_by_user_and_book_excludes_deleted** — create, soft_delete, get_by_user_and_book returns None

### `TestReviewUpdate`
9. **test_update_rating** — create review with rating=3, update to rating=5, verify changed
10. **test_update_text** — create review with text="original", update text="updated", verify changed
11. **test_update_clears_text_with_none** — create with text, update text=None, verify text is None

### `TestReviewSoftDelete`
12. **test_soft_delete_sets_deleted_at** — create, soft_delete, verify deleted_at is not None

### `TestReviewListForBook`
13. **test_list_for_book_basic** — create 2 reviews for same book (different users), list returns both, total=2
14. **test_list_for_book_excludes_deleted** — create 2 reviews, soft_delete one, list returns 1, total=1
15. **test_list_for_book_pagination** — create 3 reviews, list with size=2 page=1 returns 2 items total=3, page=2 returns 1 item
16. **test_list_for_book_ordered_newest_first** — create 2 reviews, verify first result has later created_at

### `TestReviewAggregates`
17. **test_aggregates_with_reviews** — create reviews with ratings [3, 4, 5], verify avg_rating=4.0, review_count=3
18. **test_aggregates_no_reviews** — get_aggregates for book with no reviews, verify avg_rating=None, review_count=0
19. **test_aggregates_excludes_deleted** — create 2 reviews (rating 3, 5), soft_delete the rating-5 one, verify avg_rating=3.0, review_count=1

### `TestHasUserPurchasedBook`
20. **test_confirmed_order_returns_true** — create user, book, confirmed order with order item for that book, verify returns True
21. **test_payment_failed_returns_false** — create order with status=PAYMENT_FAILED, verify returns False
22. **test_no_orders_returns_false** — user with no orders, verify returns False
23. **test_different_book_returns_false** — confirmed order with book A, check for book B, returns False

For purchase-check tests, create orders directly via ORM (Order + OrderItem models) rather than HTTP since this is a data-layer test:
```python
order = Order(user_id=user.id, status=OrderStatus.CONFIRMED)
db_session.add(order)
await db_session.flush()
order_item = OrderItem(order_id=order.id, book_id=book.id, quantity=1, unit_price=Decimal("19.99"))
db_session.add(order_item)
await db_session.flush()
```

For book creation in fixtures, create directly via ORM:
```python
book = Book(title="Test Book", author="Author", isbn="978-0000000001", price=Decimal("19.99"), stock_quantity=10, description="Test")
db_session.add(book)
await db_session.flush()
```

You may need to import Genre and create a genre if Book requires a genre_id FK. Check the Book model and add a `sample_genre` fixture if needed.

Test file structure:
- Use `pytest_asyncio.fixture` for async fixtures
- Use `db_session` fixture (from conftest.py) for all DB operations
- All tests are async (asyncio_mode = "auto" in pytest config)
- Import `from app.core.exceptions import AppError` and use `pytest.raises(AppError)` for 409 tests
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && pytest tests/test_reviews_data.py -x -q 2>&1 | tail -10</automated>
  </verify>
  <done>
    - All ~23 integration tests pass
    - Purchase check correctly returns True only for CONFIRMED orders
    - Duplicate review raises AppError(409, "REVIEW_DUPLICATE")
    - Soft-deleted reviews are excluded from list, get, and aggregate queries
    - Aggregates compute correct avg_rating and review_count
    - Existing test suite (179+ tests) still passes
  </done>
</task>

</tasks>

<verification>
1. `pytest tests/test_reviews_data.py -x -v` — all tests pass
2. `pytest tests/ -x -q` — full test suite passes (no regressions)
3. `python -c "from app.orders.repository import OrderRepository; print(hasattr(OrderRepository, 'has_user_purchased_book'))"` — True
</verification>

<success_criteria>
- `has_user_purchased_book()` returns True only for CONFIRMED orders with the specified book
- `has_user_purchased_book()` returns False for PAYMENT_FAILED orders, no orders, and wrong book
- ReviewRepository CRUD operations work correctly with real PostgreSQL database
- Duplicate review insertion raises AppError(409) via DB constraint (not app-level check)
- Soft-delete properly excludes reviews from all queries
- Aggregates compute live avg_rating and review_count
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/13-review-data-layer/13-02-SUMMARY.md`
</output>
