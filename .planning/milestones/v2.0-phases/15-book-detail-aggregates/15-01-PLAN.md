---
phase: 15-book-detail-aggregates
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/books/schemas.py
  - app/books/router.py
  - tests/test_book_aggregates.py
autonomous: true
requirements:
  - AGGR-01
  - AGGR-02

must_haves:
  truths:
    - "GET /books/{id} returns avg_rating rounded to 1 decimal place when reviews exist"
    - "GET /books/{id} returns review_count as an integer when reviews exist"
    - "GET /books/{id} returns avg_rating=null and review_count=0 when no reviews exist"
    - "After a review is submitted, the next GET /books/{id} reflects the updated aggregate"
  artifacts:
    - path: "app/books/schemas.py"
      provides: "BookDetailResponse with avg_rating and review_count fields"
      contains: "avg_rating: float | None"
    - path: "app/books/router.py"
      provides: "get_book handler fetching aggregates from ReviewRepository"
      contains: "ReviewRepository"
    - path: "tests/test_book_aggregates.py"
      provides: "Integration tests covering AGGR-01 and AGGR-02 success criteria"
      min_lines: 80
  key_links:
    - from: "app/books/router.py"
      to: "app/reviews/repository.py"
      via: "ReviewRepository(db).get_aggregates(book.id)"
      pattern: "get_aggregates"
    - from: "app/books/router.py"
      to: "app/books/schemas.py"
      via: "BookDetailResponse.model_validate(dict)"
      pattern: "model_validate"
---

<objective>
Add average rating and review count to the book detail response by wiring the existing `ReviewRepository.get_aggregates()` into the `GET /books/{id}` endpoint and extending `BookDetailResponse` with two new fields.

Purpose: Complete the v2.0 Reviews & Ratings milestone — book detail pages now surface aggregate review data so users can see how a book is rated at a glance.

Output: Modified `BookDetailResponse` schema, updated `get_book` router handler, and integration test file covering all three Phase 15 success criteria.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->
<!-- Executor should use these directly — no codebase exploration needed. -->

From app/reviews/repository.py (lines 141-163) — already implemented, DO NOT modify:
```python
class ReviewRepository:
    def __init__(self, session: AsyncSession) -> None:
        self.session = session

    async def get_aggregates(self, book_id: int) -> dict:
        """Return avg_rating and review_count for a book.
        avg_rating is rounded to 1 decimal place, or None if no reviews.
        review_count is 0 if no reviews.
        """
        # Returns: {"avg_rating": float | None, "review_count": int}
```

From app/books/schemas.py (lines 106-130) — current state to be modified:
```python
class BookDetailResponse(BaseModel):
    id: int
    title: str
    author: str
    price: Decimal
    isbn: str | None
    genre_id: int | None
    description: str | None
    cover_image_url: str | None
    publish_date: date | None
    stock_quantity: int

    @computed_field
    @property
    def in_stock(self) -> bool:
        return self.stock_quantity > 0

    model_config = {"from_attributes": True}
```

From app/books/router.py (lines 84-93) — current state to be modified:
```python
@router.get("/books/{book_id}", response_model=BookDetailResponse)
async def get_book(book_id: int, db: DbSession) -> BookDetailResponse:
    service = _make_service(db)
    book = await service._get_book_or_404(book_id)
    return BookDetailResponse.model_validate(book)
```

From tests/test_reviews.py — fixture pattern for user + purchased book:
```python
@pytest_asyncio.fixture
async def rev_user(db_session: AsyncSession) -> User:
    repo = UserRepository(db_session)
    hashed = await hash_password("userpass123")
    user = await repo.create(email="rev_user@example.com", hashed_password=hashed)
    await db_session.flush()
    return user

@pytest_asyncio.fixture
async def purchased_book(db_session, rev_user, sample_book) -> Book:
    order = Order(user_id=rev_user.id, status=OrderStatus.CONFIRMED)
    db_session.add(order)
    await db_session.flush()
    item = OrderItem(order_id=order.id, book_id=sample_book.id, quantity=1, unit_price=sample_book.price)
    db_session.add(item)
    await db_session.flush()
    return sample_book
```

From conftest.py — shared fixtures:
```python
# client: AsyncClient against test app
# db_session: function-scoped with rollback
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend BookDetailResponse schema and rewire get_book handler</name>
  <files>app/books/schemas.py, app/books/router.py</files>
  <action>
**app/books/schemas.py** — Add two fields to `BookDetailResponse` BEFORE the `@computed_field` decorator:

```python
avg_rating: float | None = None   # None when no reviews exist
review_count: int = 0             # 0 when no reviews exist
```

Default values (`None` and `0`) are required so that `model_validate` does not fail if these fields are missing (defensive). The defaults match the no-reviews case.

Keep `model_config = {"from_attributes": True}` and `in_stock` computed field unchanged.

**app/books/router.py** — Two changes:

1. Add import at top of file (after existing imports):
```python
from app.reviews.repository import ReviewRepository
```
This is safe — no circular import because `app/reviews/repository.py` only imports from `app/reviews/models.py` and `app/core/exceptions.py`.

2. Rewrite the `get_book` handler to construct `BookDetailResponse` from a dict (not ORM object directly), merging book attributes with aggregate data:

```python
@router.get("/books/{book_id}", response_model=BookDetailResponse)
async def get_book(book_id: int, db: DbSession) -> BookDetailResponse:
    """Get book by ID including stock status and rating aggregates. Public."""
    service = _make_service(db)
    book = await service._get_book_or_404(book_id)
    review_repo = ReviewRepository(db)
    aggregates = await review_repo.get_aggregates(book.id)
    return BookDetailResponse.model_validate({
        "id": book.id,
        "title": book.title,
        "author": book.author,
        "price": book.price,
        "isbn": book.isbn,
        "genre_id": book.genre_id,
        "description": book.description,
        "cover_image_url": book.cover_image_url,
        "publish_date": book.publish_date,
        "stock_quantity": book.stock_quantity,
        **aggregates,
    })
```

This dict-based construction is the established project pattern (see `ReviewService._build_review_data()`). It avoids `ValidationError` because `avg_rating` and `review_count` are NOT ORM attributes on the `Book` model.

**DO NOT** modify `ReviewRepository.get_aggregates()` — it is already correct.
**DO NOT** add aggregate fields to `BookResponse` (list endpoint) — AGGR-01/AGGR-02 only apply to `GET /books/{id}`.
**DO NOT** compute aggregates in `BookService` — direct `ReviewRepository` instantiation in the router is the cross-domain access pattern used in this project.
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && python -m pytest tests/test_catalog.py -x -q 2>&1</automated>
  </verify>
  <done>
BookDetailResponse has avg_rating (float|None) and review_count (int) fields. The get_book handler fetches aggregates from ReviewRepository and constructs the response via dict-based model_validate. All 234 existing tests still pass (especially test_catalog.py which calls GET /books/{id}).
  </done>
</task>

<task type="auto">
  <name>Task 2: Write integration tests for book detail aggregates</name>
  <files>tests/test_book_aggregates.py</files>
  <action>
Create `tests/test_book_aggregates.py` covering all three Phase 15 success criteria. Use unique email prefixes (`agg_`) to avoid collisions with other test files.

**File structure:**

```python
"""Integration tests for book detail aggregate fields (Phase 15).

Tests cover AGGR-01 (avg_rating) and AGGR-02 (review_count) on GET /books/{id}.
Three success criteria:
  1. avg_rating rounded to 1 decimal, review_count as integer (with reviews)
  2. avg_rating=null, review_count=0 (no reviews)
  3. Post-review-submit reflects updated aggregate immediately
"""

from decimal import Decimal

import pytest_asyncio
from httpx import AsyncClient
from sqlalchemy.ext.asyncio import AsyncSession

from app.books.models import Book
from app.core.security import hash_password
from app.orders.models import Order, OrderItem, OrderStatus
from app.users.models import User
from app.users.repository import UserRepository
```

**Fixtures** (local to this file, using `agg_` prefix):

1. `agg_user(db_session)` — Create user `agg_user@example.com` via UserRepository, return User ORM object.

2. `agg_user2(db_session)` — Create user `agg_user2@example.com`, return User ORM object. Needed for multi-review avg test.

3. `agg_user_headers(client, agg_user)` — Login via `POST /auth/login` and return `{"Authorization": "Bearer {token}"}`.

4. `agg_user2_headers(client, agg_user2)` — Login user2 and return headers.

5. `agg_book(db_session)` — Create `Book(title="Aggregate Test Book", author="Agg Author", price=Decimal("14.99"), stock_quantity=5)` via ORM, flush, return Book.

6. `agg_purchased_book(db_session, agg_user, agg_book)` — Create CONFIRMED order for agg_user containing agg_book, return agg_book. Same pattern as test_reviews.py `purchased_book`.

7. `agg_purchased_book_user2(db_session, agg_user2, agg_book)` — Create CONFIRMED order for agg_user2 containing agg_book, return agg_book.

**Test class: `TestBookDetailAggregates`**

Test 1: `test_no_reviews_returns_null_avg_and_zero_count(self, client, agg_book)`
- `GET /books/{agg_book.id}` → 200
- Assert `data["avg_rating"] is None`
- Assert `data["review_count"] == 0`
- Assert `data["in_stock"] is True` (existing field still works)

Test 2: `test_single_review_returns_exact_rating(self, client, agg_user_headers, agg_purchased_book)`
- POST review: `POST /books/{book_id}/reviews` with `{"rating": 4, "text": "Good book"}` using agg_user_headers → 201
- `GET /books/{book_id}` → 200
- Assert `data["avg_rating"] == 4.0`
- Assert `data["review_count"] == 1`

Test 3: `test_multiple_reviews_returns_rounded_avg(self, client, agg_user_headers, agg_user2_headers, agg_purchased_book, agg_purchased_book_user2)`
- POST review from user1: rating=4
- POST review from user2: rating=5
- `GET /books/{book_id}` → 200
- Assert `data["avg_rating"] == 4.5`
- Assert `data["review_count"] == 2`

Test 4: `test_after_review_submitted_aggregate_reflects_change(self, client, agg_user_headers, agg_purchased_book)`
- `GET /books/{book_id}` → assert `avg_rating is None`, `review_count == 0`
- POST review with rating=3 → 201
- `GET /books/{book_id}` → assert `avg_rating == 3.0`, `review_count == 1`

Test 5: `test_avg_rating_rounds_to_one_decimal(self, client, agg_user_headers, agg_user2_headers, agg_purchased_book, agg_purchased_book_user2)`
- POST review from user1: rating=3
- POST review from user2: rating=5
- `GET /books/{book_id}` → 200
- Assert `data["avg_rating"] == 4.0` (average of 3 and 5 is 4.0, rounds to 1 decimal)

Test 6: `test_deleted_review_excluded_from_aggregate(self, client, agg_user_headers, agg_user2_headers, agg_purchased_book, agg_purchased_book_user2)`
- POST review from user1: rating=2 → save review_id
- POST review from user2: rating=4
- `GET /books/{book_id}` → assert `avg_rating == 3.0`, `review_count == 2`
- DELETE user1's review: `DELETE /reviews/{review_id}` with agg_user_headers → 204
- `GET /books/{book_id}` → assert `avg_rating == 4.0`, `review_count == 1`

Each test is fully self-contained using local fixtures. No shared state between tests.
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && python -m pytest tests/test_book_aggregates.py -x -v 2>&1</automated>
  </verify>
  <done>
All 6 integration tests pass: no-reviews case returns null/0, single review returns exact rating, multiple reviews return rounded average, post-submit reflects updated aggregate, rounding to 1 decimal verified, and soft-deleted reviews are excluded from aggregates.
  </done>
</task>

</tasks>

<verification>
1. `pytest tests/test_book_aggregates.py -x -v` — all 6 aggregate tests pass
2. `pytest tests/test_catalog.py -x -v` — existing catalog tests still pass (no regressions)
3. `pytest tests/ -x -q` — full suite green (234 existing + 6 new = 240 tests)
4. `GET /books/{id}` response includes `avg_rating`, `review_count`, and `in_stock` fields
</verification>

<success_criteria>
- GET /books/{id} returns avg_rating rounded to 1 decimal place (e.g., 4.3) and review_count as integer
- When no reviews exist, avg_rating is null and review_count is 0 — endpoint does not error
- After a review is submitted, next GET /books/{id} call reflects updated aggregate without cache invalidation
- All 234 existing tests remain green
- 6 new integration tests pass covering AGGR-01 and AGGR-02
</success_criteria>

<output>
After completion, create `.planning/phases/15-book-detail-aggregates/15-01-SUMMARY.md`
</output>
