---
phase: 14-review-crud-endpoints
plan: 02
type: execute
wave: 2
depends_on:
  - 14-01
files_modified:
  - app/reviews/service.py
  - app/reviews/router.py
  - tests/test_reviews.py
autonomous: true
requirements:
  - REVW-03
  - REVW-04
  - ADMR-01
  - REVW-01
  - REVW-02
  - VPRC-02

must_haves:
  truths:
    - "A user can PATCH /reviews/{review_id} to update rating and/or text on their own review, and the changes are reflected in subsequent GET"
    - "A user receives 403 NOT_REVIEW_OWNER when trying to update or delete another user's review"
    - "A user can DELETE /reviews/{review_id} to soft-delete their own review"
    - "An admin can DELETE /reviews/{review_id} for any review regardless of ownership"
    - "After deletion, the review no longer appears in GET /books/{book_id}/reviews"
    - "All 6 requirement scenarios (REVW-01 through REVW-04, VPRC-02, ADMR-01) are covered by automated integration tests"
    - "All existing tests (~179+) continue to pass with no regressions"
  artifacts:
    - path: "tests/test_reviews.py"
      provides: "Full HTTP integration test suite for all review CRUD endpoints"
      contains: "TestCreateReview, TestListReviews, TestUpdateReview, TestDeleteReview, TestAdminModeration"
    - path: "app/reviews/service.py"
      provides: "update() and delete() methods with ownership enforcement"
      contains: "async def update, async def delete"
    - path: "app/reviews/router.py"
      provides: "PATCH and DELETE endpoints"
      contains: "PATCH, DELETE"
  key_links:
    - from: "app/reviews/router.py"
      to: "app/reviews/service.py"
      via: "update() and delete() calls from PATCH and DELETE routes"
      pattern: "service\\.update|service\\.delete"
    - from: "app/reviews/service.py"
      to: "app/reviews/repository.py"
      via: "repo.update() and repo.soft_delete() calls"
      pattern: "review_repo\\.update|review_repo\\.soft_delete"
    - from: "tests/test_reviews.py"
      to: "app/main.py"
      via: "AsyncClient against ASGI app"
      pattern: "AsyncClient.*app"
---

<objective>
Add update and delete review endpoints with ownership enforcement and admin moderation, then create comprehensive integration tests covering all review CRUD operations.

Purpose: Completes the review HTTP surface and validates all 6 requirements (REVW-01 through REVW-04, VPRC-02, ADMR-01) with automated tests.
Output: Working PATCH /reviews/{review_id} and DELETE /reviews/{review_id} endpoints, plus ~25-35 integration tests covering all scenarios.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-review-crud-endpoints/14-RESEARCH.md
@.planning/phases/14-review-crud-endpoints/14-01-SUMMARY.md

Key source files (created in Plan 14-01):
@app/reviews/schemas.py
@app/reviews/service.py
@app/reviews/router.py
@app/core/exceptions.py
@app/main.py

Pattern references:
@tests/test_reviews_data.py (existing data layer tests — use different email prefixes!)
@tests/test_wishlist.py (HTTP test pattern reference)
@tests/conftest.py (fixtures: client, db_session, async patterns)

<interfaces>
<!-- Key types and contracts from Plan 14-01 output that this plan depends on -->

From app/reviews/service.py (created in 14-01):
```python
class ReviewService:
    def __init__(self, review_repo, order_repo, book_repo)
    async def create(self, user_id, book_id, rating, text) -> tuple[Review, bool]
    async def get(self, review_id) -> tuple[Review, bool]
    async def list_for_book(self, book_id, page, size) -> tuple[list[tuple[Review, bool]], int]
    def _build_review_data(self, review, verified_purchase) -> dict
    # To be added in this plan:
    # async def update(self, review_id, user_id, rating, text) -> tuple[Review, bool]
    # async def delete(self, review_id, user_id, is_admin) -> None
```

From app/reviews/schemas.py (created in 14-01):
```python
class ReviewCreate(BaseModel):
    rating: int = Field(ge=1, le=5)
    text: str | None = Field(None, max_length=2000)

class ReviewUpdate(BaseModel):
    rating: int | None = Field(None, ge=1, le=5)
    text: str | None = Field(None, max_length=2000)

class ReviewResponse(BaseModel):
    id: int; book_id: int; user_id: int; rating: int; text: str | None
    verified_purchase: bool; created_at: datetime; updated_at: datetime
    author: ReviewAuthorSummary; book: ReviewBookSummary

class ReviewListResponse(BaseModel):
    items: list[ReviewResponse]; total: int; page: int; size: int
```

From app/reviews/router.py (created in 14-01):
```python
router = APIRouter(tags=["reviews"])
def _make_service(db) -> ReviewService
# Existing: POST /books/{book_id}/reviews, GET /books/{book_id}/reviews, GET /reviews/{review_id}
# To be added: PATCH /reviews/{review_id}, DELETE /reviews/{review_id}
```

From app/reviews/repository.py (Phase 13):
```python
_UNSET = object()  # sentinel for text field
async def update(self, review, rating=None, text=_UNSET) -> Review
async def soft_delete(self, review) -> None
```

From app/core/deps.py:
```python
ActiveUser = Annotated[dict, Depends(get_active_user)]  # {"sub": "123", "role": "user"|"admin"}
AdminUser = Annotated[dict, Depends(require_admin)]
```

From app/core/exceptions.py:
```python
class AppError(Exception):
    def __init__(self, status_code, detail, code, field=None)
class DuplicateReviewError(Exception):
    def __init__(self, existing_review_id)
```

From tests/conftest.py:
```python
# Fixtures available: client (httpx.AsyncClient), db_session (AsyncSession with rollback)
# asyncio_mode = "auto" — no @pytest.mark.asyncio needed
```

From app/users/repository.py (for test fixtures):
```python
class UserRepository:
    async def create(self, email, hashed_password) -> User
    async def set_role_admin(self, user_id) -> User
```

From app/core/security.py (for test fixtures):
```python
async def hash_password(password: str) -> str
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add update and delete methods to ReviewService and router endpoints</name>
  <files>
    app/reviews/service.py
    app/reviews/router.py
  </files>
  <action>
**1. Add update() and delete() methods to ReviewService in app/reviews/service.py**

Add two methods to the existing ReviewService class:

**`async def update(self, review_id: int, user_id: int, rating: int | None, text: object) -> tuple[Review, bool]`:**
1. Fetch review via `self.review_repo.get_by_id(review_id)`. If None, raise `AppError(404, "Review not found", "REVIEW_NOT_FOUND")`.
2. Ownership check: if `review.user_id != user_id`, raise `AppError(403, "You can only modify your own reviews", "NOT_REVIEW_OWNER")`.
3. Call `self.review_repo.update(review, rating=rating, text=text)`. Pass through the `_UNSET` sentinel for text — import `_UNSET` from `app.reviews.repository` and use it as the default parameter for `text` in the method signature: `text: object = _UNSET` where `_UNSET` is imported from the repository module.
4. Compute `vp = await self.order_repo.has_user_purchased_book(review.user_id, review.book_id)`.
5. Need to re-load relationships after update: the `review_repo.update()` does `refresh(review)` but does NOT eager-load relationships. After update, call `review = await self.review_repo.get_by_id(review.id)` to get the review with eager-loaded user and book.
6. Return `(review, vp)`.

**`async def delete(self, review_id: int, user_id: int, is_admin: bool = False) -> None`:**
1. Fetch review via `self.review_repo.get_by_id(review_id)`. If None, raise `AppError(404, "Review not found", "REVIEW_NOT_FOUND")`.
2. Ownership check: if NOT `is_admin` AND `review.user_id != user_id`, raise `AppError(403, "You can only delete your own reviews", "NOT_REVIEW_OWNER")`.
3. Call `self.review_repo.soft_delete(review)`. Soft-delete is the correct pattern — consistent with the `deleted_at` column on the model.

**2. Add PATCH and DELETE endpoints to app/reviews/router.py**

Add these endpoints to the existing router:

**PATCH /reviews/{review_id}** — update own review:
```python
@router.patch("/reviews/{review_id}", response_model=ReviewResponse)
async def update_review(
    review_id: int,
    body: ReviewUpdate,
    db: DbSession,
    current_user: ActiveUser,
) -> ReviewResponse:
    user_id = int(current_user["sub"])
    service = _make_service(db)
    review, vp = await service.update(review_id, user_id, body.rating, body.text)
    return ReviewResponse.model_validate(service._build_review_data(review, vp))
```

Import `ReviewUpdate` in the router imports.

IMPORTANT: The `body.text` from `ReviewUpdate` will be `None` if the user didn't provide it (Pydantic default). But we need to distinguish "user didn't send text" from "user sent text=null". The `_UNSET` sentinel pattern handles this at the repository level. However, Pydantic's `ReviewUpdate` model will set `text=None` by default if not provided in the request body.

To properly handle this, use `body.model_fields_set` to check what was actually sent:
```python
from app.reviews.repository import _UNSET

text = body.text if "text" in body.model_fields_set else _UNSET
review, vp = await service.update(review_id, user_id, body.rating, text)
```

This ensures that if the user omits `text` from the PATCH body, it's not updated. If they explicitly send `"text": null`, it clears the text.

**DELETE /reviews/{review_id}** — delete own review (or admin):
```python
@router.delete("/reviews/{review_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_review(
    review_id: int,
    db: DbSession,
    current_user: ActiveUser,
) -> None:
    user_id = int(current_user["sub"])
    is_admin = current_user.get("role") == "admin"
    service = _make_service(db)
    await service.delete(review_id, user_id, is_admin=is_admin)
```

This single endpoint serves both user delete (REVW-04) and admin delete (ADMR-01). The `ActiveUser` dep ensures the user is authenticated and active. The service checks ownership, with admins bypassing the ownership check via `is_admin=True`.

No separate admin endpoint needed — the admin uses the same path and the service logic handles the permission correctly.
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && python -c "from app.main import app; paths = [r.path for r in app.routes]; assert '/reviews/{review_id}' in paths, f'Missing route. Routes: {paths}'; print('PATCH and DELETE routes registered OK')"</automated>
  </verify>
  <done>
    - ReviewService.update() enforces ownership (403 NOT_REVIEW_OWNER) and delegates to repo.update()
    - ReviewService.delete() enforces ownership unless is_admin=True, then calls repo.soft_delete()
    - PATCH /reviews/{review_id} endpoint exists, requires ActiveUser, uses model_fields_set to distinguish omitted vs null text
    - DELETE /reviews/{review_id} endpoint exists, requires ActiveUser, passes is_admin flag to service
    - Single delete endpoint serves both user and admin deletion paths
  </done>
</task>

<task type="auto">
  <name>Task 2: Create comprehensive integration tests for all review CRUD endpoints</name>
  <files>
    tests/test_reviews.py
  </files>
  <action>
Create `tests/test_reviews.py` with full HTTP integration tests covering all 6 requirements.

**CRITICAL:** Use unique email prefixes to avoid collisions with `tests/test_reviews_data.py` (which uses `revdata_user@`, `revdata_user2@`, `revdata_admin@`). Use `rev_` prefix: `rev_admin@example.com`, `rev_user@example.com`, `rev_user2@example.com`.

**Test infrastructure (fixtures):**

```python
import pytest_asyncio
from httpx import AsyncClient
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.security import hash_password
from app.users.repository import UserRepository
from app.books.repository import BookRepository
from app.orders.models import Order, OrderItem, OrderStatus
```

Fixtures needed (all function-scoped to match db_session):

- `admin_headers(client, db_session)` — create admin user `rev_admin@example.com`, login, return `{"Authorization": "Bearer <token>"}`. Use `repo.set_role_admin(user.id)` after `repo.create()`. Use `await db_session.flush()` after role change.

- `user_headers(client, db_session)` — create normal user `rev_user@example.com`, login, return headers.

- `user2_headers(client, db_session)` — create second user `rev_user2@example.com`, login, return headers. Used for ownership violation tests.

- `sample_book(db_session)` — create a book via `BookRepository(db_session).create(title="Review Test Book", author="Test Author", price=Decimal("19.99"))`. Return the book.

- `purchased_book(db_session, sample_book, user_headers)` — create a CONFIRMED order for the rev_user containing sample_book. This requires: creating an Order(user_id=user_id, status=OrderStatus.CONFIRMED), creating an OrderItem(order_id, book_id, quantity, price_at_time), flushing. Extract user_id from the rev_user user that was created in user_headers fixture. NOTE: The user_id extraction is tricky because user_headers only returns headers. Solution: create a separate `test_user(db_session)` fixture that returns the User object, and have `user_headers` depend on it. Or query the user from the DB. Simplest: create the user in a dedicated fixture `rev_user(db_session)` that returns User, and `user_headers(client, rev_user)` that logs in with that user. Same for `rev_user2` and `rev_admin`.

Restructured fixtures:
- `rev_user(db_session)` — create user, return User ORM object
- `rev_user2(db_session)` — create second user, return User
- `rev_admin(db_session)` — create admin user, return User
- `user_headers(client, rev_user)` — login, return auth headers
- `user2_headers(client, rev_user2)` — login, return auth headers
- `admin_headers(client, rev_admin)` — login, return auth headers
- `sample_book(db_session)` — create book, return Book
- `purchased_book(db_session, rev_user, sample_book)` — create confirmed order for rev_user containing sample_book, return Book (same object as sample_book but now user has purchased it)

**Test classes and cases:**

**class TestCreateReview:**
- `test_create_review_success` — POST with valid rating+text, assert 201, response has all fields including verified_purchase=True, author summary, book summary, timestamps in ISO 8601
- `test_create_review_rating_only` — POST with rating only (no text), assert 201, text is null
- `test_create_review_403_not_purchased` — POST without purchase, assert 403, code=NOT_PURCHASED
- `test_create_review_409_duplicate` — POST twice for same book, second returns 409 with code=DUPLICATE_REVIEW and existing_review_id matching first review's ID
- `test_create_review_404_book_not_found` — POST with nonexistent book_id, assert 404
- `test_create_review_422_rating_out_of_range` — POST with rating=0 or rating=6, assert 422
- `test_create_review_422_text_too_long` — POST with text > 2000 chars, assert 422
- `test_create_review_401_unauthenticated` — POST without auth headers, assert 401

**class TestListReviews:**
- `test_list_reviews_returns_paginated` — create 2 reviews (from 2 different users who both purchased), GET /books/{id}/reviews, assert items, total=2, page=1, size=20
- `test_list_reviews_empty_book` — GET for book with no reviews, assert items=[], total=0
- `test_list_reviews_public_no_auth` — GET without auth headers succeeds (200)
- `test_list_reviews_verified_purchase_flag` — one reviewer purchased (verified_purchase=True), another hasn't (they submit review after purchasing a different flow... actually: if the purchase gate prevents non-purchasers from creating reviews, then ALL reviews in the list will have verified_purchase=True because you must purchase to create. HOWEVER, if a user's order is later changed or if the order system changes, the flag could be False. For testing: create a review for a user who purchased, assert verified_purchase=True. This is the realistic scenario.
- `test_list_reviews_pagination` — create enough reviews and test page=2 returns correct subset

Note on verified_purchase in list: Since the purchase gate prevents non-purchasers from creating reviews, in practice all reviews will have verified_purchase=True. However, the flag is computed live from the orders table, so if the test setup creates an order and then somehow the order is removed/changed, it would be False. For testing purposes, simply assert that reviews from purchasers show verified_purchase=True.

**class TestGetReview:**
- `test_get_review_success` — GET /reviews/{id}, assert 200 with full response including verified_purchase
- `test_get_review_404_not_found` — GET /reviews/99999, assert 404

**class TestUpdateReview:**
- `test_update_rating_only` — PATCH with new rating, assert 200, rating changed, text unchanged
- `test_update_text_only` — PATCH with new text, assert 200, text changed, rating unchanged
- `test_update_both` — PATCH with rating and text, assert 200, both changed
- `test_update_clear_text` — PATCH with text=null, assert 200, text is null (rating-only review)
- `test_update_403_not_owner` — user2 tries to PATCH user1's review, assert 403 NOT_REVIEW_OWNER
- `test_update_404_not_found` — PATCH nonexistent review, assert 404
- `test_update_401_unauthenticated` — PATCH without auth, assert 401

**class TestDeleteReview:**
- `test_delete_own_review` — DELETE own review, assert 204, then GET returns 404 (soft-deleted)
- `test_delete_403_not_owner` — user2 tries to DELETE user1's review, assert 403 NOT_REVIEW_OWNER
- `test_delete_404_not_found` — DELETE nonexistent review, assert 404
- `test_delete_401_unauthenticated` — DELETE without auth, assert 401

**class TestAdminModeration:**
- `test_admin_delete_any_review` — admin DELETEs another user's review, assert 204
- `test_admin_delete_then_list_excludes` — after admin delete, GET /books/{id}/reviews excludes the deleted review (total decremented)

**Key patterns:**
- All tests use `client` fixture (httpx.AsyncClient) for HTTP calls
- Use `db_session` for direct DB setup (creating orders for purchase fixtures)
- Assert response JSON structure matches ReviewResponse schema
- Assert correct HTTP status codes
- Use `await db_session.flush()` after DB setup (NOT commit — conftest handles transactions)
- Verify timestamps are present and non-null (don't assert exact values)

**Estimated count: ~25-30 tests**

After writing all tests, run:
```
pytest tests/test_reviews.py -x -v
```

If any test fails, fix the test or the underlying code until all pass.

Then run the full test suite:
```
pytest tests/ -x
```

All 179+ existing tests must continue to pass.
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && python -m pytest tests/test_reviews.py -x -v 2>&1 | tail -30</automated>
  </verify>
  <done>
    - tests/test_reviews.py exists with 25+ integration tests
    - TestCreateReview covers: success 201, rating-only, 403 NOT_PURCHASED, 409 DUPLICATE_REVIEW with existing_review_id, 404 book not found, 422 validation errors, 401 unauthenticated
    - TestListReviews covers: paginated response, empty book, public access, verified_purchase flag
    - TestGetReview covers: success 200, 404 not found
    - TestUpdateReview covers: rating-only update, text-only update, both, clear text, 403 not owner, 404, 401
    - TestDeleteReview covers: own review 204, 403 not owner, 404, 401
    - TestAdminModeration covers: admin delete any review, deleted review excluded from list
    - All new tests pass: `pytest tests/test_reviews.py -x` exits 0
    - Full suite passes: `pytest tests/ -x` exits 0 with 200+ tests (179 existing + ~25-30 new)
    - Unique email prefixes (rev_) avoid collisions with test_reviews_data.py
  </done>
</task>

</tasks>

<verification>
1. `pytest tests/test_reviews.py -x -v` — all review HTTP tests pass
2. `pytest tests/ -x` — full suite passes (no regressions)
3. `pytest tests/test_reviews.py -k "not_purchased" -x` — 403 for non-purchaser
4. `pytest tests/test_reviews.py -k "duplicate" -x` — 409 with existing_review_id
5. `pytest tests/test_reviews.py -k "not_owner" -x` — 403 for ownership violations
6. `pytest tests/test_reviews.py -k "admin" -x` — admin can delete any review
7. `pytest tests/test_reviews.py -k "verified_purchase" -x` — verified_purchase flag present
</verification>

<success_criteria>
- PATCH /reviews/{review_id} updates own review, returns updated review with verified_purchase
- DELETE /reviews/{review_id} soft-deletes own review, returns 204
- Admin can delete any review via the same DELETE endpoint
- Ownership violations return 403 NOT_REVIEW_OWNER (not 404)
- All 6 requirements (REVW-01 through REVW-04, VPRC-02, ADMR-01) have passing integration tests
- Full test suite passes with 0 failures
- Soft-deleted reviews excluded from GET list and GET single
</success_criteria>

<output>
After completion, create `.planning/phases/14-review-crud-endpoints/14-02-SUMMARY.md`
</output>
