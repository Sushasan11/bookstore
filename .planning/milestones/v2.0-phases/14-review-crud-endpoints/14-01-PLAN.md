---
phase: 14-review-crud-endpoints
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/reviews/schemas.py
  - app/reviews/service.py
  - app/reviews/router.py
  - app/core/exceptions.py
  - app/main.py
autonomous: true
requirements:
  - REVW-01
  - REVW-02
  - VPRC-02

must_haves:
  truths:
    - "A user with a confirmed purchase can POST /books/{book_id}/reviews and receive 201 with the review including verified_purchase=true"
    - "A user without a purchase receives 403 NOT_PURCHASED when trying to create a review"
    - "Submitting a duplicate review returns 409 DUPLICATE_REVIEW with existing_review_id in the body"
    - "GET /books/{book_id}/reviews returns a paginated list with items, total, page, size and each review has a verified_purchase flag"
    - "Each review response includes author summary (user_id, display_name, avatar_url) and book summary (book_id, title, cover_image_url)"
  artifacts:
    - path: "app/reviews/schemas.py"
      provides: "Pydantic request/response schemas for reviews"
      contains: "ReviewCreate, ReviewUpdate, ReviewResponse, ReviewListResponse, ReviewAuthorSummary, ReviewBookSummary"
    - path: "app/reviews/service.py"
      provides: "ReviewService with business rules — purchase gate, duplicate detection, verified_purchase computation"
      contains: "class ReviewService"
    - path: "app/reviews/router.py"
      provides: "HTTP endpoints for create and list reviews"
      contains: "router = APIRouter"
    - path: "app/core/exceptions.py"
      provides: "DuplicateReviewError for enriched 409 body with existing_review_id"
      contains: "class DuplicateReviewError"
  key_links:
    - from: "app/reviews/router.py"
      to: "app/reviews/service.py"
      via: "_make_service(db) factory"
      pattern: "_make_service"
    - from: "app/reviews/service.py"
      to: "app/orders/repository.py"
      via: "has_user_purchased_book() for purchase gate and verified_purchase computation"
      pattern: "has_user_purchased_book"
    - from: "app/main.py"
      to: "app/reviews/router.py"
      via: "include_router registration"
      pattern: "include_router.*reviews"
    - from: "app/main.py"
      to: "app/core/exceptions.py"
      via: "DuplicateReviewError handler registration"
      pattern: "DuplicateReviewError"
---

<objective>
Create ReviewService, Pydantic schemas, and router for the create and list review endpoints, with verified-purchase enforcement and the DuplicateReviewError exception.

Purpose: Establishes the full review HTTP surface for creating and listing reviews — the foundation that edit/delete/admin endpoints (Plan 14-02) build on.
Output: Working POST /books/{book_id}/reviews and GET /books/{book_id}/reviews endpoints with all business rules enforced.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-review-crud-endpoints/14-RESEARCH.md

Key source files:
@app/reviews/models.py
@app/reviews/repository.py
@app/core/exceptions.py
@app/core/deps.py
@app/main.py
@app/wishlist/router.py (pattern reference)
@app/wishlist/service.py (pattern reference)
@app/wishlist/schemas.py (pattern reference)
@app/books/schemas.py (BookListResponse pagination pattern reference)

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From app/reviews/models.py:
```python
class Review(Base):
    __tablename__ = "reviews"
    id: Mapped[int]
    user_id: Mapped[int]  # FK -> users.id CASCADE
    book_id: Mapped[int]  # FK -> books.id CASCADE
    rating: Mapped[int]  # CHECK 1-5
    text: Mapped[str | None]  # String(2000)
    created_at: Mapped[datetime]
    updated_at: Mapped[datetime]
    deleted_at: Mapped[datetime | None]  # soft-delete
    book: Mapped[Book] = relationship()
    user: Mapped[User] = relationship()
```

From app/reviews/repository.py:
```python
class ReviewRepository:
    async def create(self, user_id, book_id, rating, text=None) -> Review  # raises AppError(409) REVIEW_DUPLICATE
    async def get_by_id(self, review_id) -> Review | None  # excludes soft-deleted, eager-loads book+user
    async def get_by_user_and_book(self, user_id, book_id) -> Review | None  # excludes soft-deleted
    async def update(self, review, rating=None, text=_UNSET) -> Review  # _UNSET sentinel for text
    async def soft_delete(self, review) -> None
    async def list_for_book(self, book_id, *, page=1, size=20) -> tuple[list[Review], int]  # eager-loads user
    async def get_aggregates(self, book_id) -> dict  # {"avg_rating": float|None, "review_count": int}
```

From app/orders/repository.py:
```python
class OrderRepository:
    async def has_user_purchased_book(self, user_id: int, book_id: int) -> bool
```

From app/books/repository.py:
```python
class BookRepository:
    async def get_by_id(self, book_id: int) -> Book | None
```

From app/core/deps.py:
```python
DbSession = Annotated[AsyncSession, Depends(get_db)]
ActiveUser = Annotated[dict, Depends(get_active_user)]  # dict with "sub" (user ID str) and "role"
AdminUser = Annotated[dict, Depends(require_admin)]
```

From app/core/exceptions.py:
```python
class AppError(Exception):
    def __init__(self, status_code: int, detail: str, code: str, field: str | None = None)
```

From app/users/models.py:
```python
class User(Base):
    id: Mapped[int]
    email: Mapped[str]
    role: Mapped[UserRole]  # UserRole.USER or UserRole.ADMIN
    is_active: Mapped[bool]
    # NOTE: No display_name or avatar_url columns exist
```

From app/books/models.py:
```python
class Book(Base):
    id: Mapped[int]
    title: Mapped[str]
    cover_image_url: Mapped[str | None]
```

From app/main.py (exception handler pattern):
```python
application.add_exception_handler(AppError, app_error_handler)
```

From app/books/schemas.py (pagination envelope pattern):
```python
class BookListResponse(BaseModel):
    items: list[BookResponse]
    total: int
    page: int
    size: int
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DuplicateReviewError, Pydantic schemas, and ReviewService</name>
  <files>
    app/core/exceptions.py
    app/reviews/schemas.py
    app/reviews/service.py
  </files>
  <action>
**1. Add DuplicateReviewError to app/core/exceptions.py**

Add a new exception class and its handler AFTER the existing `AppError` class:

```python
class DuplicateReviewError(Exception):
    """Raised when a user tries to submit a second review for the same book.

    Carries existing_review_id so the 409 response can include it,
    enabling frontends to redirect to the edit flow.
    """
    def __init__(self, existing_review_id: int) -> None:
        self.existing_review_id = existing_review_id
        super().__init__(f"Duplicate review, existing review ID: {existing_review_id}")


async def duplicate_review_handler(request: Request, exc: DuplicateReviewError) -> JSONResponse:
    """Handle DuplicateReviewError - returns 409 with existing_review_id."""
    return JSONResponse(
        status_code=409,
        content={
            "detail": "You have already reviewed this book",
            "code": "DUPLICATE_REVIEW",
            "existing_review_id": exc.existing_review_id,
        },
    )
```

This is a separate exception from AppError (not a subclass) because the 409 body has a non-standard field (`existing_review_id`) that AppError's handler cannot produce. The handler is registered in main.py (Task 2).

**2. Create app/reviews/schemas.py**

Create Pydantic v2 schemas following the locked decisions from CONTEXT.md:

- `ReviewAuthorSummary` — `user_id: int`, `display_name: str`, `avatar_url: str | None`. Use `from_attributes = True`. Since User model has no `display_name` column, the service will derive it from `email.split("@")[0]`. Since User model has no `avatar_url` column, it will always be `None` for now.

- `ReviewBookSummary` — `book_id: int`, `title: str`, `cover_image_url: str | None`. Use `from_attributes = True`. Maps `book_id` to `book.id` via alias or explicit construction.

- `ReviewCreate` — `rating: int = Field(ge=1, le=5)`, `text: str | None = Field(None, max_length=2000)`. This is the request body for POST.

- `ReviewUpdate` — `rating: int | None = Field(None, ge=1, le=5)`, `text: str | None = Field(None, max_length=2000)`. Request body for PATCH. (Defined here for use in Plan 14-02.)

- `ReviewResponse` — `id: int`, `book_id: int`, `user_id: int`, `rating: int`, `text: str | None`, `verified_purchase: bool`, `created_at: datetime`, `updated_at: datetime`, `author: ReviewAuthorSummary`, `book: ReviewBookSummary`. Use `from_attributes = True`. The `verified_purchase` field is NOT on the ORM model — it must be injected via `model_validate(review, update={"verified_purchase": vp, "author": author_summary, "book": book_summary})`.

- `ReviewListResponse` — `items: list[ReviewResponse]`, `total: int`, `page: int`, `size: int`. Pagination envelope matching BookListResponse pattern.

IMPORTANT: The `author` and `book` nested objects cannot use `from_attributes` directly on the ORM relationships because the field names differ (e.g., `user.email` needs to become `author.display_name`, `book.id` needs to become `book.book_id`). Therefore, the service must construct `ReviewAuthorSummary` and `ReviewBookSummary` dicts explicitly and pass them in `update={}`.

**3. Create app/reviews/service.py**

Create `ReviewService` that follows the established pattern (see WishlistService):

```python
class ReviewService:
    def __init__(self, review_repo, order_repo, book_repo):
        self.review_repo = review_repo
        self.order_repo = order_repo
        self.book_repo = book_repo
```

Methods:

- `create(user_id, book_id, rating, text) -> tuple[Review, bool]`:
  1. Verify book exists via `book_repo.get_by_id(book_id)`. Raise `AppError(404, "Book not found", "BOOK_NOT_FOUND", "book_id")` if not.
  2. Pre-check for duplicate via `review_repo.get_by_user_and_book(user_id, book_id)`. If found, raise `DuplicateReviewError(existing.id)`. This avoids catching IntegrityError and enables the enriched 409 body with `existing_review_id`.
  3. Check purchase via `order_repo.has_user_purchased_book(user_id, book_id)`. If False, raise `AppError(403, "You must purchase this book before submitting a review", "NOT_PURCHASED", "book_id")`.
  4. Create via `review_repo.create(user_id, book_id, rating, text)`.
  5. Return `(review, True)` — `True` because if they passed the purchase gate, verified_purchase is always True for the creator.

- `list_for_book(book_id, page, size) -> tuple[list[tuple[Review, bool]], int]`:
  1. Call `review_repo.list_for_book(book_id, page=page, size=size)`.
  2. For each review, call `order_repo.has_user_purchased_book(review.user_id, review.book_id)` to get `verified_purchase`.
  3. Return `([(review, vp), ...], total)`. Accept N+1 for page sizes up to 20 — documented as known limitation.

- `get(review_id) -> tuple[Review, bool]`:
  1. Fetch via `review_repo.get_by_id(review_id)`. Raise `AppError(404, "Review not found", "REVIEW_NOT_FOUND")` if None.
  2. Compute `vp = await order_repo.has_user_purchased_book(review.user_id, review.book_id)`.
  3. Return `(review, vp)`.

- Add a helper method `_build_response(review, verified_purchase) -> dict` that constructs the dict suitable for `ReviewResponse.model_validate()`:
  ```python
  def _build_review_data(self, review: Review, verified_purchase: bool) -> dict:
      return {
          "id": review.id,
          "book_id": review.book_id,
          "user_id": review.user_id,
          "rating": review.rating,
          "text": review.text,
          "verified_purchase": verified_purchase,
          "created_at": review.created_at,
          "updated_at": review.updated_at,
          "author": {
              "user_id": review.user.id,
              "display_name": review.user.email.split("@")[0],
              "avatar_url": None,
          },
          "book": {
              "book_id": review.book.id,
              "title": review.book.title,
              "cover_image_url": review.book.cover_image_url,
          },
      }
  ```
  This avoids the `model_validate(orm_obj, update={...})` complexity with nested non-ORM fields by building a plain dict that ReviewResponse can validate directly.

Import `DuplicateReviewError` from `app.core.exceptions` (same module as AppError).
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && python -c "from app.reviews.schemas import ReviewCreate, ReviewUpdate, ReviewResponse, ReviewListResponse, ReviewAuthorSummary, ReviewBookSummary; from app.reviews.service import ReviewService; from app.core.exceptions import DuplicateReviewError; print('All imports OK')"</automated>
  </verify>
  <done>
    - DuplicateReviewError class and handler exist in app/core/exceptions.py
    - All 6 Pydantic schemas defined in app/reviews/schemas.py with correct fields and validation
    - ReviewService class in app/reviews/service.py with create(), list_for_book(), get(), and _build_review_data() methods
    - ReviewCreate validates rating 1-5, text max_length 2000
    - ReviewService.create() pre-checks for duplicate and raises DuplicateReviewError(existing_review_id)
    - ReviewService.create() enforces purchase gate with NOT_PURCHASED 403
    - ReviewService.list_for_book() computes verified_purchase per review
  </done>
</task>

<task type="auto">
  <name>Task 2: Create review router, register in main.py, and wire DuplicateReviewError handler</name>
  <files>
    app/reviews/router.py
    app/main.py
  </files>
  <action>
**1. Create app/reviews/router.py**

Follow the exact pattern from `app/wishlist/router.py`:

```python
from fastapi import APIRouter, Query, status
from app.books.repository import BookRepository
from app.core.deps import ActiveUser, DbSession
from app.orders.repository import OrderRepository
from app.reviews.repository import ReviewRepository
from app.reviews.schemas import ReviewCreate, ReviewResponse, ReviewListResponse
from app.reviews.service import ReviewService

router = APIRouter(tags=["reviews"])
```

Use `tags=["reviews"]` with NO prefix — routes will specify full paths explicitly. This avoids prefix collision with the books router.

`_make_service(db)` factory:
```python
def _make_service(db: DbSession) -> ReviewService:
    return ReviewService(
        review_repo=ReviewRepository(db),
        order_repo=OrderRepository(db),
        book_repo=BookRepository(db),
    )
```

**Endpoint: POST /books/{book_id}/reviews**
- Params: `book_id: int` (path), `body: ReviewCreate` (JSON), `db: DbSession`, `current_user: ActiveUser`
- Extract `user_id = int(current_user["sub"])`
- Call `service.create(user_id, book_id, body.rating, body.text)`
- Receives `(review, verified_purchase)` tuple
- Build response: `ReviewResponse.model_validate(service._build_review_data(review, verified_purchase))`
- Return with `status_code=status.HTTP_201_CREATED`
- `response_model=ReviewResponse`

**Endpoint: GET /books/{book_id}/reviews**
- Params: `book_id: int` (path), `page: int = Query(1, ge=1)`, `size: int = Query(20, ge=1, le=100)`, `db: DbSession`
- This endpoint is PUBLIC — no auth required. Anyone can read reviews.
- Call `service.list_for_book(book_id, page, size)`
- Receives `(items_with_vp, total)` where items_with_vp is `list[tuple[Review, bool]]`
- Build response:
  ```python
  items = [ReviewResponse.model_validate(service._build_review_data(r, vp)) for r, vp in items_with_vp]
  return ReviewListResponse(items=items, total=total, page=page, size=size)
  ```

**Endpoint: GET /reviews/{review_id}**
- Params: `review_id: int` (path), `db: DbSession`
- PUBLIC — no auth required.
- Call `service.get(review_id)`
- Return `ReviewResponse.model_validate(service._build_review_data(review, vp))`

**2. Register router and DuplicateReviewError handler in app/main.py**

Add import at top with other router imports:
```python
from app.reviews.router import router as reviews_router
```

Add import for the DuplicateReviewError handler:
```python
from app.core.exceptions import (
    AppError,
    DuplicateReviewError,
    app_error_handler,
    duplicate_review_handler,
    generic_exception_handler,
    http_exception_handler,
    validation_exception_handler,
)
```

Register the DuplicateReviewError handler BEFORE the AppError handler (more specific first):
```python
application.add_exception_handler(DuplicateReviewError, duplicate_review_handler)
application.add_exception_handler(AppError, app_error_handler)
```

Register the reviews router after existing routers:
```python
application.include_router(reviews_router)
```
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && python -c "from app.main import app; routes = [r.path for r in app.routes]; assert '/books/{book_id}/reviews' in routes, f'Missing reviews route. Routes: {routes}'; print('Router registered OK')"</automated>
  </verify>
  <done>
    - app/reviews/router.py exists with POST /books/{book_id}/reviews (201, ActiveUser), GET /books/{book_id}/reviews (public, paginated), GET /reviews/{review_id} (public)
    - _make_service(db) factory instantiates ReviewService with ReviewRepository, OrderRepository, BookRepository
    - DuplicateReviewError handler registered in main.py (produces 409 with existing_review_id in body)
    - reviews_router included in main.py application
    - POST endpoint extracts user_id from ActiveUser["sub"] and enforces authentication
    - GET endpoints are public (no auth dependency)
    - Review responses include author summary (display_name derived from email), book summary, and verified_purchase flag
  </done>
</task>

</tasks>

<verification>
1. `python -c "from app.main import app; print('App loads OK')"` — no import errors
2. `python -c "from app.reviews.schemas import ReviewCreate; r = ReviewCreate(rating=3); print(r)"` — schema validates
3. `python -c "from app.reviews.schemas import ReviewCreate; ReviewCreate(rating=0)"` should raise ValidationError (rating < 1)
4. `python -c "from app.reviews.schemas import ReviewCreate; ReviewCreate(rating=6)"` should raise ValidationError (rating > 5)
5. Verify route paths exist: `python -c "from app.main import app; paths = [r.path for r in app.routes]; print([p for p in paths if 'review' in p])"`
</verification>

<success_criteria>
- POST /books/{book_id}/reviews is registered and requires ActiveUser auth
- GET /books/{book_id}/reviews is registered and is public (no auth)
- GET /reviews/{review_id} is registered and is public (no auth)
- ReviewService enforces purchase gate (403 NOT_PURCHASED), duplicate detection (409 DUPLICATE_REVIEW with existing_review_id), and book existence (404 BOOK_NOT_FOUND)
- Each review response includes verified_purchase, author summary, and book summary
- DuplicateReviewError handler produces structured 409 body with existing_review_id
- All existing tests still pass (no regressions from exception handler or router changes)
</success_criteria>

<output>
After completion, create `.planning/phases/14-review-crud-endpoints/14-01-SUMMARY.md`
</output>
