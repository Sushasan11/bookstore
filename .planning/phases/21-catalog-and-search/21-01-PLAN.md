---
phase: 21-catalog-and-search
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/books/router.py
  - backend/app/books/repository.py
  - backend/app/books/schemas.py
  - backend/tests/test_books.py
  - frontend/next.config.ts
  - frontend/src/lib/catalog.ts
  - frontend/src/app/catalog/_components/BookCard.tsx
  - frontend/src/app/catalog/_components/BookCardSkeleton.tsx
  - frontend/src/components/ui/skeleton.tsx
  - frontend/src/components/ui/badge.tsx
  - frontend/src/types/api.generated.ts
autonomous: true
requirements:
  - CATL-01
  - CATL-04

must_haves:
  truths:
    - "Backend GET /books accepts min_price, max_price, sort_dir, and sort=avg_rating query params"
    - "BookCard component renders cover image (or styled placeholder), title, author, price, and stock badge"
    - "BookCardSkeleton matches card layout for loading state"
    - "Catalog fetch helpers return typed responses from backend API"
  artifacts:
    - path: "backend/app/books/router.py"
      provides: "min_price, max_price, sort_dir query params and avg_rating sort on GET /books"
      contains: "min_price|max_price|sort_dir|avg_rating"
    - path: "backend/app/books/repository.py"
      provides: "Price range filter, sort direction, and avg_rating sort in search()"
      contains: "min_price|max_price|sort_dir|avg_rating"
    - path: "frontend/src/lib/catalog.ts"
      provides: "fetchBooks, fetchBook, fetchGenres typed helpers"
      exports: ["fetchBooks", "fetchBook", "fetchGenres"]
    - path: "frontend/src/app/catalog/_components/BookCard.tsx"
      provides: "Book card with cover, title, author, price, stock badge"
      min_lines: 30
    - path: "frontend/src/app/catalog/_components/BookCardSkeleton.tsx"
      provides: "Skeleton loading card and grid skeleton"
      exports: ["BookCardSkeleton", "BookGridSkeleton"]
  key_links:
    - from: "frontend/src/lib/catalog.ts"
      to: "frontend/src/lib/api.ts"
      via: "apiFetch import"
      pattern: "import.*apiFetch.*from.*@/lib/api"
    - from: "frontend/src/lib/catalog.ts"
      to: "frontend/src/types/api.generated.ts"
      via: "components type import"
      pattern: "import.*components.*from.*@/types/api.generated"
---

<objective>
Extend the backend to support price range filtering, sort direction, and avg_rating sort, then build the frontend foundation components needed by both the catalog page and book detail page: typed API fetch helpers, BookCard with cover placeholder, and skeleton loading states.

Purpose: Unblock Plans 02 and 03 by providing the shared components and API layer they depend on. The backend extension is required for CATL-04 (price range filter), sort options (price high-to-low), and "Highest rated" sort (per locked CONTEXT.md decision). The BookCard is reused in both the catalog grid (Plan 02) and "More in Genre" section (Plan 03).

Output: Extended backend API with price/sort/avg_rating params, regenerated TypeScript types, catalog fetch helpers, BookCard component, and skeleton loading components.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-catalog-and-search/21-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From frontend/src/lib/api.ts:
```typescript
const API_BASE = process.env.NEXT_PUBLIC_API_URL ?? 'http://localhost:8000'

export class ApiError extends Error {
  constructor(message: string, public status: number, public detail?: string) {
    super(message)
    this.name = 'ApiError'
  }
}

export async function apiFetch<T>(path: string, options: RequestInit = {}): Promise<T>
```

From frontend/src/types/api.generated.ts (key schemas):
```typescript
// components["schemas"]["BookResponse"]
BookResponse: {
  id: number; title: string; author: string; price: string;
  isbn: string | null; genre_id: number | null; description: string | null;
  cover_image_url: string | null; publish_date: string | null;
  stock_quantity: number;
}

// components["schemas"]["BookDetailResponse"]
BookDetailResponse: {
  ...BookResponse fields,
  avg_rating?: number | null;
  review_count: number;
  readonly in_stock: boolean;
}

// components["schemas"]["BookListResponse"]
BookListResponse: {
  items: components["schemas"]["BookResponse"][];
  total: number; page: number; size: number;
}

// components["schemas"]["GenreResponse"]
GenreResponse: { id: number; name: string; }
```

From backend/app/books/router.py (GET /books current signature — to be extended):
```python
@router.get("/books", response_model=BookListResponse)
async def list_books(
    db: DbSession,
    q: str | None = Query(None),
    genre_id: int | None = Query(None),
    author: str | None = Query(None),
    sort: Literal["title", "price", "date", "created_at"] = Query("title"),
    page: int = Query(1, ge=1),
    size: int = Query(20, ge=1, le=100),
) -> BookListResponse:
# Task 1 adds: min_price, max_price, sort_dir params; expands sort to include "avg_rating"
```

From backend/app/books/repository.py (search method — to be extended):
```python
async def search(self, *, q=None, genre_id=None, author=None, sort="title", page=1, size=20) -> tuple[list[Book], int]:
# Task 1 adds: min_price, max_price, sort_dir params; avg_rating sort via left-join subquery on reviews
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend backend GET /books with min_price, max_price, sort_dir params, and avg_rating sort</name>
  <files>
    backend/app/books/router.py
    backend/app/books/repository.py
    backend/app/books/schemas.py
    backend/tests/test_books.py
  </files>
  <action>
Add new query parameters and avg_rating sort to the GET /books endpoint:

1. **In `backend/app/books/router.py`** — add to `list_books()`:
   - `min_price: Decimal | None = Query(None, ge=0, description="Minimum price filter (inclusive)")` — import Decimal from decimal
   - `max_price: Decimal | None = Query(None, ge=0, description="Maximum price filter (inclusive)")` — must be >= min_price when both provided
   - `sort_dir: Literal["asc", "desc"] = Query("asc", description="Sort direction: asc or desc")` — add "desc" to Literal import
   - Expand the `sort` Literal to include `"avg_rating"`: `sort: Literal["title", "price", "date", "created_at", "avg_rating"] = Query("title", ...)`
   Pass all new params through to `service.list_books()`.

2. **In `backend/app/books/repository.py`** — update `search()` method:
   - Add params: `min_price: Decimal | None = None`, `max_price: Decimal | None = None`, `sort_dir: str = "asc"`
   - After genre/author filters, add price range filter:
     ```python
     if min_price is not None:
         stmt = stmt.where(Book.price >= min_price)
     if max_price is not None:
         stmt = stmt.where(Book.price <= max_price)
     ```
   - In the sort section (non-FTS case), apply sort_dir: when `sort_dir == "desc"`, reverse the sort column with `.desc()`. For `sort="created_at"`, the default is already desc — if `sort_dir=="asc"`, use `.asc()` instead. Tiebreaker `Book.id` always ascending for stable pagination.
   - **Add `sort="avg_rating"` support:** When `sort == "avg_rating"`, use a left-join subquery against the reviews table to compute avg rating per book. Build a subquery:
     ```python
     from app.reviews.models import Review
     # Subquery: avg_rating per book (only non-deleted reviews)
     avg_sub = (
         select(
             Review.book_id,
             func.avg(Review.rating).label("avg_rating"),
         )
         .where(Review.deleted_at.is_(None))
         .group_by(Review.book_id)
         .subquery()
     )
     stmt = stmt.outerjoin(avg_sub, Book.id == avg_sub.c.book_id)
     ```
     Then order by `avg_sub.c.avg_rating` (desc by default for "highest rated"; respect `sort_dir`). Use `nulls_last()` so books with no reviews sort to the end.
   - Import `Decimal` from decimal.

3. **In `backend/app/books/service.py`** — update `list_books()` to pass `min_price`, `max_price`, and `sort_dir` through to `book_repo.search()`.

4. **In `backend/tests/test_books.py`** — add 5 test cases in a new `TestBookPriceFilterAndSortDir` class:
   - `test_min_price_filter`: Create books at $5 and $15. GET /books?min_price=10 returns only $15 book.
   - `test_max_price_filter`: Create books at $5 and $15. GET /books?max_price=10 returns only $5 book.
   - `test_price_range_filter`: Create books at $5, $10, $15. GET /books?min_price=8&max_price=12 returns only $10 book.
   - `test_sort_dir_desc`: Create books titled "Alpha" ($5) and "Zeta" ($20). GET /books?sort=price&sort_dir=desc returns Zeta first.
   - `test_sort_avg_rating`: Create 2 books; add reviews (via direct DB insert) giving book A avg 4.5 and book B avg 3.0. GET /books?sort=avg_rating&sort_dir=desc returns book A first.

After backend changes, the backend must start and pass all existing tests plus the new ones.
  </action>
  <verify>
    <automated>cd backend && poetry run pytest tests/test_books.py -x -q</automated>
  </verify>
  <done>
    GET /books accepts min_price, max_price, sort_dir query params, and sort=avg_rating. Price range filtering works correctly. Sort direction reversal works for all sort options. avg_rating sort uses a left-join subquery against reviews with nulls_last. All existing and new tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create catalog API helpers, BookCard, skeleton components, and configure next/image</name>
  <files>
    frontend/next.config.ts
    frontend/src/lib/catalog.ts
    frontend/src/app/catalog/_components/BookCard.tsx
    frontend/src/app/catalog/_components/BookCardSkeleton.tsx
    frontend/src/components/ui/skeleton.tsx
    frontend/src/components/ui/badge.tsx
    frontend/src/types/api.generated.ts
  </files>
  <action>
**Step 1: Install dependencies and add shadcn components**
```bash
cd frontend && npm install use-debounce && npx shadcn@latest add skeleton badge --yes
```

**Step 2: Configure next/image for external cover URLs**
In `frontend/next.config.ts`, add `images.remotePatterns` to allow HTTPS images from any domain (covers any future cover image source):
```typescript
const nextConfig: NextConfig = {
  images: {
    remotePatterns: [
      { protocol: 'https', hostname: '**' },
    ],
  },
};
```

**Step 3: Regenerate API types** (after backend changes from Task 1 are running)
```bash
cd frontend && npm run generate-types
```
This updates `frontend/src/types/api.generated.ts` to include the new `min_price`, `max_price`, and `sort_dir` query params.

**Step 4: Create `frontend/src/lib/catalog.ts`** with typed fetch helpers:

```typescript
import { apiFetch, ApiError } from '@/lib/api'
import type { components } from '@/types/api.generated'

type BookListResponse = components['schemas']['BookListResponse']
type BookDetailResponse = components['schemas']['BookDetailResponse']
type GenreResponse = components['schemas']['GenreResponse']

// Re-export types for consumer convenience
export type { BookListResponse, BookDetailResponse, GenreResponse }
export type BookResponse = components['schemas']['BookResponse']

export async function fetchBooks(params: {
  q?: string
  genre_id?: number
  min_price?: number
  max_price?: number
  sort?: string
  sort_dir?: 'asc' | 'desc'
  page?: number
  size?: number
}): Promise<BookListResponse> {
  const qs = new URLSearchParams()
  if (params.q) qs.set('q', params.q)
  if (params.genre_id) qs.set('genre_id', String(params.genre_id))
  if (params.min_price !== undefined) qs.set('min_price', String(params.min_price))
  if (params.max_price !== undefined) qs.set('max_price', String(params.max_price))
  if (params.sort) qs.set('sort', params.sort)
  if (params.sort_dir) qs.set('sort_dir', params.sort_dir)
  if (params.page) qs.set('page', String(params.page))
  if (params.size) qs.set('size', String(params.size))
  return apiFetch<BookListResponse>(`/books?${qs}`)
}

export async function fetchBook(id: number): Promise<BookDetailResponse | null> {
  try {
    return await apiFetch<BookDetailResponse>(`/books/${id}`)
  } catch (e: unknown) {
    if (e instanceof ApiError && e.status === 404) return null
    throw e
  }
}

export async function fetchGenres(): Promise<GenreResponse[]> {
  return apiFetch<GenreResponse[]>('/genres')
}
```

**Step 5: Create `frontend/src/app/catalog/_components/BookCard.tsx`** as a server component:

- Import `next/image`, Link from `next/link`, Badge from shadcn
- Props: `book: BookResponse` (from catalog.ts re-export)
- The card is a Link wrapping `/books/${book.id}`
- Layout: aspect-[2/3] cover area on top, text content below
- Cover image: if `book.cover_image_url` exists, render `<Image>` with `fill`, `object-cover`, `sizes="(max-width: 768px) 50vw, 25vw"`. If null, render a styled placeholder div with deterministic background color (use `const colors = ['bg-blue-100 dark:bg-blue-900', 'bg-green-100 dark:bg-green-900', 'bg-purple-100 dark:bg-purple-900', 'bg-amber-100 dark:bg-amber-900', 'bg-rose-100 dark:bg-rose-900']` and select via `book.id % colors.length`). Placeholder shows `book.title` in bold and `book.author` in smaller text, centered.
- Below cover: title (font-medium, line-clamp-1), author (text-sm text-muted-foreground, line-clamp-1), price formatted as `$XX.XX`
- Stock badge: if `stock_quantity > 0`, show green "In Stock" badge. If 0, show red "Out of Stock" badge. Use shadcn Badge component with `variant="secondary"` and custom className for color.
- Card has rounded-lg, overflow-hidden, border, hover:shadow-md transition-shadow for interactivity feel.

**Step 6: Create `frontend/src/app/catalog/_components/BookCardSkeleton.tsx`**:

```typescript
import { Skeleton } from '@/components/ui/skeleton'

export function BookCardSkeleton() {
  return (
    <div className="flex flex-col gap-2">
      <Skeleton className="aspect-[2/3] w-full rounded-lg" />
      <Skeleton className="h-4 w-3/4" />
      <Skeleton className="h-3 w-1/2" />
      <Skeleton className="h-4 w-1/4" />
    </div>
  )
}

export function BookGridSkeleton() {
  return (
    <div className="grid grid-cols-2 md:grid-cols-4 gap-6">
      {Array.from({ length: 20 }).map((_, i) => (
        <BookCardSkeleton key={i} />
      ))}
    </div>
  )
}
```

Verify TypeScript compiles with no errors: `cd frontend && npx tsc --noEmit`.
  </action>
  <verify>
    <automated>cd frontend && npx tsc --noEmit</automated>
  </verify>
  <done>
    next.config.ts has remotePatterns for external images. catalog.ts exports fetchBooks/fetchBook/fetchGenres with full typing. BookCard renders cover placeholder with deterministic color, title, author, price, and stock badge. BookCardSkeleton and BookGridSkeleton provide loading states. TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. Backend: `cd backend && poetry run pytest tests/test_books.py -x -q` passes all tests including new price range and sort_dir tests
2. Frontend: `cd frontend && npx tsc --noEmit` compiles with zero errors
3. `frontend/src/lib/catalog.ts` exports fetchBooks, fetchBook, fetchGenres
4. `frontend/src/app/catalog/_components/BookCard.tsx` exists and imports from catalog.ts types
5. `frontend/src/app/catalog/_components/BookCardSkeleton.tsx` exports BookCardSkeleton and BookGridSkeleton
</verification>

<success_criteria>
- GET /books?min_price=10&max_price=20 filters books by price range correctly
- GET /books?sort=price&sort_dir=desc returns books sorted by price descending
- GET /books?sort=avg_rating&sort_dir=desc returns books sorted by highest rated first (nulls last)
- BookCard component renders a visually distinct placeholder for books without cover images
- All TypeScript types compile cleanly after regeneration
</success_criteria>

<output>
After completion, create `.planning/phases/21-catalog-and-search/21-01-SUMMARY.md`
</output>
