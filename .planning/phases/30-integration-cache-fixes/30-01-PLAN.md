---
phase: 30-integration-cache-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/app/api/revalidate/route.ts
  - frontend/src/lib/revalidate.ts
  - frontend/src/app/admin/catalog/page.tsx
  - frontend/src/components/admin/StockUpdateModal.tsx
  - frontend/src/app/admin/reviews/page.tsx
autonomous: true
requirements:
  - ADMF-02
  - ADMF-03
  - CATL-03
  - CATL-04
  - CATL-05
  - CATL-06

must_haves:
  truths:
    - "Existing middleware.ts redirects non-admin/unauthenticated users away from /admin routes at the edge (Layer 1)"
    - "Admin layout.tsx independently checks role and redirects (Layer 2) — defense-in-depth against CVE-2025-29927"
    - "Admin book create mutation triggers server-side cache revalidation for the customer storefront catalog and book detail pages"
    - "Admin book edit mutation triggers cache revalidation so the customer storefront shows updated book data"
    - "Admin book delete mutation triggers cache revalidation so the deleted book no longer appears in storefront catalog"
    - "Admin stock update mutation triggers cache revalidation so the book detail page reflects the new stock level"
    - "Admin review delete mutations trigger cache revalidation so book detail page avg_rating and review_count update"
    - "Revalidation API route is admin-only — unauthenticated or non-admin requests receive 403"
  artifacts:
    - path: "frontend/src/app/api/revalidate/route.ts"
      provides: "Admin-guarded on-demand revalidation Route Handler"
      exports: ["POST"]
    - path: "frontend/src/lib/revalidate.ts"
      provides: "Fire-and-forget triggerRevalidation helper with typed path support"
      exports: ["triggerRevalidation", "RevalidationPath"]
    - path: "frontend/src/middleware.ts"
      provides: "Layer 1 admin route protection (already exists — verified, not modified)"
    - path: "frontend/src/app/admin/layout.tsx"
      provides: "Layer 2 admin role check Server Component (already exists — verified, not modified)"
  key_links:
    - from: "frontend/src/app/admin/catalog/page.tsx"
      to: "/api/revalidate"
      via: "triggerRevalidation in createMutation.onSuccess, updateMutation.onSuccess, deleteMutation.onSuccess"
      pattern: "triggerRevalidation\\("
    - from: "frontend/src/components/admin/StockUpdateModal.tsx"
      to: "/api/revalidate"
      via: "triggerRevalidation in stockMutation.onSuccess"
      pattern: "triggerRevalidation\\("
    - from: "frontend/src/app/admin/reviews/page.tsx"
      to: "/api/revalidate"
      via: "triggerRevalidation in singleDeleteMutation.onSuccess, bulkDeleteMutation.onSuccess"
      pattern: "triggerRevalidation\\("
    - from: "frontend/src/app/api/revalidate/route.ts"
      to: "next/cache revalidatePath"
      via: "revalidatePath(path, type?) calls — type='page' used for dynamic route patterns like /books/[id] to revalidate all matching pages"
      pattern: "revalidatePath\\("
---

<objective>
Close defense-in-depth and cache propagation gaps from the v3.1 milestone audit.

Purpose: (1) Verify that the existing middleware.ts + admin layout.tsx satisfy the Layer 1 + Layer 2 defense-in-depth requirement (ADMF-02, ADMF-03). (2) Fix the cache propagation break where admin mutations invalidate TanStack Query client cache but have no effect on the Next.js fetch cache used by the RSC storefront — so customer-facing catalog and book detail pages reflect admin changes without requiring a full page reload.

Output: Verified middleware defense-in-depth, a new `POST /api/revalidate` Route Handler with admin auth guard, a `triggerRevalidation` helper, and all admin mutations wired to call it fire-and-forget from `onSuccess` callbacks.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-integration-cache-fixes/30-CONTEXT.md
@.planning/phases/30-integration-cache-fixes/30-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->
<!-- Executor should use these directly — no codebase exploration needed. -->

From frontend/src/auth.ts:
```typescript
export const { handlers, auth, signIn, signOut } = NextAuth({ ... })
// auth() returns Session | null
// Session.user.role === 'admin' | 'user'
```

From frontend/src/middleware.ts (existing — Layer 1 defense-in-depth):
```typescript
// Already implements admin route protection:
// - adminPrefixes = ["/admin"]
// - Checks isLoggedIn and req.auth?.user?.role !== "admin"
// - Redirects non-admin to "/" silently
// - matcher: ["/((?!api|_next/static|_next/image|favicon.ico).*)"]
```

From frontend/src/app/admin/layout.tsx (existing — Layer 2 defense-in-depth):
```typescript
// Already implements independent role check:
// const session = await auth()
// if (!session?.user || session.user.role !== 'admin') { redirect('/') }
```

From frontend/src/types/api.generated.ts:
```typescript
// AdminReviewBook — book context in admin review list
AdminReviewBook: {
  book_id: number;   // <-- use this for per-book revalidation path
  title: string;
}

// AdminReviewEntry.book is AdminReviewBook
// So deleteTarget.book.book_id gives the book ID for single review delete
```

From frontend/src/app/admin/catalog/page.tsx:
```typescript
// Mutations to wire revalidation into:
// createMutation.onSuccess → currently invalidates adminKeys.catalog.all + ['books']
// updateMutation.onSuccess → currently invalidates adminKeys.catalog.all + ['books']
// deleteMutation.onSuccess → currently invalidates adminKeys.catalog.all + ['books']
// editingBook!.id available in updateMutation scope
// deleteTarget!.id available in deleteMutation scope
```

From frontend/src/components/admin/StockUpdateModal.tsx:
```typescript
// stockMutation.onSuccess → currently invalidates adminKeys.inventory.all + adminKeys.catalog.all + ['books']
// book?.book_id available in scope for per-book revalidation
```

From frontend/src/app/admin/reviews/page.tsx:
```typescript
// singleDeleteMutation.onSuccess → currently invalidates adminKeys.reviews.all
// deleteTarget!.book.book_id available for per-book revalidation
// bulkDeleteMutation.onSuccess → currently invalidates adminKeys.reviews.all
// selectedIds contains review IDs (not book IDs) — use revalidatePath('/books/[id]', 'page') for bulk
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify middleware defense-in-depth and create revalidation Route Handler</name>
  <files>frontend/src/app/api/revalidate/route.ts, frontend/src/lib/revalidate.ts</files>
  <action>
**Part A — Middleware verification (ADMF-02, ADMF-03):**

Verify the existing `frontend/src/middleware.ts` satisfies defense-in-depth:
1. Confirm it uses `auth()` wrapper from `@/auth` (NextAuth v5 Edge-compatible pattern)
2. Confirm `adminPrefixes` includes `"/admin"`
3. Confirm unauthenticated admin requests redirect to `/`
4. Confirm non-admin authenticated requests redirect to `/`
5. Confirm `config.matcher` covers `/admin` routes
6. Confirm `frontend/src/app/admin/layout.tsx` has an independent `auth()` + role check (Layer 2)

**No code changes to middleware.ts or layout.tsx.** If everything checks out (it should — research confirmed), proceed to Part B. If any gap is found, fix it before proceeding.

**Part B — Create revalidation Route Handler:**

Create `frontend/src/app/api/revalidate/route.ts`:
```typescript
import { revalidatePath } from 'next/cache'
import { auth } from '@/auth'
import { NextResponse } from 'next/server'

interface RevalidationEntry {
  path: string
  type?: 'page' | 'layout'
}

export async function POST(request: Request) {
  const session = await auth()

  // Admin guard — prevent unauthorized cache busting
  if (!session?.user || session.user.role !== 'admin') {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
  }

  const body = await request.json().catch(() => ({}))
  const paths: RevalidationEntry[] = Array.isArray(body.paths) ? body.paths : []

  for (const entry of paths) {
    // Support both string entries (legacy) and object entries with type
    if (typeof entry === 'string') {
      revalidatePath(entry)
    } else {
      revalidatePath(entry.path, entry.type)
    }
  }

  return NextResponse.json({ revalidated: true, paths })
}
```

**Why object entries with `type`:** Next.js `revalidatePath('/books/[id]', 'page')` revalidates ALL pages matching the dynamic route pattern. Without the `'page'` type parameter, only the layout segment is invalidated — individual book detail pages remain stale. This matters for bulk operations where we cannot enumerate specific book IDs.

**Part C — Create triggerRevalidation helper:**

Create `frontend/src/lib/revalidate.ts`:
```typescript
export type RevalidationPath = string | { path: string; type: 'page' | 'layout' }

/**
 * Fire-and-forget storefront cache revalidation.
 *
 * Calls POST /api/revalidate to purge the Next.js fetch cache for the given paths.
 * Admin mutations call this from onSuccess — do NOT await; admin UX must not block.
 * Silent failure in production: ISR safety net (revalidate = 3600) handles recovery.
 *
 * Accepts plain strings for simple paths (e.g. '/catalog') or objects with a `type`
 * field for dynamic route patterns (e.g. { path: '/books/[id]', type: 'page' }).
 * The `type` parameter tells Next.js to revalidate ALL pages matching that pattern.
 */
export function triggerRevalidation(paths: RevalidationPath[]) {
  fetch('/api/revalidate', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ paths }),
  }).catch((err) => {
    if (process.env.NODE_ENV === 'development') {
      console.warn('[revalidate] failed:', err)
    }
  })
}
```

The helper is a separate file (not inline) so all admin mutation pages import from one place — DRY and easy to find.
  </action>
  <verify>
    <automated>cd D:/Python/claude-test/frontend && npx tsc --noEmit --pretty 2>&1 | head -30</automated>
  </verify>
  <done>
    - `frontend/src/app/api/revalidate/route.ts` exists, exports POST, checks admin role via auth(), accepts `{ path, type? }[]` entries and calls `revalidatePath(path, type)` when type is present
    - `frontend/src/lib/revalidate.ts` exists, exports `triggerRevalidation` accepting `RevalidationPath[]` (string or `{ path, type }` union), uses fire-and-forget fetch with dev-mode error logging
    - middleware.ts verified as Layer 1 (no changes needed)
    - admin/layout.tsx verified as Layer 2 (no changes needed)
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire triggerRevalidation into all admin mutation onSuccess callbacks</name>
  <files>frontend/src/app/admin/catalog/page.tsx, frontend/src/components/admin/StockUpdateModal.tsx, frontend/src/app/admin/reviews/page.tsx</files>
  <action>
Wire `triggerRevalidation` from `@/lib/revalidate` into every admin mutation that affects storefront-visible data. Follow the mutation coverage matrix from research. Do NOT await the call — it is fire-and-forget.

**Note on catalog listing page:** `(store)/catalog/page.tsx` accesses `searchParams` which opts it into dynamic rendering (always fresh). Including `/catalog` in revalidation paths is harmless and future-proof, so include it for create/update/delete book mutations.

**1. `frontend/src/app/admin/catalog/page.tsx`:**

Add import at top:
```typescript
import { triggerRevalidation } from '@/lib/revalidate'
```

Modify `createMutation.onSuccess`:
```typescript
onSuccess: () => {
  queryClient.invalidateQueries({ queryKey: adminKeys.catalog.all })
  queryClient.invalidateQueries({ queryKey: ['books'] })
  triggerRevalidation(['/catalog'])
  toast.success('Book added successfully')
  setDrawerOpen(false)
},
```
(New book — revalidate catalog listing only. No book detail page exists yet for the new book.)

Modify `updateMutation.onSuccess`:
```typescript
onSuccess: () => {
  queryClient.invalidateQueries({ queryKey: adminKeys.catalog.all })
  queryClient.invalidateQueries({ queryKey: ['books'] })
  triggerRevalidation(['/catalog', `/books/${editingBook!.id}`])
  toast.success('Book updated successfully')
  setDrawerOpen(false)
  setEditingBook(null)
},
```
(Updated book — revalidate both catalog listing and the specific book detail page.)

Modify `deleteMutation.onSuccess`:
```typescript
onSuccess: () => {
  queryClient.invalidateQueries({ queryKey: adminKeys.catalog.all })
  queryClient.invalidateQueries({ queryKey: ['books'] })
  triggerRevalidation(['/catalog'])
  toast.success('Book deleted successfully')
  setDeleteTarget(null)
},
```
(Deleted book — revalidate catalog listing. Detail page will 404 naturally on next visit after ISR miss.)

**2. `frontend/src/components/admin/StockUpdateModal.tsx`:**

Add import at top:
```typescript
import { triggerRevalidation } from '@/lib/revalidate'
```

Modify `stockMutation.onSuccess`:
```typescript
onSuccess: () => {
  queryClient.invalidateQueries({ queryKey: adminKeys.inventory.all })
  queryClient.invalidateQueries({ queryKey: adminKeys.catalog.all })
  queryClient.invalidateQueries({ queryKey: ['books'] })
  triggerRevalidation([`/books/${book?.book_id}`])

  if (book?.current_stock === 0 && newQuantity > 0) {
    toast.success('Stock updated — pre-booking notifications sent')
  } else {
    toast.success('Stock updated successfully')
  }

  onSuccess?.()
  onOpenChange(false)
},
```
(Stock update — revalidate the specific book detail page where stock/availability is shown.)

**3. `frontend/src/app/admin/reviews/page.tsx`:**

Add import at top:
```typescript
import { triggerRevalidation } from '@/lib/revalidate'
```

Modify `singleDeleteMutation.onSuccess`:
```typescript
onSuccess: () => {
  queryClient.invalidateQueries({ queryKey: adminKeys.reviews.all })
  triggerRevalidation([`/books/${deleteTarget!.book.book_id}`])
  toast.success('Review deleted')
  setDeleteTarget(null)
},
```
(Single review delete — revalidate the affected book's detail page which displays avg_rating and review_count via RSC fetch.)

Modify `bulkDeleteMutation.onSuccess`:
```typescript
onSuccess: (data) => {
  queryClient.invalidateQueries({ queryKey: adminKeys.reviews.all })
  triggerRevalidation([{ path: '/books/[id]', type: 'page' }])
  toast.success(
    `${data.deleted_count} review${data.deleted_count === 1 ? '' : 's'} deleted`
  )
  setSelectedIds(new Set())
  setBulkConfirmOpen(false)
},
```
(Bulk review delete — multiple books may be affected; selectedIds contains review IDs not book IDs. Pass `{ path: '/books/[id]', type: 'page' }` so the Route Handler calls `revalidatePath('/books/[id]', 'page')`, which tells Next.js to revalidate ALL pages matching the dynamic `[id]` segment. Without the `'page'` type, only the layout segment is invalidated and individual book detail pages remain stale.)

**Important:** User management mutations (deactivate/reactivate in users/page.tsx) do NOT need revalidation — user status does not affect storefront book pages.
  </action>
  <verify>
    <automated>cd D:/Python/claude-test/frontend && npx tsc --noEmit --pretty 2>&1 | head -30</automated>
  </verify>
  <done>
    - catalog/page.tsx createMutation.onSuccess calls triggerRevalidation(['/catalog'])
    - catalog/page.tsx updateMutation.onSuccess calls triggerRevalidation(['/catalog', '/books/${bookId}'])
    - catalog/page.tsx deleteMutation.onSuccess calls triggerRevalidation(['/catalog'])
    - StockUpdateModal.tsx stockMutation.onSuccess calls triggerRevalidation(['/books/${bookId}'])
    - reviews/page.tsx singleDeleteMutation.onSuccess calls triggerRevalidation(['/books/${bookId}'])
    - reviews/page.tsx bulkDeleteMutation.onSuccess calls triggerRevalidation([{ path: '/books/[id]', type: 'page' }])
    - All calls are fire-and-forget (not awaited)
    - TypeScript compiles without errors
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes — no TypeScript errors from new imports or modified callbacks
2. `frontend/src/app/api/revalidate/route.ts` exists and exports a POST handler that checks admin auth
3. `frontend/src/lib/revalidate.ts` exists and exports `triggerRevalidation`
4. All 6 admin mutations (3 in catalog, 1 in StockUpdateModal, 2 in reviews) call `triggerRevalidation`
5. No mutation awaits the revalidation call (fire-and-forget pattern preserved)
6. `frontend/src/middleware.ts` remains unchanged (already correct)
7. `frontend/src/app/admin/layout.tsx` remains unchanged (already correct)
</verification>

<success_criteria>
- Defense-in-depth verified: middleware.ts (Layer 1) + admin/layout.tsx (Layer 2) both perform independent admin role checks
- POST /api/revalidate exists, is admin-guarded (403 for non-admin), accepts `{ path, type? }[]` entries, and calls `revalidatePath(path, type)` when type is present
- All admin mutations that affect storefront-visible data call triggerRevalidation fire-and-forget from onSuccess
- Catalog CRUD mutations revalidate /catalog and/or /books/${bookId} as appropriate
- Stock update mutation revalidates /books/${bookId}
- Review delete mutations revalidate affected book detail pages
- TypeScript compiles without errors
- Existing ISR safety net (revalidate = 3600) remains on book detail page (belt and suspenders)
</success_criteria>

<output>
After completion, create `.planning/phases/30-integration-cache-fixes/30-01-SUMMARY.md`
</output>
