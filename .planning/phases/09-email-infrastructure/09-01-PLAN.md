---
phase: 09-email-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - poetry.lock
  - app/core/config.py
  - app/email/__init__.py
  - app/email/service.py
  - app/email/templates/base.html
autonomous: true
requirements:
  - EMAL-01
  - EMAL-04
  - EMAL-05
  - EMAL-06

must_haves:
  truths:
    - "EmailService can be instantiated with ConnectionConfig derived from Settings"
    - "base.html Jinja2 template renders without error and supports template inheritance via block content"
    - "EmailService.enqueue() adds email sending to BackgroundTasks without blocking"
    - "Plain-text fallback is auto-generated by stripping HTML tags and wired into enqueue() via alternative_body"
    - "MAIL_* settings have sensible defaults so non-email tests don't break on startup"
  artifacts:
    - path: "app/email/__init__.py"
      provides: "Email module package init"
    - path: "app/email/service.py"
      provides: "EmailService class with enqueue(), _strip_html(), and _render_plain_text()"
      contains: "class EmailService"
    - path: "app/email/templates/base.html"
      provides: "Shared base layout with header, content block, footer"
      contains: "block content"
    - path: "app/core/config.py"
      provides: "MAIL_* settings fields with defaults"
      contains: "MAIL_USERNAME"
  key_links:
    - from: "app/email/service.py"
      to: "app/core/config.py"
      via: "get_settings() for ConnectionConfig construction"
      pattern: "get_settings|ConnectionConfig"
    - from: "app/email/service.py"
      to: "app/email/templates/"
      via: "TEMPLATE_FOLDER=Path(__file__).parent / 'templates'"
      pattern: "TEMPLATE_FOLDER"
    - from: "app/email/service.py"
      to: "fastapi_mail"
      via: "FastMail + MessageSchema + ConnectionConfig + MultipartSubtypeEnum imports"
      pattern: "from fastapi_mail import"
    - from: "app/email/service.py::enqueue()"
      to: "app/email/service.py::_render_plain_text()"
      via: "enqueue() calls _render_plain_text() to generate alternative_body for MessageSchema"
      pattern: "_render_plain_text|alternative_body"
---

<objective>
Install fastapi-mail, add email configuration to Settings, create the EmailService class, and build the shared base.html Jinja2 template.

Purpose: Provide a tested, reusable email infrastructure that any router can use to send HTML emails via BackgroundTasks without blocking the API response or sending before DB commit.

Output: `app/email/` module with EmailService class, base.html template, and MAIL_* config fields in Settings.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-email-infrastructure/09-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From app/core/config.py:
```python
from functools import lru_cache
from pydantic_settings import BaseSettings, SettingsConfigDict

class Settings(BaseSettings):
    # Database
    DATABASE_URL: str = "postgresql+asyncpg://postgres:postgres@127.0.0.1:5434/bookstore_dev"
    TEST_DATABASE_URL: str = "postgresql+asyncpg://postgres:postgres@127.0.0.1:5433/bookstore_test"
    # Security
    SECRET_KEY: str = "changeme-in-production"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_DAYS: int = 7
    # OAuth - Google
    GOOGLE_CLIENT_ID: str = ""
    GOOGLE_CLIENT_SECRET: str = ""
    # OAuth - GitHub
    GITHUB_CLIENT_ID: str = ""
    GITHUB_CLIENT_SECRET: str = ""
    # Application
    DEBUG: bool = False
    ALLOWED_ORIGINS: list[str] = ["http://localhost:3000"]
    ENV: str = "development"

    model_config = SettingsConfigDict(
        env_file=".env", env_file_encoding="utf-8", case_sensitive=False,
    )

@lru_cache
def get_settings() -> Settings:
    return Settings()
```

From app/core/deps.py (post-commit pattern — email safety depends on this):
```python
async def get_db() -> AsyncGenerator[AsyncSession]:
    async with AsyncSessionLocal() as session:
        try:
            yield session
            await session.commit()
        except Exception:
            await session.rollback()
            raise
        finally:
            await session.close()
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install fastapi-mail and add MAIL_* settings to config</name>
  <files>pyproject.toml, poetry.lock, app/core/config.py</files>
  <action>
1. Install fastapi-mail:
   ```bash
   poetry add "fastapi-mail>=1.6,<2"
   ```
   This also installs `blinker` as a transitive dependency (required for `record_messages()` in tests).

2. Add MAIL_* fields to the existing `Settings` class in `app/core/config.py`. Add them AFTER the existing `ENV` field, under a new `# Email` comment block:
   ```python
   # Email
   MAIL_USERNAME: str = ""
   MAIL_PASSWORD: str = ""
   MAIL_FROM: str = "noreply@bookstore.com"
   MAIL_PORT: int = 587
   MAIL_SERVER: str = "smtp.gmail.com"
   MAIL_FROM_NAME: str = "Bookstore"
   MAIL_SUPPRESS_SEND: int = 1  # Default: suppress (safe for dev/test); prod sets to 0
   ```

   **All fields have defaults** so existing tests that never import email functionality will not break. `MAIL_SUPPRESS_SEND` defaults to 1 (suppressed) — production overrides to 0 via environment variable.

   Do NOT change the existing `model_config` or any existing fields. Append only.
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && poetry show fastapi-mail && python -c "from app.core.config import get_settings; s = get_settings(); print(s.MAIL_FROM, s.MAIL_SUPPRESS_SEND)"</automated>
  </verify>
  <done>fastapi-mail is installed. Settings class has MAIL_* fields with sensible defaults. `get_settings().MAIL_FROM` returns "noreply@bookstore.com" and `MAIL_SUPPRESS_SEND` returns 1.</done>
</task>

<task type="auto">
  <name>Task 2: Create EmailService class and base.html template</name>
  <files>app/email/__init__.py, app/email/service.py, app/email/templates/base.html</files>
  <action>
1. Create `app/email/__init__.py` — empty file (package init).

2. Create `app/email/service.py` with:

   **Imports:**
   ```python
   import logging
   import re
   from functools import lru_cache
   from pathlib import Path

   from fastapi import BackgroundTasks
   from fastapi_mail import ConnectionConfig, FastMail, MessageSchema, MessageType
   from fastapi_mail.schemas import MultipartSubtypeEnum
   from jinja2 import Environment, FileSystemLoader

   from app.core.config import get_settings
   ```

   **`get_email_config()` function:**
   - Reads from `get_settings()` to build `ConnectionConfig`
   - Sets `MAIL_STARTTLS=True`, `MAIL_SSL_TLS=False`, `USE_CREDENTIALS=True`, `VALIDATE_CERTS=True`
   - Sets `SUPPRESS_SEND` from `s.MAIL_SUPPRESS_SEND` (note: ConnectionConfig field is `SUPPRESS_SEND`, not `MAIL_SUPPRESS_SEND`)
   - Sets `TEMPLATE_FOLDER=Path(__file__).parent / "templates"`

   **`TEMPLATE_FOLDER` constant and Jinja2 environment (module-level):**
   ```python
   TEMPLATE_FOLDER = Path(__file__).parent / "templates"
   ```

   **`EmailService` class:**
   ```python
   class EmailService:
       """Reusable email service wrapping FastMail.

       Usage pattern (in routers):
           email_svc.enqueue(background_tasks, to, template_name, subject, context)

       The enqueue() method adds the send to BackgroundTasks. Because
       BackgroundTasks run AFTER the response is sent (which is after
       get_db commits), email is never dispatched if the DB transaction
       rolls back. This is a structural guarantee — see app/core/deps.py.
       """

       def __init__(self, config: ConnectionConfig) -> None:
           self.fm = FastMail(config)
           self._logger = logging.getLogger(__name__)
           self._jinja_env = Environment(
               loader=FileSystemLoader(str(TEMPLATE_FOLDER)),
               autoescape=True,
           )

       @staticmethod
       def _strip_html(html: str) -> str:
           """Auto-generate plain-text fallback by stripping HTML tags."""
           text = re.sub(r'<[^>]+>', '', html)
           # Collapse whitespace runs into single spaces
           return re.sub(r'\s+', ' ', text).strip()

       def _render_plain_text(self, template_name: str, context: dict) -> str:
           """Render the Jinja2 template to HTML, then strip tags for plain-text fallback.

           This implements the CONTEXT.md locked decision: 'plain-text fallback
           auto-generated by stripping HTML tags from rendered output — no
           separate .txt templates'.
           """
           template = self._jinja_env.get_template(template_name)
           rendered_html = template.render(**context)
           return self._strip_html(rendered_html)

       def enqueue(
           self,
           background_tasks: BackgroundTasks,
           to: str,
           template_name: str,
           subject: str,
           context: dict,
       ) -> None:
           """Add email send to BackgroundTasks (post-commit safe).

           Renders the template to generate a plain-text fallback via
           _strip_html(), then builds a multipart/alternative MessageSchema
           with both HTML (via template_body) and plain text (via alternative_body).

           Args:
               background_tasks: FastAPI BackgroundTasks instance from the route.
               to: Recipient email address (single).
               template_name: Jinja2 template filename (e.g. "order_confirmation.html").
               subject: Email subject line.
               context: Dict of template variables passed to Jinja2.
           """
           plain_text = self._render_plain_text(template_name, context)
           message = MessageSchema(
               subject=subject,
               recipients=[to],
               template_body=context,
               subtype=MessageType.html,
               alternative_body=plain_text,
               multipart_subtype=MultipartSubtypeEnum.alternative,
           )
           background_tasks.add_task(self._send, message, template_name)

       async def _send(self, message: MessageSchema, template_name: str) -> None:
           """Internal: send the email. Logs and drops on failure."""
           try:
               await self.fm.send_message(message, template_name=template_name)
           except Exception as exc:
               self._logger.error(
                   "Email send failed: recipient=%s template=%s error=%s",
                   message.recipients,
                   template_name,
                   str(exc),
               )
   ```

   **`get_email_service()` factory (cached):**
   ```python
   @lru_cache
   def get_email_service() -> EmailService:
       """Return a cached EmailService instance.

       Cached via @lru_cache — FastMail(config) is reused across requests.
       In tests, call get_email_service.cache_clear() to reset.
       """
       return EmailService(config=get_email_config())
   ```

   **Depends alias (at module bottom):**
   ```python
   from typing import Annotated
   from fastapi import Depends

   EmailSvc = Annotated[EmailService, Depends(get_email_service)]
   ```

3. Create `app/email/templates/` directory and `app/email/templates/base.html`:

   The base template uses table-based layout for email client compatibility. It defines three Jinja2 blocks: `title`, `content`, `footer`.

   ```html
   <!DOCTYPE html>
   <html lang="en">
   <head>
     <meta charset="UTF-8">
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <title>{% block title %}Bookstore{% endblock %}</title>
   </head>
   <body style="font-family: Arial, sans-serif; background-color: #f4f4f4; margin: 0; padding: 0;">
     <table width="100%" cellpadding="0" cellspacing="0" role="presentation">
       <tr>
         <td align="center">
           <table width="600" cellpadding="20" cellspacing="0"
                  style="background-color: #ffffff; margin: 30px auto;">
             <!-- Header -->
             <tr>
               <td style="background-color: #1a202c; color: #ffffff; text-align: center; padding: 20px;">
                 <h1 style="margin: 0; font-size: 24px;">Bookstore</h1>
               </td>
             </tr>
             <!-- Content -->
             <tr>
               <td style="padding: 30px 20px;">
                 {% block content %}{% endblock %}
               </td>
             </tr>
             <!-- Footer -->
             <tr>
               <td style="background-color: #f4f4f4; text-align: center; font-size: 12px; color: #718096; padding: 15px 20px;">
                 {% block footer %}
                 <p style="margin: 0;">You received this email because you have an account with Bookstore.</p>
                 {% endblock %}
               </td>
             </tr>
           </table>
         </td>
       </tr>
     </table>
   </body>
   </html>
   ```

   This base template is extended by concrete email templates in Phase 12 using `{% extends "base.html" %}` and `{% block content %}...{% endblock %}`.

   **Important notes:**
   - Do NOT register any router in `app/main.py` — the email module has no HTTP endpoints.
   - Do NOT create any Alembic migration — the email module has no database model.
   - Do NOT add any import in `app/db/base.py` — no model to register.
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && python -c "from app.email.service import EmailService, get_email_service, get_email_config, EmailSvc; svc = get_email_service(); print('EmailService OK:', type(svc).__name__); print('strip:', svc._strip_html('<p>Hello <b>World</b></p>'))"</automated>
  </verify>
  <done>
    - `app/email/__init__.py` exists (empty).
    - `app/email/service.py` exports `EmailService`, `get_email_service`, `get_email_config`, `EmailSvc`.
    - `EmailService` has `enqueue()`, `_send()`, `_strip_html()`, `_render_plain_text()` methods.
    - `enqueue()` calls `_render_plain_text()` and passes the result as `alternative_body` to `MessageSchema` with `multipart_subtype=MultipartSubtypeEnum.alternative`.
    - `get_email_service()` is `@lru_cache`-decorated.
    - `app/email/templates/base.html` renders with Jinja2 block inheritance (`title`, `content`, `footer`).
    - `_strip_html('<p>Hello <b>World</b></p>')` returns `'Hello World'`.
  </done>
</task>

</tasks>

<verification>
1. `poetry show fastapi-mail` confirms fastapi-mail is installed.
2. `poetry show blinker` confirms blinker (transitive dep) is installed.
3. `python -c "from app.core.config import get_settings; s = get_settings(); assert s.MAIL_SUPPRESS_SEND == 1"` passes.
4. `python -c "from app.email.service import get_email_service; svc = get_email_service(); assert svc.fm is not None"` passes.
5. `python -c "from jinja2 import Environment, FileSystemLoader; env = Environment(loader=FileSystemLoader('app/email/templates')); t = env.get_template('base.html'); print(t.render())"` renders without error.
6. Existing test suite still passes: `pytest tests/test_health.py -x` (no regressions from Settings change).
</verification>

<success_criteria>
- fastapi-mail installed and importable
- MAIL_* settings in config with safe defaults (SUPPRESS_SEND=1)
- EmailService class with enqueue() method that adds to BackgroundTasks
- _strip_html() generates plain-text from HTML
- enqueue() wires _strip_html() into the send path via _render_plain_text() and alternative_body
- base.html template renders with Jinja2 and supports block inheritance
- No existing tests broken
</success_criteria>

<output>
After completion, create `.planning/phases/09-email-infrastructure/09-01-SUMMARY.md`
</output>
