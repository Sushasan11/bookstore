---
phase: 10-admin-user-management
plan: 02
type: execute
wave: 2
depends_on:
  - 10-01
files_modified:
  - tests/test_admin_users.py
autonomous: true
requirements:
  - ADMN-01
  - ADMN-02
  - ADMN-03
  - ADMN-04
  - ADMN-05

must_haves:
  truths:
    - "Tests prove admin can list users with pagination metadata"
    - "Tests prove admin can filter users by role and active status"
    - "Tests prove admin can deactivate a regular user and all refresh tokens are revoked"
    - "Tests prove admin can reactivate a previously deactivated user"
    - "Tests prove deactivating an admin account is rejected with 403"
    - "Tests prove deactivated user cannot log in"
    - "Tests prove deactivated user's access token is rejected on protected endpoints"
    - "Tests prove deactivation and reactivation are idempotent"
  artifacts:
    - path: "tests/test_admin_users.py"
      provides: "Integration tests for all admin user management endpoints"
      min_lines: 150
  key_links:
    - from: "tests/test_admin_users.py"
      to: "/admin/users endpoints"
      via: "httpx AsyncClient HTTP calls"
      pattern: "client\\.(get|patch).*admin/users"
    - from: "tests/test_admin_users.py"
      to: "/auth/login"
      via: "Login attempt after deactivation to prove lockout"
      pattern: "client\\.post.*auth/login"
    - from: "tests/test_admin_users.py"
      to: "/cart"
      via: "GET /cart with deactivated user's token to prove ActiveUser lockout on non-admin routes"
      pattern: "client\\.get.*/cart"
---

<objective>
Create comprehensive integration tests for all admin user management endpoints, covering every requirement (ADMN-01 through ADMN-05) including pagination, filtering, deactivation with token revocation, reactivation, admin self-protection, immediate lockout verification, and idempotency.

Purpose: Prove all admin user management behaviors work correctly at the HTTP level, including edge cases and cross-cutting concerns (lockout enforcement).
Output: tests/test_admin_users.py with passing test suite covering all ADMN requirements.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-admin-user-management/10-CONTEXT.md
@.planning/phases/10-admin-user-management/10-RESEARCH.md
@.planning/phases/10-admin-user-management/10-01-SUMMARY.md

<interfaces>
<!-- Key types and contracts from Plan 01 that tests must verify. -->

From app/admin/schemas.py (created in Plan 01):
```python
class AdminUserResponse(BaseModel):
    id: int
    email: str
    full_name: str | None = None  # Always None until a future migration adds full_name column to User
    role: str
    is_active: bool
    created_at: datetime
    model_config = {"from_attributes": True}

class UserListResponse(BaseModel):
    items: list[AdminUserResponse]
    total_count: int
    page: int
    per_page: int
    total_pages: int
```

From app/admin/router.py (created in Plan 01):
```python
# GET /admin/users?page=1&per_page=20&role=user&is_active=false -> UserListResponse
# PATCH /admin/users/{user_id}/deactivate -> AdminUserResponse
# PATCH /admin/users/{user_id}/reactivate -> AdminUserResponse
```

From app/core/deps.py (modified in Plan 01):
```python
# get_active_user: DB lookup, 403 if user is None or not is_active
# ActiveUser: type alias for Annotated[dict, Depends(get_active_user)]
# AdminUser now chains through get_active_user (is_active enforced on admin routes)
# cart/orders/wishlist routers also use ActiveUser (migrated in Plan 01 Task 3)
```

Existing test fixture pattern (from tests/test_catalog.py):
```python
@pytest_asyncio.fixture
async def admin_headers(client: AsyncClient, db_session: AsyncSession) -> dict:
    repo = UserRepository(db_session)
    hashed = await hash_password("adminpass123")
    user = await repo.create(email="catalog_admin@example.com", hashed_password=hashed)
    await repo.set_role_admin(user.id)
    await db_session.flush()
    resp = await client.post("/auth/login", json={"email": "catalog_admin@example.com", "password": "adminpass123"})
    assert resp.status_code == 200
    return {"Authorization": f"Bearer {resp.json()['access_token']}"}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create admin user management integration tests</name>
  <files>tests/test_admin_users.py</files>
  <action>
Create `tests/test_admin_users.py` with comprehensive integration tests. Follow existing test patterns from `tests/test_catalog.py` and `tests/test_auth.py`.

**Fixtures:**

```python
import pytest
import pytest_asyncio
from httpx import AsyncClient
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.security import hash_password
from app.users.repository import UserRepository

@pytest_asyncio.fixture
async def admin_headers(client: AsyncClient, db_session: AsyncSession) -> dict:
    """Create an admin user and return auth headers."""
    repo = UserRepository(db_session)
    hashed = await hash_password("adminpass123")
    user = await repo.create(email="admin_mgmt@example.com", hashed_password=hashed)
    await repo.set_role_admin(user.id)
    await db_session.flush()
    resp = await client.post("/auth/login", json={"email": "admin_mgmt@example.com", "password": "adminpass123"})
    assert resp.status_code == 200
    return {"Authorization": f"Bearer {resp.json()['access_token']}"}

@pytest_asyncio.fixture
async def user_headers(client: AsyncClient, db_session: AsyncSession) -> dict:
    """Create a regular user and return auth headers."""
    repo = UserRepository(db_session)
    hashed = await hash_password("userpass123")
    user = await repo.create(email="regular_user@example.com", hashed_password=hashed)
    await db_session.flush()
    resp = await client.post("/auth/login", json={"email": "regular_user@example.com", "password": "userpass123"})
    assert resp.status_code == 200
    return {"Authorization": f"Bearer {resp.json()['access_token']}"}

async def _create_user(db_session: AsyncSession, email: str, *, is_admin: bool = False) -> int:
    """Helper to create a user directly via repository. Returns user ID."""
    repo = UserRepository(db_session)
    hashed = await hash_password("testpass123")
    user = await repo.create(email=email, hashed_password=hashed)
    if is_admin:
        await repo.set_role_admin(user.id)
    await db_session.flush()
    return user.id
```

**Test classes and cases (minimum):**

**class TestListUsers (ADMN-01, ADMN-02):**
1. `test_list_users_paginated` — GET /admin/users returns items list with total_count, page, per_page, total_pages. Create 3 users + 1 admin, verify total_count >= 4, items is a list of objects with id/email/full_name/role/is_active/created_at. Assert `full_name` is None for all users (no full_name column on User model yet).
2. `test_list_users_filter_by_role` — GET /admin/users?role=user returns only users with role="user". GET /admin/users?role=admin returns only admins.
3. `test_list_users_filter_by_active_status` — Create a deactivated user (via PATCH), then GET /admin/users?is_active=false returns only deactivated users.
4. `test_list_users_combined_filters` — GET /admin/users?role=user&is_active=true returns users matching both conditions.
5. `test_list_users_pagination_params` — GET /admin/users?page=1&per_page=2 returns exactly 2 items. Verify total_pages is correct (math.ceil(total/per_page)).
6. `test_list_users_non_admin_forbidden` — GET /admin/users with user_headers returns 403.
7. `test_list_users_unauthenticated` — GET /admin/users without auth returns 401.
8. `test_list_users_invalid_role_422` — GET /admin/users?role=invalid returns 422.

**class TestDeactivateUser (ADMN-03, ADMN-05):**
9. `test_deactivate_user_success` — PATCH /admin/users/{id}/deactivate returns 200 with AdminUserResponse where is_active=false.
10. `test_deactivate_revokes_refresh_tokens` — After deactivation, the user's POST /auth/refresh fails (token revoked).
11. `test_deactivate_blocks_login` — After deactivation, POST /auth/login with correct creds returns 403 "Account deactivated. Contact support."
12. `test_deactivate_blocks_access_token` — After deactivation, using the user's existing access token on GET /cart returns 403 "Account deactivated. Contact support." (cart routes use ActiveUser per Plan 01 Task 3).
13. `test_deactivate_admin_forbidden` — PATCH /admin/users/{admin_id}/deactivate returns 403 "Cannot deactivate admin accounts".
14. `test_deactivate_self_admin_forbidden` — Admin deactivating their own admin account returns 403.
15. `test_deactivate_idempotent` — Deactivating an already-deactivated user returns 200 with is_active=false.
16. `test_deactivate_nonexistent_user_404` — PATCH /admin/users/99999/deactivate returns 404.

**class TestReactivateUser (ADMN-04):**
17. `test_reactivate_user_success` — Deactivate then PATCH /admin/users/{id}/reactivate returns 200 with is_active=true.
18. `test_reactivate_requires_fresh_login` — After reactivation, the user can log in again (POST /auth/login returns 200).
19. `test_reactivate_idempotent` — Reactivating an already-active user returns 200 with is_active=true.
20. `test_reactivate_nonexistent_user_404` — PATCH /admin/users/99999/reactivate returns 404.

**Important test patterns:**
- Use `_create_user()` helper for users that won't need auth headers (test subjects)
- For deactivation lockout tests, first create user AND get their access token via login, then deactivate, then try to use the token
- Always assert response JSON structure matches AdminUserResponse/UserListResponse schemas
- Use unique email addresses per test to avoid conflicts (e.g., "deactivate_test@example.com")
- Each test should be self-contained: create its own test data, don't rely on other test state
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && python -m pytest tests/test_admin_users.py -x -v 2>&1 | tail -40</automated>
  </verify>
  <done>
    - tests/test_admin_users.py exists with at least 18 integration tests
    - TestListUsers: pagination, role filter, active status filter, combined filters, per_page, non-admin 403, unauthenticated 401
    - TestDeactivateUser: success, token revocation, login blocked, admin protection, self-protection, idempotent, 404
    - TestReactivateUser: success, fresh login works, idempotent, 404
    - All tests pass with pytest -x
    - Tests cover all 5 ADMN requirements
  </done>
</task>

</tasks>

<verification>
1. Full test run: `cd D:/Python/claude-test && python -m pytest tests/test_admin_users.py -x -v`
2. Test count: at least 18 tests in test_admin_users.py
3. Lint: `cd D:/Python/claude-test && ruff check tests/test_admin_users.py`
4. Format: `cd D:/Python/claude-test && ruff format --check tests/test_admin_users.py`
</verification>

<success_criteria>
- All tests in tests/test_admin_users.py pass
- Every ADMN requirement (01-05) has at least one test covering it
- Deactivation lockout (login blocked + access token rejected) is proven by tests
- Admin self-protection (403 on admin deactivation) is proven by tests
- Idempotency is proven for both deactivation and reactivation
- Pagination and filtering are proven with correct response envelope
- Code passes ruff check and ruff format
</success_criteria>

<output>
After completion, create `.planning/phases/10-admin-user-management/10-02-SUMMARY.md`
</output>
