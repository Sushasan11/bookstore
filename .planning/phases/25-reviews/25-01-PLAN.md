---
phase: 25-reviews
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/lib/reviews.ts
  - frontend/src/app/books/[id]/_components/StarSelector.tsx
  - frontend/src/app/books/[id]/_components/ReviewCard.tsx
  - frontend/src/components/ui/textarea.tsx
autonomous: true
requirements: [REVW-01, REVW-02]

must_haves:
  truths:
    - "lib/reviews.ts exports fetchReviews, createReview, updateReview, deleteReview API functions and a useReviews hook with create/update/delete mutations"
    - "StarSelector renders 5 clickable star buttons with hover preview and keyboard accessibility"
    - "ReviewCard displays a single review with star rating, author name, optional text, verified-purchase badge, and formatted date"
  artifacts:
    - path: "frontend/src/lib/reviews.ts"
      provides: "Reviews data layer with API functions and useReviews hook"
      exports: ["fetchReviews", "createReview", "updateReview", "deleteReview", "useReviews", "REVIEWS_KEY"]
    - path: "frontend/src/app/books/[id]/_components/StarSelector.tsx"
      provides: "Interactive 1-5 star rating picker"
      exports: ["StarSelector"]
    - path: "frontend/src/app/books/[id]/_components/ReviewCard.tsx"
      provides: "Single review display component"
      exports: ["ReviewCard"]
    - path: "frontend/src/components/ui/textarea.tsx"
      provides: "shadcn Textarea component"
      exports: ["Textarea"]
  key_links:
    - from: "frontend/src/lib/reviews.ts"
      to: "/books/{bookId}/reviews, /reviews/{reviewId}"
      via: "apiFetch calls with Authorization header"
      pattern: "apiFetch.*reviews"
    - from: "frontend/src/lib/reviews.ts"
      to: "api.generated.ts types"
      via: "import type { components }"
      pattern: "components.*schemas.*Review"
---

<objective>
Create the reviews data layer (API functions + TanStack Query hook) and foundational UI components (StarSelector, ReviewCard) for Phase 25. Install the shadcn Textarea component needed by the ReviewForm in Plan 25-02.

Purpose: Establish the reviews data layer and reusable components that Plan 25-02 will compose into the ReviewsSection and ReviewForm on the book detail page.
Output: `lib/reviews.ts` with all review API functions and `useReviews` hook, `StarSelector.tsx` interactive star picker, `ReviewCard.tsx` review display component, `textarea.tsx` shadcn component installed.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-reviews/25-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->
<!-- Executor should use these directly — no codebase exploration needed. -->

From frontend/src/lib/api.ts:
```typescript
export class ApiError extends Error {
  constructor(message: string, public status: number, public detail?: string, public data?: unknown) {}
}
export async function apiFetch<T>(path: string, options?: RequestInit): Promise<T>
```

From frontend/src/types/api.generated.ts (review types):
```typescript
ReviewCreate: { rating: number; text?: string | null }
ReviewUpdate: { rating?: number | null; text?: string | null }
ReviewResponse: {
  id: number; book_id: number; user_id: number; rating: number;
  text: string | null; verified_purchase: boolean;
  created_at: string; updated_at: string;
  author: { user_id: number; display_name: string; avatar_url: string | null };
  book: { book_id: number; title: string; cover_image_url: string | null };
}
ReviewListResponse: { items: ReviewResponse[]; total: number; page: number; size: number }
```

From frontend/src/auth.ts (session shape):
```typescript
// Client-side via useSession():
session.accessToken  // FastAPI JWT string
session.user.id      // FastAPI user ID as string (from JWT sub claim)
session.user.role    // "user" | "admin"
```

From frontend/src/lib/wishlist.ts (canonical hook pattern):
```typescript
// Pattern to follow — same structure for useReviews:
export const WISHLIST_KEY = ['wishlist'] as const
export async function fetchWishlist(accessToken: string): Promise<WishlistResponse> { ... }
export function useWishlist() {
  const { data: session } = useSession()
  const accessToken = session?.accessToken ?? ''
  const queryClient = useQueryClient()
  // useQuery + useMutation with toast + invalidateQueries
}
```

From frontend/src/app/books/[id]/_components/RatingDisplay.tsx (existing star rendering):
```typescript
// Uses Unicode ★ with text-yellow-500 for filled, text-muted-foreground for empty
<span className={filled ? 'text-yellow-500' : 'text-muted-foreground'}>★</span>
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install shadcn Textarea and create lib/reviews.ts</name>
  <files>
    frontend/src/components/ui/textarea.tsx
    frontend/src/lib/reviews.ts
  </files>
  <action>
**Step 1:** Install the shadcn Textarea component:
```bash
cd frontend && npx shadcn@latest add textarea --yes
```

**Step 2:** Create `frontend/src/lib/reviews.ts` — the reviews data layer following the established hook pattern from `wishlist.ts` and `prebook.ts`.

The file must be a `'use client'` module exporting:

1. **Type aliases** extracted from `api.generated.ts`:
   - `ReviewResponse`, `ReviewListResponse`, `ReviewCreate`, `ReviewUpdate`

2. **Cache key:** `REVIEWS_KEY = (bookId: number) => ['reviews', bookId] as const` — parameterized by bookId (unlike WISHLIST_KEY which is global, reviews are per-book).

3. **API functions** (all use `apiFetch` from `@/lib/api`):
   - `fetchReviews(bookId: number): Promise<ReviewListResponse>` — calls `GET /books/${bookId}/reviews?size=50` (no auth needed, public endpoint). Use `size=50` to fetch all reviews for a book without pagination UI.
   - `createReview(accessToken: string, bookId: number, body: ReviewCreate): Promise<ReviewResponse>` — calls `POST /books/${bookId}/reviews` with Authorization header and JSON body.
   - `updateReview(accessToken: string, reviewId: number, body: ReviewUpdate): Promise<ReviewResponse>` — calls `PATCH /reviews/${reviewId}` with Authorization header. IMPORTANT: only include fields in body that actually changed (see Pitfall 4 in research — partial update semantics).
   - `deleteReview(accessToken: string, reviewId: number): Promise<void>` — calls `DELETE /reviews/${reviewId}` with Authorization header. Returns void (204 No Content handled by apiFetch).

4. **`useReviews(bookId: number)` hook** returning:
   - `reviewsQuery` — TanStack `useQuery` with `queryKey: REVIEWS_KEY(bookId)`, `queryFn: () => fetchReviews(bookId)`, `staleTime: 30_000`. Note: this query does NOT require auth — reviews are public. Do NOT add an `enabled: !!accessToken` guard. Always fetch.
   - `createMutation` — `useMutation` calling `createReview`. On success: `toast.success('Review submitted!')` + `queryClient.invalidateQueries({ queryKey: REVIEWS_KEY(bookId) })`. On error: check `ApiError.status` — 403 means "You must purchase this book before reviewing it" (toast.error), 409 means DUPLICATE_REVIEW (invalidate queries + `toast.info('Showing your existing review — you can edit it below')`), otherwise generic "Failed to submit review" (toast.error).
   - `updateMutation` — `useMutation` calling `updateReview`. On success: `toast.success('Review updated!')` + invalidate. On error: `toast.error('Failed to update review')`.
   - `deleteMutation` — `useMutation` calling `deleteReview`. On success: `toast.success('Review deleted')` + invalidate. On error: `toast.error('Failed to delete review')`.
   - `myReview` — derived from `reviewsQuery.data`: find the current user's review by comparing `review.author.user_id === Number(session?.user?.id)`. Returns `ReviewResponse | null`. Returns `null` if no session or no matching review. Use `author.user_id` (number) not `user_id` (also number but `author.user_id` is the canonical path from the nested object).

The hook should get `session` from `useSession()`, extract `accessToken = session?.accessToken ?? ''`, and pass it to mutation functions. The `queryClient` comes from `useQueryClient()`.

Import `ApiError` from `@/lib/api` for error type checking in mutation handlers. Import `toast` from `sonner`. Import `useRouter` from `next/navigation` for potential login redirect (but do NOT add redirect logic in the hook itself — that belongs in the form component).
  </action>
  <verify>
    <automated>cd frontend && npx tsc --noEmit</automated>
  </verify>
  <done>
    - `frontend/src/components/ui/textarea.tsx` exists (shadcn installed)
    - `frontend/src/lib/reviews.ts` exports fetchReviews, createReview, updateReview, deleteReview, useReviews, REVIEWS_KEY
    - TypeScript compiles with zero errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create StarSelector and ReviewCard components</name>
  <files>
    frontend/src/app/books/[id]/_components/StarSelector.tsx
    frontend/src/app/books/[id]/_components/ReviewCard.tsx
  </files>
  <action>
**Step 1:** Create `frontend/src/app/books/[id]/_components/StarSelector.tsx` — a `'use client'` interactive 1-5 star rating picker.

Props interface:
```typescript
interface StarSelectorProps {
  value: number          // 1-5, 0 = unset
  onChange: (rating: number) => void
  disabled?: boolean
}
```

Implementation:
- Use `useState` for `hovered` (number, default 0). Display state = `hovered || value`.
- Render 5 `<button type="button">` elements (NOT spans — buttons are keyboard accessible per Pitfall 6).
- Each button: `onClick={() => onChange(star)}`, `onMouseEnter={() => setHovered(star)}`, `onMouseLeave={() => setHovered(0)}`.
- `disabled` prop forwarded to each button.
- `aria-label={`${star} star${star !== 1 ? 's' : ''}`}` on each button for screen readers.
- Wrap in `<div className="flex gap-1" role="group" aria-label="Rating">`.
- Star character: `★` (Unicode, matching existing `RatingDisplay.tsx` aesthetic).
- Filled style: `text-yellow-500` (star <= display), empty: `text-muted-foreground`.
- Size: `text-2xl` for comfortable click targets.
- Transition: `transition-colors` for smooth hover feedback.
- `cursor-pointer` when enabled, `cursor-not-allowed opacity-50` when disabled.

Export: `StarSelector` (named export).

**Step 2:** Create `frontend/src/app/books/[id]/_components/ReviewCard.tsx` — a presentational component displaying a single review.

Props interface (import `ReviewResponse` type from `@/types/api.generated`):
```typescript
interface ReviewCardProps {
  review: components['schemas']['ReviewResponse']
  isOwn: boolean       // true if this review belongs to the current user
  onEdit?: () => void  // called when user clicks "Edit" (Plan 25-02 will wire this)
  onDelete?: () => void // called when user clicks "Delete" (Plan 25-02 will wire this)
}
```

Implementation:
- Renders inside a `<div>` with `border-b py-4` styling (simple divider between reviews, no Card component needed — reviews are a list, not standalone cards).
- **Header row:** author display name (bold), verified-purchase badge (if `review.verified_purchase` is true, show a small green "Verified Purchase" badge using the Badge component from shadcn), and formatted date (top-right or after author).
- **Star rating row:** Render `review.rating` filled stars + remaining empty stars using the same `★` Unicode character and `text-yellow-500`/`text-muted-foreground` classes from `RatingDisplay.tsx`. Use a simple inline map — no need to import RatingDisplay (it has half-star logic we don't need for individual reviews which are always integers).
- **Review text:** If `review.text` is not null, render it in `<p className="text-muted-foreground mt-2">`.
- **Action buttons:** If `isOwn` is true AND `onEdit`/`onDelete` are provided, render small icon buttons (Pencil and Trash2 from lucide-react) in the header row. These are wired by the parent component (ReviewsSection) in Plan 25-02.
- **Date formatting:** Use a `formatReviewDate` helper (same pattern as BookDetailHero):
```typescript
function formatReviewDate(dateStr: string): string {
  try {
    return new Date(dateStr).toLocaleDateString(undefined, {
      year: 'numeric', month: 'long', day: 'numeric',
    })
  } catch {
    return dateStr
  }
}
```

Import `Badge` from `@/components/ui/badge`. Import `Pencil`, `Trash2` from `lucide-react`. Import `Button` from `@/components/ui/button`.

Export: `ReviewCard` (named export).
  </action>
  <verify>
    <automated>cd frontend && npx tsc --noEmit && npm run build</automated>
  </verify>
  <done>
    - `StarSelector` renders 5 interactive star buttons with hover and keyboard support
    - `ReviewCard` displays author, rating stars, text, date, verified-purchase badge, and conditional edit/delete buttons
    - TypeScript compiles with zero errors
    - Production build succeeds
  </done>
</task>

</tasks>

<verification>
1. `cd frontend && npx tsc --noEmit` — zero TypeScript errors
2. `cd frontend && npm run build` — production build succeeds
3. `frontend/src/components/ui/textarea.tsx` exists (shadcn Textarea installed)
4. `frontend/src/lib/reviews.ts` exports all API functions and useReviews hook
5. `frontend/src/app/books/[id]/_components/StarSelector.tsx` exists with StarSelector export
6. `frontend/src/app/books/[id]/_components/ReviewCard.tsx` exists with ReviewCard export
</verification>

<success_criteria>
- All 4 files created and TypeScript-clean
- useReviews hook handles create/update/delete mutations with proper error handling (403 purchase gate, 409 duplicate)
- StarSelector is keyboard accessible (button elements, aria-labels)
- ReviewCard handles all display states (with/without text, verified purchase, own review actions)
- Production build passes
</success_criteria>

<output>
After completion, create `.planning/phases/25-reviews/25-01-SUMMARY.md`
</output>
