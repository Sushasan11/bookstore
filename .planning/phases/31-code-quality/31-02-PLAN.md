---
phase: 31-code-quality
plan: 02
type: execute
wave: 2
depends_on:
  - 31-01
files_modified:
  - backend/app/admin/analytics_repository.py
  - backend/app/admin/analytics_router.py
  - backend/app/admin/analytics_service.py
  - frontend/src/lib/admin.ts
  - frontend/src/app/admin/overview/page.tsx
  - frontend/src/app/admin/sales/page.tsx
autonomous: true
requirements:
  - ANLY-01

must_haves:
  truths:
    - "Selecting Today, This Week, or This Month in the period selector updates the top-sellers table to show data for that period only"
    - "The overview page's Top 5 Best Sellers mini-table filters by the selected period"
    - "The sales page's Top Sellers table filters by the selected period"
    - "When no period is passed, the backend returns all-time data (backward compatible)"
  artifacts:
    - path: "backend/app/admin/analytics_repository.py"
      provides: "top_books method with optional period_start/period_end filtering"
      contains: "period_start"
    - path: "backend/app/admin/analytics_router.py"
      provides: "top-books endpoint with optional period query param"
      contains: "period"
    - path: "frontend/src/lib/admin.ts"
      provides: "fetchTopBooks with period parameter, adminKeys.sales.topBooks with period in key"
      contains: "period"
  key_links:
    - from: "frontend/src/app/admin/sales/page.tsx"
      to: "frontend/src/lib/admin.ts"
      via: "fetchTopBooks(accessToken, limit, sortBy, period)"
      pattern: "fetchTopBooks.*period"
    - from: "frontend/src/lib/admin.ts"
      to: "backend/app/admin/analytics_router.py"
      via: "GET /admin/analytics/sales/top-books?period=..."
      pattern: "period=.*\\$\\{period\\}"
    - from: "backend/app/admin/analytics_router.py"
      to: "backend/app/admin/analytics_repository.py"
      via: "repo.top_books(period_start=..., period_end=...)"
      pattern: "top_books.*period_start"
---

<objective>
Make the top-sellers analytics table respect the user's period selection (today/week/month) by adding period filtering to the backend endpoint and wiring it through the frontend query layer.

Purpose: Currently the top-sellers table shows all-time data regardless of the period selector state. This plan threads the period parameter from UI through query key, fetch function, API endpoint, and repository SQL query (ANLY-01).

Output: Backend endpoint accepts optional `period` parameter, repository filters by date range, frontend passes period through React Query, tables update when period changes.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-code-quality/31-CONTEXT.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->
<!-- Executor should use these directly — no codebase exploration needed. -->

From backend/app/admin/analytics_service.py (lines 9-33) — _period_bounds helper to reuse:
```python
def _period_bounds(now: datetime, period: str) -> tuple[datetime, datetime]:
    """Return (start, end) for the current partial period."""
    if period == "today":
        start = now.replace(hour=0, minute=0, second=0, microsecond=0)
    elif period == "week":
        monday = now - timedelta(days=now.weekday())
        start = monday.replace(hour=0, minute=0, second=0, microsecond=0)
    elif period == "month":
        start = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
    else:
        raise ValueError(f"Unknown period: {period!r}.")
    return start, now
```

From backend/app/admin/analytics_repository.py (lines 54-92) — current top_books method:
```python
async def top_books(self, *, sort_by: str, limit: int = 10) -> list[dict]:
    revenue_col = func.sum(OrderItem.unit_price * OrderItem.quantity).label("total_revenue")
    volume_col = func.sum(OrderItem.quantity).label("units_sold")
    order_col = revenue_col if sort_by == "revenue" else volume_col
    stmt = (
        select(OrderItem.book_id, Book.title, Book.author, revenue_col, volume_col)
        .join(Order, OrderItem.order_id == Order.id)
        .join(Book, OrderItem.book_id == Book.id)
        .where(Order.status == OrderStatus.CONFIRMED, OrderItem.book_id.is_not(None))
        .group_by(OrderItem.book_id, Book.title, Book.author)
        .order_by(desc(order_col))
        .limit(limit)
    )
    result = await self._db.execute(stmt)
    return [row._asdict() for row in result.all()]
```

From backend/app/admin/analytics_router.py (lines 48-66) — current get_top_books endpoint:
```python
@router.get("/sales/top-books", response_model=TopBooksResponse)
async def get_top_books(
    db: DbSession,
    _admin: AdminUser,
    sort_by: str = Query("revenue", pattern="^(revenue|volume)$"),
    limit: int = Query(10, ge=1, le=50),
) -> TopBooksResponse:
    repo = AnalyticsRepository(db)
    books = await repo.top_books(sort_by=sort_by, limit=limit)
    return TopBooksResponse(sort_by=sort_by, items=books)
```

From frontend/src/lib/admin.ts — current fetchTopBooks and adminKeys:
```typescript
// Query key (line 60-61):
topBooks: (limit: number, sort_by: 'revenue' | 'volume' = 'revenue') =>
  ['admin', 'sales', 'top-books', limit, sort_by] as const,

// Fetch function (lines 110-119):
export async function fetchTopBooks(
  accessToken: string,
  limit: number = 5,
  sort_by: 'revenue' | 'volume' = 'revenue'
): Promise<TopBooksResponse> {
  return apiFetch<TopBooksResponse>(
    `/admin/analytics/sales/top-books?sort_by=${sort_by}&limit=${limit}`,
    { headers: { Authorization: `Bearer ${accessToken}` } }
  )
}
```

From frontend/src/app/admin/overview/page.tsx — topBooksQuery usage (lines 70-75):
```typescript
const topBooksQuery = useQuery({
  queryKey: adminKeys.sales.topBooks(5, 'revenue'),
  queryFn: () => fetchTopBooks(accessToken, 5, 'revenue'),
  enabled: !!accessToken,
  staleTime: 60_000,
})
```

From frontend/src/app/admin/sales/page.tsx — topBooksQuery usage (lines 86-91):
```typescript
const topBooksQuery = useQuery({
  queryKey: adminKeys.sales.topBooks(limit, sortBy),
  queryFn: () => fetchTopBooks(accessToken, limit, sortBy),
  enabled: !!accessToken,
  staleTime: 60_000,
})
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add period filtering to backend top-books endpoint</name>
  <files>backend/app/admin/analytics_repository.py, backend/app/admin/analytics_router.py, backend/app/admin/analytics_service.py</files>
  <action>
**analytics_repository.py — Add optional period filtering to top_books:**
- Add `period_start: datetime | None = None` and `period_end: datetime | None = None` keyword parameters to `top_books()`.
- When both are provided, add `.where(Order.created_at >= period_start, Order.created_at < period_end)` to the existing query's `.where()` clause.
- When neither is provided, the query remains unchanged (all-time data, backward compatible).
- Import `datetime` type is already imported at line 2.

The updated method signature:
```python
async def top_books(
    self,
    *,
    sort_by: str,
    limit: int = 10,
    period_start: datetime | None = None,
    period_end: datetime | None = None,
) -> list[dict]:
```

Add the period conditions after the existing `.where()`:
```python
if period_start is not None and period_end is not None:
    stmt = stmt.where(
        Order.created_at >= period_start,
        Order.created_at < period_end,
    )
```

**analytics_router.py — Add optional period query parameter:**
- Add `period: str | None = Query(None, pattern="^(today|week|month)$")` parameter to `get_top_books`.
- When `period` is not None, compute bounds using `_period_bounds` from `analytics_service.py` and pass to `repo.top_books()`.
- Import `_period_bounds` from `app.admin.analytics_service` and `datetime, timezone` from `datetime`.
- Update the function body:

```python
from datetime import datetime, timezone
from app.admin.analytics_service import _period_bounds

# ... inside get_top_books:
period_start = None
period_end = None
if period is not None:
    period_start, period_end = _period_bounds(datetime.now(timezone.utc), period)

books = await repo.top_books(
    sort_by=sort_by, limit=limit,
    period_start=period_start, period_end=period_end,
)
```

**analytics_service.py — No changes needed.** The `_period_bounds` function is already module-level and can be imported directly by the router. No service method wrapping is needed since the router calls the repository directly for top_books (same as the current pattern).
  </action>
  <verify>
    <automated>cd backend && python -c "from app.admin.analytics_router import get_top_books; print('OK')" 2>&1</automated>
  </verify>
  <done>Backend /admin/analytics/sales/top-books endpoint accepts optional ?period=today|week|month parameter; when period is set, results are filtered to that time range; when omitted, returns all-time data (backward compatible)</done>
</task>

<task type="auto">
  <name>Task 2: Wire frontend to pass period through query key and fetch function</name>
  <files>frontend/src/lib/admin.ts, frontend/src/app/admin/overview/page.tsx, frontend/src/app/admin/sales/page.tsx</files>
  <action>
**admin.ts — Update adminKeys.sales.topBooks and fetchTopBooks:**

Update the query key factory to include period (line 60-61):
```typescript
topBooks: (limit: number, sort_by: 'revenue' | 'volume' = 'revenue', period?: string) =>
  ['admin', 'sales', 'top-books', limit, sort_by, period] as const,
```

Update fetchTopBooks to accept and pass optional period (lines 110-119):
```typescript
export async function fetchTopBooks(
  accessToken: string,
  limit: number = 5,
  sort_by: 'revenue' | 'volume' = 'revenue',
  period?: string
): Promise<TopBooksResponse> {
  const params = new URLSearchParams({ sort_by, limit: String(limit) })
  if (period) params.set('period', period)
  return apiFetch<TopBooksResponse>(
    `/admin/analytics/sales/top-books?${params}`,
    { headers: { Authorization: `Bearer ${accessToken}` } }
  )
}
```

**overview/page.tsx — Pass period to topBooksQuery:**

Update the topBooksQuery (around lines 70-75) to include `period` in both queryKey and queryFn:
```typescript
const topBooksQuery = useQuery({
  queryKey: adminKeys.sales.topBooks(5, 'revenue', period),
  queryFn: () => fetchTopBooks(accessToken, 5, 'revenue', period),
  enabled: !!accessToken,
  staleTime: 60_000,
})
```

React Query will automatically refetch when `period` state changes because the query key includes it. Standard loading skeleton already handles the refetch state.

**sales/page.tsx — Pass period to topBooksQuery:**

Update the topBooksQuery (around lines 86-91) to include `period` in both queryKey and queryFn:
```typescript
const topBooksQuery = useQuery({
  queryKey: adminKeys.sales.topBooks(limit, sortBy, period),
  queryFn: () => fetchTopBooks(accessToken, limit, sortBy, period),
  enabled: !!accessToken,
  staleTime: 60_000,
})
```

Same pattern — React Query auto-refetches on period change via query key.
  </action>
  <verify>
    <automated>cd frontend && npx tsc --noEmit --pretty 2>&1 | head -30</automated>
  </verify>
  <done>Period selector changes trigger top-sellers table refetch on both overview and sales pages; query keys include period for proper cache separation; fetchTopBooks sends period as query parameter to backend; TypeScript compiles cleanly</done>
</task>

</tasks>

<verification>
1. `cd frontend && npx tsc --noEmit` exits with 0 — no type errors
2. `grep -n "period" backend/app/admin/analytics_router.py` shows period parameter on get_top_books
3. `grep -n "period_start" backend/app/admin/analytics_repository.py` shows period filtering in top_books
4. `grep -n "period" frontend/src/lib/admin.ts` shows period in topBooks key factory and fetchTopBooks
5. `grep -n "period" frontend/src/app/admin/overview/page.tsx` shows period passed to topBooksQuery
6. `grep -n "period" frontend/src/app/admin/sales/page.tsx` shows period passed to topBooksQuery
7. Backend endpoint with no period param still works (backward compatible): `curl -s "http://localhost:8000/admin/analytics/sales/top-books?sort_by=revenue&limit=5"` returns valid JSON
</verification>

<success_criteria>
- Top-sellers table on both overview and sales pages updates when the user selects a different period
- Backend /admin/analytics/sales/top-books accepts optional period=today|week|month query parameter
- When period is set, only CONFIRMED orders within that period are counted
- When period is omitted, all-time data is returned (backward compatible)
- React Query cache keys include period for proper data separation
- TypeScript and Python both compile/import without errors
</success_criteria>

<output>
After completion, create `.planning/phases/31-code-quality/31-02-SUMMARY.md`
</output>
