---
phase: 07-orders
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/orders/models.py
  - app/orders/schemas.py
  - app/orders/repository.py
  - app/orders/service.py
  - app/orders/router.py
  - alembic/versions/d4e5f6a7b8c9_create_orders_and_order_items.py
  - alembic/env.py
  - app/main.py
autonomous: true
requirements:
  - COMM-03
  - COMM-04
  - COMM-05
  - ENGM-06

must_haves:
  truths:
    - "POST /orders/checkout creates an order, decrements book stock, and clears the cart in a single transaction"
    - "Concurrent checkouts for the same book cannot result in negative stock (SELECT FOR UPDATE in ascending ID order)"
    - "Payment failure returns error and preserves cart — no order created, no stock decremented"
    - "Checkout with empty cart returns 422 ORDER_CART_EMPTY"
    - "Checkout with insufficient stock returns 409 ORDER_INSUFFICIENT_STOCK listing which items are short"
    - "GET /orders returns the authenticated user's order history with line items"
    - "GET /orders/{id} returns order detail with items and unit_price snapshot"
    - "GET /admin/orders returns all orders (admin only)"
    - "Order items store unit_price at time of purchase, not current book price"
  artifacts:
    - path: "app/orders/models.py"
      provides: "Order and OrderItem models with OrderStatus StrEnum"
      contains: "class Order"
    - path: "app/orders/schemas.py"
      provides: "CheckoutRequest, OrderItemResponse, OrderResponse schemas"
      contains: "class OrderResponse"
    - path: "app/orders/repository.py"
      provides: "OrderRepository with lock_books, create_order, list_for_user, list_all"
      contains: "with_for_update"
    - path: "app/orders/service.py"
      provides: "OrderService with checkout orchestration and MockPaymentService"
      contains: "class OrderService"
    - path: "app/orders/router.py"
      provides: "POST /orders/checkout, GET /orders, GET /orders/{id}, GET /admin/orders"
      exports: ["router", "admin_router"]
    - path: "alembic/versions/d4e5f6a7b8c9_create_orders_and_order_items.py"
      provides: "Migration creating orders and order_items tables"
      contains: "create_table"
  key_links:
    - from: "app/orders/service.py"
      to: "app/orders/repository.py"
      via: "OrderRepository.lock_books() SELECT FOR UPDATE"
      pattern: "lock_books"
    - from: "app/orders/service.py"
      to: "app/cart/repository.py"
      via: "CartRepository.get_with_items() for cart loading"
      pattern: "get_with_items"
    - from: "app/orders/router.py"
      to: "app/orders/service.py"
      via: "_make_service factory pattern"
      pattern: "_make_service"
    - from: "app/main.py"
      to: "app/orders/router.py"
      via: "include_router for both orders_router and orders_admin_router"
      pattern: "include_router.*orders"
---

<objective>
Full orders vertical slice — Order/OrderItem models, Alembic migration, Pydantic schemas, OrderRepository with SELECT FOR UPDATE stock locking, MockPaymentService, OrderService with single-transaction checkout orchestration, and all 4 REST endpoints (POST /orders/checkout, GET /orders, GET /orders/{id}, GET /admin/orders).

Purpose: Deliver the complete checkout-to-order-history feature so users can convert their cart into confirmed orders and review past purchases.
Output: Working orders domain with all endpoints registered in the FastAPI app, ready for integration testing.
</objective>

<execution_context>
@C:/Users/Sushasan/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Sushasan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/07-orders/07-CONTEXT.md
@.planning/phases/07-orders/07-RESEARCH.md
@.planning/phases/06-cart/06-01-SUMMARY.md

@app/cart/models.py
@app/cart/repository.py
@app/cart/service.py
@app/cart/router.py
@app/cart/schemas.py
@app/core/deps.py
@app/core/exceptions.py
@app/main.py
@alembic/env.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Order/OrderItem models, OrderStatus enum, and Alembic migration</name>
  <files>
    app/orders/models.py
    alembic/versions/d4e5f6a7b8c9_create_orders_and_order_items.py
    alembic/env.py
  </files>
  <action>
**app/orders/models.py** — Create Order and OrderItem SQLAlchemy models:

1. `OrderStatus(enum.StrEnum)` with values `CONFIRMED = "confirmed"` and `PAYMENT_FAILED = "payment_failed"`.

2. `Order` model (`__tablename__ = "orders"`):
   - `id: Mapped[int]` primary key
   - `user_id: Mapped[int]` FK to `users.id` with `ondelete="CASCADE"`, `nullable=False`, `index=True`
   - `status: Mapped[OrderStatus]` using `SAEnum(OrderStatus, name="orderstatus")`, `nullable=False`, default `OrderStatus.CONFIRMED`
   - `created_at: Mapped[datetime]` with `DateTime(timezone=True)`, `server_default=func.now()`, `nullable=False`
   - `items: Mapped[list[OrderItem]]` relationship with `back_populates="order"`, `cascade="all, delete-orphan"`

3. `OrderItem` model (`__tablename__ = "order_items"`):
   - `id: Mapped[int]` primary key
   - `order_id: Mapped[int]` FK to `orders.id` with `ondelete="CASCADE"`, `nullable=False`, `index=True`
   - `book_id: Mapped[int | None]` FK to `books.id` with `ondelete="SET NULL"`, `nullable=True`, `index=True` — preserves order history when book is deleted from catalog
   - `quantity: Mapped[int]` using `Integer`, `nullable=False`
   - `unit_price: Mapped[Decimal]` using `Numeric(10, 2)`, `nullable=False` — price snapshot at time of purchase
   - `order: Mapped[Order]` relationship with `back_populates="items"`
   - `book: Mapped[Book | None]` relationship (no back_populates, read-only join for display)

Use `from __future__ import annotations` and `TYPE_CHECKING` guard for `Book` import (same pattern as `app/cart/models.py`). Import `Base` from `app.db.base`.

**alembic/versions/d4e5f6a7b8c9_create_orders_and_order_items.py** — Hand-written migration:
- `revision = "d4e5f6a7b8c9"`, `down_revision = "b2c3d4e5f6a7"` (chains off cart migration)
- `upgrade()`: Create `orders` table with columns (id, user_id, status as `sa.Enum("confirmed", "payment_failed", name="orderstatus")` with `server_default="confirmed"`, created_at with `server_default=sa.text("now()")`), FK to users, PK, then `create_index("ix_orders_user_id", "orders", ["user_id"])`. Then create `order_items` table with columns (id, order_id, book_id nullable, quantity, unit_price as `Numeric(10,2)`), FK to orders (CASCADE), FK to books (SET NULL), PK, then create indexes `ix_order_items_order_id` and `ix_order_items_book_id`.
- `downgrade()`: Drop indexes, drop `order_items`, drop index on orders, drop `orders`, then `op.execute("DROP TYPE IF EXISTS orderstatus")` to clean up the PostgreSQL enum type.
- Include proper Alembic boilerplate: `from typing import Sequence, Union`, `branch_labels`, `depends_on`, `Revision`, `revision`, `down_revision` variables.

**alembic/env.py** — Add Order and OrderItem model imports:
- Add `from app.orders.models import Order, OrderItem  # noqa: F401` after the existing cart model import line. Keep alphabetical order (books, cart, orders, users).
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && poetry run ruff check app/orders/models.py alembic/versions/d4e5f6a7b8c9_create_orders_and_order_items.py alembic/env.py && poetry run ruff format --check app/orders/models.py alembic/versions/d4e5f6a7b8c9_create_orders_and_order_items.py alembic/env.py</automated>
    <manual>Verify models define Order and OrderItem with correct columns, migration chains off b2c3d4e5f6a7</manual>
  </verify>
  <done>Order and OrderItem models exist with OrderStatus StrEnum, migration creates both tables with correct FKs/indexes/constraints, env.py imports new models for Alembic discovery</done>
</task>

<task type="auto">
  <name>Task 2: Schemas, repository, service (with checkout + MockPayment), router, and main.py registration</name>
  <files>
    app/orders/schemas.py
    app/orders/repository.py
    app/orders/service.py
    app/orders/router.py
    app/main.py
  </files>
  <action>
**app/orders/schemas.py** — Create Pydantic schemas:

1. `CheckoutRequest(BaseModel)`: `force_payment_failure: bool = False` — test-friendly trigger for simulating payment decline.

2. `OrderItemBookSummary(BaseModel)`: `id: int`, `title: str`, `author: str`. `model_config = {"from_attributes": True}`. Minimal book info embedded in order item responses.

3. `OrderItemResponse(BaseModel)`: `id: int`, `book_id: int | None`, `quantity: int`, `unit_price: Decimal`, `book: OrderItemBookSummary | None` (None if book deleted from catalog). `model_config = {"from_attributes": True}`.

4. `OrderResponse(BaseModel)`: `id: int`, `status: str`, `created_at: datetime`, `items: list[OrderItemResponse]`. Add `@computed_field` / `@property` for `total_price -> Decimal` that returns `sum(i.unit_price * i.quantity for i in self.items) or Decimal("0")`. `model_config = {"from_attributes": True}`.

5. `InsufficientStockItem(BaseModel)`: `book_id: int`, `title: str`, `requested: int`, `available: int`. Used in the error response for stock failures.

**app/orders/repository.py** — Create OrderRepository:

Constructor takes `AsyncSession`. Methods:

1. `lock_books(book_ids: list[int]) -> list[Book]`: Execute `select(Book).where(Book.id.in_(book_ids)).order_by(Book.id).with_for_update()`. Book IDs MUST already be sorted ascending by the caller (deadlock prevention). Returns list of locked Book rows.

2. `create_order(user_id: int, cart_items: list[CartItem], book_map: dict[int, Book]) -> Order`: Create `Order(user_id=user_id, status=OrderStatus.CONFIRMED)`, `session.add(order)`, `await session.flush()` to get `order.id`. Then for each cart item: create `OrderItem(order_id=order.id, book_id=item.book_id, quantity=item.quantity, unit_price=book_map[item.book_id].price)`, `session.add(oi)`, and decrement `book_map[item.book_id].stock_quantity -= item.quantity`. After loop: `await session.flush()`. Then `await session.refresh(order, ["items"])` and for each `item in order.items: await session.refresh(item, ["book"])` to eagerly load relationships for response serialization. Return order.

3. `get_by_id_for_user(order_id: int, user_id: int) -> Order | None`: `select(Order).where(Order.id == order_id, Order.user_id == user_id).options(selectinload(Order.items).selectinload(OrderItem.book))`.

4. `list_for_user(user_id: int) -> list[Order]`: `select(Order).where(Order.user_id == user_id).order_by(Order.created_at.desc()).options(selectinload(Order.items).selectinload(OrderItem.book))`.

5. `list_all() -> list[Order]`: `select(Order).order_by(Order.created_at.desc()).options(selectinload(Order.items).selectinload(OrderItem.book))`.

Import Book from `app.books.models`, CartItem from `app.cart.models`. Import `select` from `sqlalchemy`, `selectinload` from `sqlalchemy.orm`, `AsyncSession` from `sqlalchemy.ext.asyncio`.

**app/orders/service.py** — Create MockPaymentService and OrderService:

`MockPaymentService`:
- `async def charge(*, force_fail: bool = False) -> bool`: If `force_fail`, return `False`. Otherwise `return random.random() > 0.10` (90% success rate). Import `random` at top.

`OrderService`:
- Constructor takes `order_repo: OrderRepository`, `cart_repo: CartRepository`, `payment_service: MockPaymentService`.
- `async def checkout(user_id: int, request: CheckoutRequest) -> Order`:
  1. Load cart via `self.cart_repo.get_with_items(user_id)`. If no cart or no items, raise `AppError(422, "Cart is empty", "ORDER_CART_EMPTY")`.
  2. Sort book IDs ascending: `book_ids = sorted(item.book_id for item in cart.items)`.
  3. Lock books: `books = await self.order_repo.lock_books(book_ids)`. Build `book_map = {b.id: b for b in books}`.
  4. Validate stock for ALL items. Build `insufficient` list: for each cart item, if `book_map[item.book_id].stock_quantity < item.quantity`, append `InsufficientStockItem(book_id=item.book_id, title=book_map[item.book_id].title, requested=item.quantity, available=book_map[item.book_id].stock_quantity)`. If `insufficient` is non-empty, build detail message from the list and raise `AppError(409, "Insufficient stock for one or more items", "ORDER_INSUFFICIENT_STOCK")`.
  5. Call `self.payment_service.charge(force_fail=request.force_payment_failure)`. If returns `False`, raise `AppError(402, "Payment declined", "ORDER_PAYMENT_FAILED")`.
  6. Create order: `order = await self.order_repo.create_order(user_id, cart.items, book_map)`.
  7. Clear cart: delete all cart items via `for item in cart.items: await self.cart_repo.session.delete(item)` then `await self.cart_repo.session.flush()`. (Cart row itself remains for future use — consistent with `get_or_create` pattern.)
  8. Return order.

- `async def list_for_user(user_id: int) -> list[Order]`: Delegate to `self.order_repo.list_for_user(user_id)`.
- `async def get_order(user_id: int, order_id: int) -> Order`: Call `self.order_repo.get_by_id_for_user(order_id, user_id)`. If None, raise `AppError(404, "Order not found", "ORDER_NOT_FOUND")`.
- `async def list_all() -> list[Order]`: Delegate to `self.order_repo.list_all()`.

Import `CartRepository` from `app.cart.repository`.

**app/orders/router.py** — Create two routers:

1. `router = APIRouter(prefix="/orders", tags=["orders"])` — user-facing endpoints.
2. `admin_router = APIRouter(prefix="/admin/orders", tags=["admin"])` — admin endpoint.

`_make_service(db: DbSession) -> OrderService`: Instantiate with `OrderRepository(db)`, `CartRepository(db)`, `MockPaymentService()`.

Endpoints:
- `POST /checkout` (on `router`): `status_code=201`, `response_model=OrderResponse`. Takes `body: CheckoutRequest, db: DbSession, current_user: CurrentUser`. Casts `user_id = int(current_user["sub"])`. Calls `service.checkout(user_id, body)`. Returns `OrderResponse.model_validate(order)`.
- `GET /` (on `router`): `response_model=list[OrderResponse]`. Takes `db: DbSession, current_user: CurrentUser`. Returns list of `OrderResponse.model_validate(o)` for each order.
- `GET /{order_id}` (on `router`): `response_model=OrderResponse`. Takes `order_id: int, db: DbSession, current_user: CurrentUser`. Returns `OrderResponse.model_validate(order)`.
- `GET /` (on `admin_router`): `response_model=list[OrderResponse]`. Takes `db: DbSession, _: AdminUser`. Returns list of all orders.

Import `CurrentUser, AdminUser, DbSession` from `app.core.deps`.

**app/main.py** — Register both routers:
- Add `from app.orders.router import admin_router as orders_admin_router` and `from app.orders.router import router as orders_router` in the import section (maintain alphabetical order: books, cart, core, orders, users).
- Add `application.include_router(orders_router)` and `application.include_router(orders_admin_router)` after `cart_router` in `create_app()`.
  </action>
  <verify>
    <automated>cd D:/Python/claude-test && poetry run ruff check app/orders/ app/main.py && poetry run ruff format --check app/orders/ app/main.py && poetry run python -c "from app.main import app; routes = {r.path: list(r.methods) for r in app.routes if hasattr(r, 'methods')}; assert '/orders/checkout' in routes, f'Missing /orders/checkout in {routes}'; assert '/orders' in routes; assert '/orders/{order_id}' in routes; assert '/admin/orders' in routes; print('All 4 order routes registered')"</automated>
    <manual>Verify all 4 endpoints are importable and routes exist in the app</manual>
  </verify>
  <done>OrderService with checkout orchestration (lock -> validate stock -> payment -> create order -> clear cart), MockPaymentService with force_fail support, all 4 endpoints registered in FastAPI app, ruff passes</done>
</task>

</tasks>

<verification>
1. `poetry run ruff check app/orders/ alembic/ app/main.py` — zero violations
2. `poetry run ruff format --check app/orders/ alembic/ app/main.py` — already formatted
3. `python -c "from app.orders.models import Order, OrderItem, OrderStatus"` — imports succeed
4. `python -c "from app.orders.router import router, admin_router"` — imports succeed
5. `python -c "from app.main import app; ..."` — all 4 routes registered
6. All existing tests pass: `poetry run task test` — zero regressions (94 tests)
</verification>

<success_criteria>
- Order and OrderItem models defined with OrderStatus StrEnum (CONFIRMED, PAYMENT_FAILED)
- Migration d4e5f6a7b8c9 creates orders and order_items tables chaining off b2c3d4e5f6a7
- OrderRepository.lock_books() uses SELECT FOR UPDATE with ascending ID order
- OrderService.checkout() validates cart non-empty, locks books, checks stock, calls payment, creates order, decrements stock, clears cart — all in single transaction (no intermediate commits)
- MockPaymentService supports force_fail for deterministic test control
- POST /orders/checkout (201), GET /orders, GET /orders/{id}, GET /admin/orders all registered
- Admin endpoint requires AdminUser dependency
- All existing 94 tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-orders/07-01-SUMMARY.md`
</output>
