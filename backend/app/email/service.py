"""Email service for sending HTML emails via BackgroundTasks.

Emails are dispatched via BackgroundTasks (post-response), which runs AFTER
the DB session commits (see app/core/deps.py get_db). This structural guarantee
means email is never sent if the DB transaction rolls back.
"""

import logging
import re
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from functools import lru_cache
from pathlib import Path
from typing import Annotated

from fastapi import BackgroundTasks, Depends
from fastapi_mail import ConnectionConfig, FastMail
from jinja2 import Environment, FileSystemLoader

from app.core.config import get_settings

TEMPLATE_FOLDER = Path(__file__).parent / "templates"


def get_email_config() -> ConnectionConfig:
    """Build ConnectionConfig from application settings."""
    s = get_settings()
    return ConnectionConfig(
        MAIL_USERNAME=s.MAIL_USERNAME,
        MAIL_PASSWORD=s.MAIL_PASSWORD,
        MAIL_FROM=s.MAIL_FROM,
        MAIL_PORT=s.MAIL_PORT,
        MAIL_SERVER=s.MAIL_SERVER,
        MAIL_FROM_NAME=s.MAIL_FROM_NAME,
        MAIL_STARTTLS=True,
        MAIL_SSL_TLS=False,
        USE_CREDENTIALS=True,
        VALIDATE_CERTS=True,
        SUPPRESS_SEND=s.MAIL_SUPPRESS_SEND,
        TEMPLATE_FOLDER=TEMPLATE_FOLDER,
    )


class EmailService:
    """Reusable email service wrapping FastMail.

    Usage pattern (in routers):
        email_svc.enqueue(background_tasks, to, template_name, subject, context)

    The enqueue() method adds the send to BackgroundTasks. Because
    BackgroundTasks run AFTER the response is sent (which is after
    get_db commits), email is never dispatched if the DB transaction
    rolls back. This is a structural guarantee — see app/core/deps.py.
    """

    def __init__(self, config: ConnectionConfig) -> None:
        self.fm = FastMail(config)
        self._config = config
        self._logger = logging.getLogger(__name__)
        self._jinja_env = Environment(
            loader=FileSystemLoader(str(TEMPLATE_FOLDER)),
            autoescape=True,
        )

    @staticmethod
    def _strip_html(html: str) -> str:
        """Auto-generate plain-text fallback by stripping HTML tags.

        Block-level closing tags (</h1>, </p>, </div>, etc.) are replaced with
        a space before removal so adjacent text nodes are not run together.
        All remaining tags are then removed and whitespace is collapsed.
        """
        # Replace block-level closing tags with a space to separate text nodes
        text = re.sub(r'</(?:h[1-6]|p|div|li|tr|td|th|section|article|header|footer|main|nav|aside|blockquote|pre)>', ' ', html, flags=re.IGNORECASE)
        # Remove all remaining tags
        text = re.sub(r'<[^>]+>', '', text)
        # Collapse whitespace runs into single spaces
        return re.sub(r'\s+', ' ', text).strip()

    def _render_html(self, template_name: str, context: dict) -> str:
        """Render the Jinja2 template to a full HTML string."""
        template = self._jinja_env.get_template(template_name)
        return template.render(**context)

    def _render_plain_text(self, template_name: str, context: dict) -> str:
        """Render the Jinja2 template to HTML, then strip tags for plain-text fallback.

        This implements the CONTEXT.md locked decision: 'plain-text fallback
        auto-generated by stripping HTML tags from rendered output — no
        separate .txt templates'.
        """
        rendered_html = self._render_html(template_name, context)
        return self._strip_html(rendered_html)

    def enqueue(
        self,
        background_tasks: BackgroundTasks,
        to: str,
        template_name: str,
        subject: str,
        context: dict,
    ) -> None:
        """Add email send to BackgroundTasks (post-commit safe).

        Renders the Jinja2 template to HTML ourselves and builds a correct
        multipart/alternative MIME message with text/plain first and
        text/html second (RFC 2046 preference order). This bypasses a
        fastapi-mail bug that wraps multipart/alternative inside an extra
        multipart/related container, causing Gmail to show plain text.

        Args:
            background_tasks: FastAPI BackgroundTasks instance from the route.
            to: Recipient email address (single).
            template_name: Jinja2 template filename (e.g. "order_confirmation.html").
            subject: Email subject line.
            context: Dict of template variables passed to Jinja2.
        """
        html_body = self._render_html(template_name, context)
        plain_text = self._strip_html(html_body)

        msg = MIMEMultipart("alternative")
        msg["Subject"] = subject
        msg["From"] = f"{self._config.MAIL_FROM_NAME} <{self._config.MAIL_FROM}>"
        msg["To"] = to
        # RFC 2046: last part is preferred — attach plain first, HTML second
        msg.attach(MIMEText(plain_text, "plain", "utf-8"))
        msg.attach(MIMEText(html_body, "html", "utf-8"))

        background_tasks.add_task(self._send, msg, to)

    async def _send(self, message: MIMEMultipart, to: str) -> None:
        """Internal: send the email via SMTP. Logs and drops on failure."""
        if self._config.SUPPRESS_SEND:
            self._logger.info("Email suppressed (SUPPRESS_SEND=1): to=%s", to)
            return
        try:
            with smtplib.SMTP(self._config.MAIL_SERVER, self._config.MAIL_PORT) as server:
                server.starttls()
                password = self._config.MAIL_PASSWORD
                if hasattr(password, "get_secret_value"):
                    password = password.get_secret_value()
                server.login(self._config.MAIL_USERNAME, password)
                server.send_message(message)
        except Exception as exc:
            self._logger.error(
                "Email send failed: recipient=%s error=%s",
                to,
                str(exc),
            )


@lru_cache
def get_email_service() -> EmailService:
    """Return a cached EmailService instance.

    Cached via @lru_cache — FastMail(config) is reused across requests.
    In tests, call get_email_service.cache_clear() to reset.
    """
    return EmailService(config=get_email_config())


EmailSvc = Annotated[EmailService, Depends(get_email_service)]
